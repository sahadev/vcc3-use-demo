import "./chunk-73L62GNY.js";
import {
  Fragment,
  Teleport,
  Transition,
  computed,
  createApp,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  h,
  inject,
  isRef,
  isVNode,
  mergeProps,
  nextTick,
  onActivated,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onMounted,
  onUnmounted,
  onUpdated,
  provide,
  reactive,
  ref,
  resolveDirective,
  unref,
  vShow,
  watch,
  watchEffect,
  withDirectives
} from "./chunk-52N2MWM3.js";

// node_modules/vant/es/utils/basic.js
function noop() {
}
var extend = Object.assign;
var inBrowser = typeof window !== "undefined";
function get(object, path) {
  var keys = path.split(".");
  var result = object;
  keys.forEach((key) => {
    var _result$key;
    result = (_result$key = result[key]) != null ? _result$key : "";
  });
  return result;
}
function pick(obj, keys, ignoreUndefined) {
  return keys.reduce((ret, key) => {
    if (!ignoreUndefined || obj[key] !== void 0) {
      ret[key] = obj[key];
    }
    return ret;
  }, {});
}

// node_modules/vant/es/utils/props.js
var unknownProp = null;
var numericProp = [Number, String];
var truthProp = {
  type: Boolean,
  default: true
};
var makeRequiredProp = (type) => ({
  type,
  required: true
});
var makeArrayProp = () => ({
  type: Array,
  default: () => []
});
var makeNumberProp = (defaultVal) => ({
  type: Number,
  default: defaultVal
});
var makeNumericProp = (defaultVal) => ({
  type: numericProp,
  default: defaultVal
});
var makeStringProp = (defaultVal) => ({
  type: String,
  default: defaultVal
});

// node_modules/@vant/use/dist/esm/index.js
var inBrowser2 = typeof window !== "undefined";
function raf(fn2) {
  return inBrowser2 ? requestAnimationFrame(fn2) : -1;
}
function cancelRaf(id) {
  if (inBrowser2) {
    cancelAnimationFrame(id);
  }
}
function doubleRaf(fn2) {
  raf(() => raf(fn2));
}
var isWindow = (val) => val === window;
var makeDOMRect = (width2, height2) => ({
  top: 0,
  left: 0,
  right: width2,
  bottom: height2,
  width: width2,
  height: height2
});
var useRect = (elementOrRef) => {
  const element = unref(elementOrRef);
  if (isWindow(element)) {
    const width2 = element.innerWidth;
    const height2 = element.innerHeight;
    return makeDOMRect(width2, height2);
  }
  if (element == null ? void 0 : element.getBoundingClientRect) {
    return element.getBoundingClientRect();
  }
  return makeDOMRect(0, 0);
};
function useToggle(defaultValue = false) {
  const state = ref(defaultValue);
  const toggle = (value = !state.value) => {
    state.value = value;
  };
  return [state, toggle];
}
function useParent(key) {
  const parent = inject(key, null);
  if (parent) {
    const instance4 = getCurrentInstance();
    const { link, unlink, internalChildren } = parent;
    link(instance4);
    onUnmounted(() => unlink(instance4));
    const index = computed(() => internalChildren.indexOf(instance4));
    return {
      parent,
      index
    };
  }
  return {
    parent: null,
    index: ref(-1)
  };
}
function flattenVNodes(children) {
  const result = [];
  const traverse = (children2) => {
    if (Array.isArray(children2)) {
      children2.forEach((child) => {
        var _a;
        if (isVNode(child)) {
          result.push(child);
          if ((_a = child.component) == null ? void 0 : _a.subTree) {
            traverse(child.component.subTree.children);
          }
          if (child.children) {
            traverse(child.children);
          }
        }
      });
    }
  };
  traverse(children);
  return result;
}
function sortChildren(parent, publicChildren, internalChildren) {
  const vnodes = flattenVNodes(parent.subTree.children);
  internalChildren.sort((a, b) => vnodes.indexOf(a.vnode) - vnodes.indexOf(b.vnode));
  const orderedPublicChildren = internalChildren.map((item) => item.proxy);
  publicChildren.sort((a, b) => {
    const indexA = orderedPublicChildren.indexOf(a);
    const indexB = orderedPublicChildren.indexOf(b);
    return indexA - indexB;
  });
}
function useChildren(key) {
  const publicChildren = reactive([]);
  const internalChildren = reactive([]);
  const parent = getCurrentInstance();
  const linkChildren = (value) => {
    const link = (child) => {
      if (child.proxy) {
        internalChildren.push(child);
        publicChildren.push(child.proxy);
        sortChildren(parent, publicChildren, internalChildren);
      }
    };
    const unlink = (child) => {
      const index = internalChildren.indexOf(child);
      publicChildren.splice(index, 1);
      internalChildren.splice(index, 1);
    };
    provide(key, Object.assign({
      link,
      unlink,
      children: publicChildren,
      internalChildren
    }, value));
  };
  return {
    children: publicChildren,
    linkChildren
  };
}
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
function parseTime(time) {
  const days = Math.floor(time / DAY);
  const hours = Math.floor(time % DAY / HOUR);
  const minutes = Math.floor(time % HOUR / MINUTE);
  const seconds = Math.floor(time % MINUTE / SECOND);
  const milliseconds = Math.floor(time % SECOND);
  return {
    total: time,
    days,
    hours,
    minutes,
    seconds,
    milliseconds
  };
}
function isSameSecond(time1, time2) {
  return Math.floor(time1 / 1e3) === Math.floor(time2 / 1e3);
}
function useCountDown(options) {
  let rafId;
  let endTime;
  let counting;
  let deactivated;
  const remain = ref(options.time);
  const current2 = computed(() => parseTime(remain.value));
  const pause = () => {
    counting = false;
    cancelRaf(rafId);
  };
  const getCurrentRemain = () => Math.max(endTime - Date.now(), 0);
  const setRemain = (value) => {
    var _a, _b;
    remain.value = value;
    (_a = options.onChange) == null ? void 0 : _a.call(options, current2.value);
    if (value === 0) {
      pause();
      (_b = options.onFinish) == null ? void 0 : _b.call(options);
    }
  };
  const microTick = () => {
    rafId = raf(() => {
      if (counting) {
        setRemain(getCurrentRemain());
        if (remain.value > 0) {
          microTick();
        }
      }
    });
  };
  const macroTick = () => {
    rafId = raf(() => {
      if (counting) {
        const remainRemain = getCurrentRemain();
        if (!isSameSecond(remainRemain, remain.value) || remainRemain === 0) {
          setRemain(remainRemain);
        }
        if (remain.value > 0) {
          macroTick();
        }
      }
    });
  };
  const tick = () => {
    if (!inBrowser2) {
      return;
    }
    if (options.millisecond) {
      microTick();
    } else {
      macroTick();
    }
  };
  const start2 = () => {
    if (!counting) {
      endTime = Date.now() + remain.value;
      counting = true;
      tick();
    }
  };
  const reset = (totalTime = options.time) => {
    pause();
    remain.value = totalTime;
  };
  onBeforeUnmount(pause);
  onActivated(() => {
    if (deactivated) {
      counting = true;
      deactivated = false;
      tick();
    }
  });
  onDeactivated(() => {
    if (counting) {
      pause();
      deactivated = true;
    }
  });
  return {
    start: start2,
    pause,
    reset,
    current: current2
  };
}
function onMountedOrActivated(hook) {
  let mounted;
  onMounted(() => {
    hook();
    nextTick(() => {
      mounted = true;
    });
  });
  onActivated(() => {
    if (mounted) {
      hook();
    }
  });
}
function useEventListener(type, listener, options = {}) {
  if (!inBrowser2) {
    return;
  }
  const { target = window, passive: passive2 = false, capture = false } = options;
  let attached;
  const add = (target2) => {
    const element = unref(target2);
    if (element && !attached) {
      element.addEventListener(type, listener, { capture, passive: passive2 });
      attached = true;
    }
  };
  const remove2 = (target2) => {
    const element = unref(target2);
    if (element && attached) {
      element.removeEventListener(type, listener, capture);
      attached = false;
    }
  };
  onUnmounted(() => remove2(target));
  onDeactivated(() => remove2(target));
  onMountedOrActivated(() => add(target));
  if (isRef(target)) {
    watch(target, (val, oldVal) => {
      remove2(oldVal);
      add(val);
    });
  }
}
function useClickAway(target, listener, options = {}) {
  if (!inBrowser2) {
    return;
  }
  const { eventName = "click" } = options;
  const onClick = (event) => {
    const element = unref(target);
    if (element && !element.contains(event.target)) {
      listener(event);
    }
  };
  useEventListener(eventName, onClick, { target: document });
}
var width;
var height;
function useWindowSize() {
  if (!width) {
    width = ref(0);
    height = ref(0);
    if (inBrowser2) {
      const update = () => {
        width.value = window.innerWidth;
        height.value = window.innerHeight;
      };
      update();
      window.addEventListener("resize", update, { passive: true });
      window.addEventListener("orientationchange", update, { passive: true });
    }
  }
  return { width, height };
}
var overflowScrollReg = /scroll|auto/i;
var defaultRoot = inBrowser2 ? window : void 0;
function isElement(node) {
  const ELEMENT_NODE_TYPE = 1;
  return node.tagName !== "HTML" && node.tagName !== "BODY" && node.nodeType === ELEMENT_NODE_TYPE;
}
function getScrollParent(el, root = defaultRoot) {
  let node = el;
  while (node && node !== root && isElement(node)) {
    const { overflowY } = window.getComputedStyle(node);
    if (overflowScrollReg.test(overflowY)) {
      return node;
    }
    node = node.parentNode;
  }
  return root;
}
function useScrollParent(el, root = defaultRoot) {
  const scrollParent = ref();
  onMounted(() => {
    if (el.value) {
      scrollParent.value = getScrollParent(el.value, root);
    }
  });
  return scrollParent;
}
var visibility;
function usePageVisibility() {
  if (!visibility) {
    visibility = ref("visible");
    if (inBrowser2) {
      const update = () => {
        visibility.value = document.hidden ? "hidden" : "visible";
      };
      update();
      window.addEventListener("visibilitychange", update);
    }
  }
  return visibility;
}
var CUSTOM_FIELD_INJECTION_KEY = Symbol("van-field");
function useCustomFieldValue(customValue) {
  const field = inject(CUSTOM_FIELD_INJECTION_KEY, null);
  if (field && !field.customValue.value) {
    field.customValue.value = customValue;
    watch(customValue, () => {
      field.resetValidation();
      field.validateWithTrigger("onChange");
    });
  }
}

// node_modules/vant/es/utils/validate.js
var isDef = (val) => val !== void 0 && val !== null;
var isFunction = (val) => typeof val === "function";
var isObject = (val) => val !== null && typeof val === "object";
var isPromise = (val) => isObject(val) && isFunction(val.then) && isFunction(val.catch);
var isDate = (val) => Object.prototype.toString.call(val) === "[object Date]" && !Number.isNaN(val.getTime());
function isMobile(value) {
  value = value.replace(/[^-|\d]/g, "");
  return /^((\+86)|(86))?(1)\d{10}$/.test(value) || /^0[0-9-]{10,13}$/.test(value);
}
var isNumeric = (val) => typeof val === "number" || /^\d+(\.\d+)?$/.test(val);
var isIOS = () => inBrowser ? /ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()) : false;

// node_modules/vant/es/utils/dom.js
function getScrollTop(el) {
  var top2 = "scrollTop" in el ? el.scrollTop : el.pageYOffset;
  return Math.max(top2, 0);
}
function setScrollTop(el, value) {
  if ("scrollTop" in el) {
    el.scrollTop = value;
  } else {
    el.scrollTo(el.scrollX, value);
  }
}
function getRootScrollTop() {
  return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
}
function setRootScrollTop(value) {
  setScrollTop(window, value);
  setScrollTop(document.body, value);
}
function getElementTop(el, scroller) {
  if (el === window) {
    return 0;
  }
  var scrollTop = scroller ? getScrollTop(scroller) : getRootScrollTop();
  return useRect(el).top + scrollTop;
}
var isIOS2 = isIOS();
function resetScroll() {
  if (isIOS2) {
    setRootScrollTop(getRootScrollTop());
  }
}
var stopPropagation = (event) => event.stopPropagation();
function preventDefault(event, isStopPropagation) {
  if (typeof event.cancelable !== "boolean" || event.cancelable) {
    event.preventDefault();
  }
  if (isStopPropagation) {
    stopPropagation(event);
  }
}
function isHidden(elementRef) {
  var el = unref(elementRef);
  if (!el) {
    return false;
  }
  var style = window.getComputedStyle(el);
  var hidden = style.display === "none";
  var parentHidden = el.offsetParent === null && style.position !== "fixed";
  return hidden || parentHidden;
}
var {
  width: windowWidth,
  height: windowHeight
} = useWindowSize();

// node_modules/vant/es/utils/format.js
function addUnit(value) {
  if (isDef(value)) {
    return isNumeric(value) ? value + "px" : String(value);
  }
  return void 0;
}
function getSizeStyle(originSize) {
  if (isDef(originSize)) {
    var size = addUnit(originSize);
    return {
      width: size,
      height: size
    };
  }
}
function getZIndexStyle(zIndex) {
  var style = {};
  if (zIndex !== void 0) {
    style.zIndex = +zIndex;
  }
  return style;
}
var rootFontSize;
function getRootFontSize() {
  if (!rootFontSize) {
    var doc = document.documentElement;
    var fontSize = doc.style.fontSize || window.getComputedStyle(doc).fontSize;
    rootFontSize = parseFloat(fontSize);
  }
  return rootFontSize;
}
function convertRem(value) {
  value = value.replace(/rem/g, "");
  return +value * getRootFontSize();
}
function convertVw(value) {
  value = value.replace(/vw/g, "");
  return +value * windowWidth.value / 100;
}
function convertVh(value) {
  value = value.replace(/vh/g, "");
  return +value * windowHeight.value / 100;
}
function unitToPx(value) {
  if (typeof value === "number") {
    return value;
  }
  if (inBrowser) {
    if (value.includes("rem")) {
      return convertRem(value);
    }
    if (value.includes("vw")) {
      return convertVw(value);
    }
    if (value.includes("vh")) {
      return convertVh(value);
    }
  }
  return parseFloat(value);
}
var camelizeRE = /-(\w)/g;
var camelize = (str) => str.replace(camelizeRE, (_, c) => c.toUpperCase());
var kebabCase = (str) => str.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
function padZero(num, targetLength) {
  if (targetLength === void 0) {
    targetLength = 2;
  }
  var str = num + "";
  while (str.length < targetLength) {
    str = "0" + str;
  }
  return str;
}
var clamp = (num, min, max) => Math.min(Math.max(num, min), max);
function trimExtraChar(value, char, regExp) {
  var index = value.indexOf(char);
  if (index === -1) {
    return value;
  }
  if (char === "-" && index !== 0) {
    return value.slice(0, index);
  }
  return value.slice(0, index + 1) + value.slice(index).replace(regExp, "");
}
function formatNumber(value, allowDot, allowMinus) {
  if (allowDot === void 0) {
    allowDot = true;
  }
  if (allowMinus === void 0) {
    allowMinus = true;
  }
  if (allowDot) {
    value = trimExtraChar(value, ".", /\./g);
  } else {
    value = value.split(".")[0];
  }
  if (allowMinus) {
    value = trimExtraChar(value, "-", /-/g);
  } else {
    value = value.replace(/-/, "");
  }
  var regExp = allowDot ? /[^-0-9.]/g : /[^-0-9]/g;
  return value.replace(regExp, "");
}
function addNumber(num1, num2) {
  var cardinal = Math.pow(10, 10);
  return Math.round((num1 + num2) * cardinal) / cardinal;
}

// node_modules/vant/es/utils/deep-assign.js
var {
  hasOwnProperty
} = Object.prototype;
function assignKey(to, from, key) {
  var val = from[key];
  if (!isDef(val)) {
    return;
  }
  if (!hasOwnProperty.call(to, key) || !isObject(val)) {
    to[key] = val;
  } else {
    to[key] = deepAssign(Object(to[key]), val);
  }
}
function deepAssign(to, from) {
  Object.keys(from).forEach((key) => {
    assignKey(to, from, key);
  });
  return to;
}

// node_modules/vant/es/locale/lang/zh-CN.js
var zh_CN_default = {
  name: "\u59D3\u540D",
  tel: "\u7535\u8BDD",
  save: "\u4FDD\u5B58",
  confirm: "\u786E\u8BA4",
  cancel: "\u53D6\u6D88",
  delete: "\u5220\u9664",
  loading: "\u52A0\u8F7D\u4E2D...",
  noCoupon: "\u6682\u65E0\u4F18\u60E0\u5238",
  nameEmpty: "\u8BF7\u586B\u5199\u59D3\u540D",
  telInvalid: "\u8BF7\u586B\u5199\u6B63\u786E\u7684\u7535\u8BDD",
  vanCalendar: {
    end: "\u7ED3\u675F",
    start: "\u5F00\u59CB",
    title: "\u65E5\u671F\u9009\u62E9",
    confirm: "\u786E\u5B9A",
    startEnd: "\u5F00\u59CB/\u7ED3\u675F",
    weekdays: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
    monthTitle: (year, month) => year + "\u5E74" + month + "\u6708",
    rangePrompt: (maxRange) => "\u6700\u591A\u9009\u62E9 " + maxRange + " \u5929"
  },
  vanCascader: {
    select: "\u8BF7\u9009\u62E9"
  },
  vanContactCard: {
    addText: "\u6DFB\u52A0\u8054\u7CFB\u4EBA"
  },
  vanContactList: {
    addText: "\u65B0\u5EFA\u8054\u7CFB\u4EBA"
  },
  vanPagination: {
    prev: "\u4E0A\u4E00\u9875",
    next: "\u4E0B\u4E00\u9875"
  },
  vanPullRefresh: {
    pulling: "\u4E0B\u62C9\u5373\u53EF\u5237\u65B0...",
    loosing: "\u91CA\u653E\u5373\u53EF\u5237\u65B0..."
  },
  vanSubmitBar: {
    label: "\u5408\u8BA1\uFF1A"
  },
  vanCoupon: {
    unlimited: "\u65E0\u4F7F\u7528\u95E8\u69DB",
    discount: (discount) => discount + "\u6298",
    condition: (condition) => "\u6EE1" + condition + "\u5143\u53EF\u7528"
  },
  vanCouponCell: {
    title: "\u4F18\u60E0\u5238",
    count: (count) => count + "\u5F20\u53EF\u7528"
  },
  vanCouponList: {
    exchange: "\u5151\u6362",
    close: "\u4E0D\u4F7F\u7528\u4F18\u60E0\u5238",
    enable: "\u53EF\u7528",
    disabled: "\u4E0D\u53EF\u7528",
    placeholder: "\u8BF7\u8F93\u5165\u4F18\u60E0\u7801"
  },
  vanAddressEdit: {
    area: "\u5730\u533A",
    postal: "\u90AE\u653F\u7F16\u7801",
    areaEmpty: "\u8BF7\u9009\u62E9\u5730\u533A",
    addressEmpty: "\u8BF7\u586B\u5199\u8BE6\u7EC6\u5730\u5740",
    postalEmpty: "\u90AE\u653F\u7F16\u7801\u4E0D\u6B63\u786E",
    defaultAddress: "\u8BBE\u4E3A\u9ED8\u8BA4\u6536\u8D27\u5730\u5740"
  },
  vanAddressEditDetail: {
    label: "\u8BE6\u7EC6\u5730\u5740",
    placeholder: "\u8857\u9053\u95E8\u724C\u4FE1\u606F"
  },
  vanAddressList: {
    add: "\u65B0\u589E\u5730\u5740"
  }
};

// node_modules/vant/es/locale/index.js
var lang = ref("zh-CN");
var messages = reactive({
  "zh-CN": zh_CN_default
});
var Locale = {
  messages() {
    return messages[lang.value];
  },
  use(newLang, newMessages) {
    lang.value = newLang;
    this.add({
      [newLang]: newMessages
    });
  },
  add(newMessages) {
    if (newMessages === void 0) {
      newMessages = {};
    }
    deepAssign(messages, newMessages);
  }
};
var locale_default = Locale;

// node_modules/vant/es/utils/create.js
function createTranslate(name96) {
  var prefix2 = camelize(name96) + ".";
  return function(path) {
    var messages2 = locale_default.messages();
    var message = get(messages2, prefix2 + path) || get(messages2, path);
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return isFunction(message) ? message(...args) : message;
  };
}
function genBem(name96, mods) {
  if (!mods) {
    return "";
  }
  if (typeof mods === "string") {
    return " " + name96 + "--" + mods;
  }
  if (Array.isArray(mods)) {
    return mods.reduce((ret, item) => ret + genBem(name96, item), "");
  }
  return Object.keys(mods).reduce((ret, key) => ret + (mods[key] ? genBem(name96, key) : ""), "");
}
function createBEM(name96) {
  return (el, mods) => {
    if (el && typeof el !== "string") {
      mods = el;
      el = "";
    }
    el = el ? name96 + "__" + el : name96;
    return "" + el + genBem(el, mods);
  };
}
function createNamespace(name96) {
  var prefixedName = "van-" + name96;
  return [prefixedName, createBEM(prefixedName), createTranslate(prefixedName)];
}

// node_modules/vant/es/utils/constant.js
var BORDER = "van-hairline";
var BORDER_TOP = BORDER + "--top";
var BORDER_LEFT = BORDER + "--left";
var BORDER_BOTTOM = BORDER + "--bottom";
var BORDER_SURROUND = BORDER + "--surround";
var BORDER_TOP_BOTTOM = BORDER + "--top-bottom";
var BORDER_UNSET_TOP_BOTTOM = BORDER + "-unset--top-bottom";
var HAPTICS_FEEDBACK = "van-haptics-feedback";
var FORM_KEY = Symbol("van-form");

// node_modules/vant/es/utils/interceptor.js
function callInterceptor(interceptor, _ref) {
  var {
    args = [],
    done,
    canceled
  } = _ref;
  if (interceptor) {
    var returnVal = interceptor.apply(null, args);
    if (isPromise(returnVal)) {
      returnVal.then((value) => {
        if (value) {
          done();
        } else if (canceled) {
          canceled();
        }
      }).catch(noop);
    } else if (returnVal) {
      done();
    } else if (canceled) {
      canceled();
    }
  } else {
    done();
  }
}

// node_modules/vant/es/utils/with-install.js
function withInstall(options) {
  options.install = (app) => {
    var {
      name: name96
    } = options;
    app.component(name96, options);
    app.component(camelize("-" + name96), options);
  };
  return options;
}

// node_modules/vant/es/action-bar/ActionBar.js
var [name, bem] = createNamespace("action-bar");
var ACTION_BAR_KEY = Symbol(name);
var actionBarProps = {
  safeAreaInsetBottom: truthProp
};
var ActionBar_default = defineComponent({
  name,
  props: actionBarProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var {
      linkChildren
    } = useChildren(ACTION_BAR_KEY);
    linkChildren();
    return () => createVNode("div", {
      "class": [bem(), {
        "van-safe-area-bottom": props.safeAreaInsetBottom
      }]
    }, [slots.default == null ? void 0 : slots.default()]);
  }
});

// node_modules/vant/es/action-bar/index.js
var ActionBar = withInstall(ActionBar_default);

// node_modules/vant/es/composables/use-expose.js
function useExpose(apis) {
  var instance4 = getCurrentInstance();
  if (instance4) {
    extend(instance4.proxy, apis);
  }
}

// node_modules/vant/es/composables/use-route.js
var routeProps = {
  to: [String, Object],
  url: String,
  replace: Boolean
};
function route(_ref) {
  var {
    to,
    url,
    replace,
    $router: router
  } = _ref;
  if (to && router) {
    router[replace ? "replace" : "push"](to);
  } else if (url) {
    replace ? location.replace(url) : location.href = url;
  }
}
function useRoute() {
  var vm = getCurrentInstance().proxy;
  return () => route(vm);
}

// node_modules/vant/es/badge/Badge.js
var [name2, bem2] = createNamespace("badge");
var badgeProps = {
  dot: Boolean,
  max: numericProp,
  tag: makeStringProp("div"),
  color: String,
  offset: Array,
  content: numericProp,
  showZero: truthProp,
  position: makeStringProp("top-right")
};
var Badge_default = defineComponent({
  name: name2,
  props: badgeProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var hasContent = () => {
      if (slots.content) {
        return true;
      }
      var {
        content,
        showZero
      } = props;
      return isDef(content) && content !== "" && (showZero || content !== 0);
    };
    var renderContent = () => {
      var {
        dot,
        max,
        content
      } = props;
      if (!dot && hasContent()) {
        if (slots.content) {
          return slots.content();
        }
        if (isDef(max) && isNumeric(content) && +content > max) {
          return max + "+";
        }
        return content;
      }
    };
    var style = computed(() => {
      var style2 = {
        background: props.color
      };
      if (props.offset) {
        var [x, y] = props.offset;
        if (slots.default) {
          style2.top = addUnit(y);
          if (typeof x === "number") {
            style2.right = addUnit(-x);
          } else {
            style2.right = x.startsWith("-") ? x.replace("-", "") : "-" + x;
          }
        } else {
          style2.marginTop = addUnit(y);
          style2.marginLeft = addUnit(x);
        }
      }
      return style2;
    });
    var renderBadge = () => {
      if (hasContent() || props.dot) {
        return createVNode("div", {
          "class": bem2([props.position, {
            dot: props.dot,
            fixed: !!slots.default
          }]),
          "style": style.value
        }, [renderContent()]);
      }
    };
    return () => {
      if (slots.default) {
        var {
          tag
        } = props;
        return createVNode(tag, {
          "class": bem2("wrapper")
        }, {
          default: () => [slots.default(), renderBadge()]
        });
      }
      return renderBadge();
    };
  }
});

// node_modules/vant/es/badge/index.js
var Badge = withInstall(Badge_default);

// node_modules/vant/es/config-provider/ConfigProvider.js
var [name3, bem3] = createNamespace("config-provider");
var CONFIG_PROVIDER_KEY = Symbol(name3);
var configProviderProps = {
  tag: makeStringProp("div"),
  themeVars: Object,
  iconPrefix: String
};
function mapThemeVarsToCSSVars(themeVars) {
  var cssVars = {};
  Object.keys(themeVars).forEach((key) => {
    cssVars["--van-" + kebabCase(key)] = themeVars[key];
  });
  return cssVars;
}
var ConfigProvider_default = defineComponent({
  name: name3,
  props: configProviderProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var style = computed(() => {
      if (props.themeVars) {
        return mapThemeVarsToCSSVars(props.themeVars);
      }
    });
    provide(CONFIG_PROVIDER_KEY, props);
    return () => createVNode(props.tag, {
      "class": bem3(),
      "style": style.value
    }, {
      default: () => [slots.default == null ? void 0 : slots.default()]
    });
  }
});

// node_modules/vant/es/icon/Icon.js
var [name4, bem4] = createNamespace("icon");
var isImage = (name96) => name96 == null ? void 0 : name96.includes("/");
var iconProps = {
  dot: Boolean,
  tag: makeStringProp("i"),
  name: String,
  size: numericProp,
  badge: numericProp,
  color: String,
  classPrefix: String
};
var Icon_default = defineComponent({
  name: name4,
  props: iconProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var config = inject(CONFIG_PROVIDER_KEY, null);
    var classPrefix = computed(() => props.classPrefix || (config == null ? void 0 : config.iconPrefix) || bem4());
    return () => {
      var {
        tag,
        dot,
        name: name96,
        size,
        badge,
        color
      } = props;
      var isImageIcon = isImage(name96);
      return createVNode(Badge, {
        "dot": dot,
        "tag": tag,
        "content": badge,
        "class": [classPrefix.value, isImageIcon ? "" : classPrefix.value + "-" + name96],
        "style": {
          color,
          fontSize: addUnit(size)
        }
      }, {
        default: () => [slots.default == null ? void 0 : slots.default(), isImageIcon && createVNode("img", {
          "class": bem4("image"),
          "src": name96
        }, null)]
      });
    };
  }
});

// node_modules/vant/es/icon/index.js
var Icon = withInstall(Icon_default);

// node_modules/vant/es/loading/Loading.js
var [name5, bem5] = createNamespace("loading");
var SpinIcon = Array(12).fill(null).map((_, index) => createVNode("i", {
  "class": bem5("line", String(index + 1))
}, null));
var CircularIcon = createVNode("svg", {
  "class": bem5("circular"),
  "viewBox": "25 25 50 50"
}, [createVNode("circle", {
  "cx": "50",
  "cy": "50",
  "r": "20",
  "fill": "none"
}, null)]);
var loadingProps = {
  size: numericProp,
  type: makeStringProp("circular"),
  color: String,
  vertical: Boolean,
  textSize: numericProp,
  textColor: String
};
var Loading_default = defineComponent({
  name: name5,
  props: loadingProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var spinnerStyle = computed(() => extend({
      color: props.color
    }, getSizeStyle(props.size)));
    var renderText = () => {
      if (slots.default) {
        var _props$textColor;
        return createVNode("span", {
          "class": bem5("text"),
          "style": {
            fontSize: addUnit(props.textSize),
            color: (_props$textColor = props.textColor) != null ? _props$textColor : props.color
          }
        }, [slots.default()]);
      }
    };
    return () => {
      var {
        type,
        vertical
      } = props;
      return createVNode("div", {
        "class": bem5([type, {
          vertical
        }])
      }, [createVNode("span", {
        "class": bem5("spinner", type),
        "style": spinnerStyle.value
      }, [type === "spinner" ? SpinIcon : CircularIcon]), renderText()]);
    };
  }
});

// node_modules/vant/es/loading/index.js
var Loading = withInstall(Loading_default);

// node_modules/vant/es/button/Button.js
var [name6, bem6] = createNamespace("button");
var buttonProps = extend({}, routeProps, {
  tag: makeStringProp("button"),
  text: String,
  icon: String,
  type: makeStringProp("default"),
  size: makeStringProp("normal"),
  color: String,
  block: Boolean,
  plain: Boolean,
  round: Boolean,
  square: Boolean,
  loading: Boolean,
  hairline: Boolean,
  disabled: Boolean,
  iconPrefix: String,
  nativeType: makeStringProp("button"),
  loadingSize: numericProp,
  loadingText: String,
  loadingType: String,
  iconPosition: makeStringProp("left")
});
var Button_default = defineComponent({
  name: name6,
  props: buttonProps,
  emits: ["click"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var route2 = useRoute();
    var renderLoadingIcon = () => {
      if (slots.loading) {
        return slots.loading();
      }
      return createVNode(Loading, {
        "size": props.loadingSize,
        "type": props.loadingType,
        "class": bem6("loading")
      }, null);
    };
    var renderIcon = () => {
      if (props.loading) {
        return renderLoadingIcon();
      }
      if (slots.icon) {
        return createVNode("div", {
          "class": bem6("icon")
        }, [slots.icon()]);
      }
      if (props.icon) {
        return createVNode(Icon, {
          "name": props.icon,
          "class": bem6("icon"),
          "classPrefix": props.iconPrefix
        }, null);
      }
    };
    var renderText = () => {
      var text;
      if (props.loading) {
        text = props.loadingText;
      } else {
        text = slots.default ? slots.default() : props.text;
      }
      if (text) {
        return createVNode("span", {
          "class": bem6("text")
        }, [text]);
      }
    };
    var getStyle = () => {
      var {
        color,
        plain
      } = props;
      if (color) {
        var style = {
          color: plain ? color : "white"
        };
        if (!plain) {
          style.background = color;
        }
        if (color.includes("gradient")) {
          style.border = 0;
        } else {
          style.borderColor = color;
        }
        return style;
      }
    };
    var onClick = (event) => {
      if (props.loading) {
        preventDefault(event);
      } else if (!props.disabled) {
        emit("click", event);
        route2();
      }
    };
    return () => {
      var {
        tag,
        type,
        size,
        block,
        round: round2,
        plain,
        square,
        loading,
        disabled,
        hairline,
        nativeType,
        iconPosition
      } = props;
      var classes = [bem6([type, size, {
        plain,
        block,
        round: round2,
        square,
        loading,
        disabled,
        hairline
      }]), {
        [BORDER_SURROUND]: hairline
      }];
      return createVNode(tag, {
        "type": nativeType,
        "class": classes,
        "style": getStyle(),
        "disabled": disabled,
        "onClick": onClick
      }, {
        default: () => [createVNode("div", {
          "class": bem6("content")
        }, [iconPosition === "left" && renderIcon(), renderText(), iconPosition === "right" && renderIcon()])]
      });
    };
  }
});

// node_modules/vant/es/button/index.js
var Button = withInstall(Button_default);

// node_modules/vant/es/action-bar-button/ActionBarButton.js
var [name7, bem7] = createNamespace("action-bar-button");
var actionBarButtonProps = extend({}, routeProps, {
  type: String,
  text: String,
  icon: String,
  color: String,
  loading: Boolean,
  disabled: Boolean
});
var ActionBarButton_default = defineComponent({
  name: name7,
  props: actionBarButtonProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var route2 = useRoute();
    var {
      parent,
      index
    } = useParent(ACTION_BAR_KEY);
    var isFirst = computed(() => {
      if (parent) {
        var prev = parent.children[index.value - 1];
        return !(prev && "isButton" in prev);
      }
    });
    var isLast = computed(() => {
      if (parent) {
        var next = parent.children[index.value + 1];
        return !(next && "isButton" in next);
      }
    });
    useExpose({
      isButton: true
    });
    return () => {
      var {
        type,
        icon,
        text,
        color,
        loading,
        disabled
      } = props;
      return createVNode(Button, {
        "class": bem7([type, {
          last: isLast.value,
          first: isFirst.value
        }]),
        "size": "large",
        "type": type,
        "icon": icon,
        "color": color,
        "loading": loading,
        "disabled": disabled,
        "onClick": route2
      }, {
        default: () => [slots.default ? slots.default() : text]
      });
    };
  }
});

// node_modules/vant/es/action-bar-button/index.js
var ActionBarButton = withInstall(ActionBarButton_default);

// node_modules/vant/es/action-bar-icon/ActionBarIcon.js
var [name8, bem8] = createNamespace("action-bar-icon");
var actionBarIconProps = extend({}, routeProps, {
  dot: Boolean,
  text: String,
  icon: String,
  color: String,
  badge: numericProp,
  iconClass: unknownProp,
  iconPrefix: String
});
var ActionBarIcon_default = defineComponent({
  name: name8,
  props: actionBarIconProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var route2 = useRoute();
    useParent(ACTION_BAR_KEY);
    var renderIcon = () => {
      var {
        dot,
        badge,
        icon,
        color,
        iconClass,
        iconPrefix
      } = props;
      if (slots.icon) {
        return createVNode(Badge, {
          "dot": dot,
          "content": badge,
          "class": bem8("icon")
        }, {
          default: slots.icon
        });
      }
      return createVNode(Icon, {
        "tag": "div",
        "dot": dot,
        "name": icon,
        "badge": badge,
        "color": color,
        "class": [bem8("icon"), iconClass],
        "classPrefix": iconPrefix
      }, null);
    };
    return () => createVNode("div", {
      "role": "button",
      "class": bem8(),
      "tabindex": 0,
      "onClick": route2
    }, [renderIcon(), slots.default ? slots.default() : props.text]);
  }
});

// node_modules/vant/es/action-bar-icon/index.js
var ActionBarIcon = withInstall(ActionBarIcon_default);

// node_modules/vant/es/popup/shared.js
var popupSharedProps = {
  show: Boolean,
  zIndex: numericProp,
  overlay: truthProp,
  duration: numericProp,
  teleport: [String, Object],
  lockScroll: truthProp,
  lazyRender: truthProp,
  beforeClose: Function,
  overlayStyle: Object,
  overlayClass: unknownProp,
  transitionAppear: Boolean,
  closeOnClickOverlay: truthProp
};
var popupSharedPropKeys = Object.keys(popupSharedProps);

// node_modules/vant/es/composables/use-touch.js
var MIN_DISTANCE = 10;
function getDirection(x, y) {
  if (x > y && x > MIN_DISTANCE) {
    return "horizontal";
  }
  if (y > x && y > MIN_DISTANCE) {
    return "vertical";
  }
  return "";
}
function useTouch() {
  var startX = ref(0);
  var startY = ref(0);
  var deltaX = ref(0);
  var deltaY = ref(0);
  var offsetX = ref(0);
  var offsetY = ref(0);
  var direction = ref("");
  var isVertical = () => direction.value === "vertical";
  var isHorizontal = () => direction.value === "horizontal";
  var reset = () => {
    deltaX.value = 0;
    deltaY.value = 0;
    offsetX.value = 0;
    offsetY.value = 0;
    direction.value = "";
  };
  var start2 = (event) => {
    reset();
    startX.value = event.touches[0].clientX;
    startY.value = event.touches[0].clientY;
  };
  var move = (event) => {
    var touch = event.touches[0];
    deltaX.value = touch.clientX < 0 ? 0 : touch.clientX - startX.value;
    deltaY.value = touch.clientY - startY.value;
    offsetX.value = Math.abs(deltaX.value);
    offsetY.value = Math.abs(deltaY.value);
    if (!direction.value) {
      direction.value = getDirection(offsetX.value, offsetY.value);
    }
  };
  return {
    move,
    start: start2,
    reset,
    startX,
    startY,
    deltaX,
    deltaY,
    offsetX,
    offsetY,
    direction,
    isVertical,
    isHorizontal
  };
}

// node_modules/vant/es/composables/use-lock-scroll.js
var totalLockCount = 0;
var BODY_LOCK_CLASS = "van-overflow-hidden";
function useLockScroll(rootRef, shouldLock) {
  var touch = useTouch();
  var onTouchMove = (event) => {
    touch.move(event);
    var direction = touch.deltaY.value > 0 ? "10" : "01";
    var el = getScrollParent(event.target, rootRef.value);
    var {
      scrollHeight,
      offsetHeight,
      scrollTop
    } = el;
    var status = "11";
    if (scrollTop === 0) {
      status = offsetHeight >= scrollHeight ? "00" : "01";
    } else if (scrollTop + offsetHeight >= scrollHeight) {
      status = "10";
    }
    if (status !== "11" && touch.isVertical() && !(parseInt(status, 2) & parseInt(direction, 2))) {
      preventDefault(event, true);
    }
  };
  var lock = () => {
    document.addEventListener("touchstart", touch.start);
    document.addEventListener("touchmove", onTouchMove, {
      passive: false
    });
    if (!totalLockCount) {
      document.body.classList.add(BODY_LOCK_CLASS);
    }
    totalLockCount++;
  };
  var unlock = () => {
    if (totalLockCount) {
      document.removeEventListener("touchstart", touch.start);
      document.removeEventListener("touchmove", onTouchMove);
      totalLockCount--;
      if (!totalLockCount) {
        document.body.classList.remove(BODY_LOCK_CLASS);
      }
    }
  };
  var init = () => shouldLock() && lock();
  var destroy = () => shouldLock() && unlock();
  onMountedOrActivated(init);
  onDeactivated(destroy);
  onBeforeUnmount(destroy);
  watch(shouldLock, (value) => {
    value ? lock() : unlock();
  });
}

// node_modules/vant/es/composables/use-lazy-render.js
function useLazyRender(show) {
  var inited = ref(false);
  watch(show, (value) => {
    if (value) {
      inited.value = value;
    }
  }, {
    immediate: true
  });
  return (render) => () => inited.value ? render() : null;
}

// node_modules/vant/es/composables/on-popup-reopen.js
var POPUP_TOGGLE_KEY = Symbol();
function onPopupReopen(callback) {
  var popupToggleStatus = inject(POPUP_TOGGLE_KEY, null);
  if (popupToggleStatus) {
    watch(popupToggleStatus, (show) => {
      if (show) {
        callback();
      }
    });
  }
}

// node_modules/vant/es/overlay/Overlay.js
var [name9, bem9] = createNamespace("overlay");
var overlayProps = {
  show: Boolean,
  zIndex: numericProp,
  duration: numericProp,
  className: unknownProp,
  lockScroll: truthProp,
  customStyle: Object
};
var Overlay_default = defineComponent({
  name: name9,
  props: overlayProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var lazyRender = useLazyRender(() => props.show);
    var preventTouchMove = (event) => {
      preventDefault(event, true);
    };
    var renderOverlay = lazyRender(() => {
      var style = extend(getZIndexStyle(props.zIndex), props.customStyle);
      if (isDef(props.duration)) {
        style.animationDuration = props.duration + "s";
      }
      return withDirectives(createVNode("div", {
        "style": style,
        "class": [bem9(), props.className],
        "onTouchmove": props.lockScroll ? preventTouchMove : noop
      }, [slots.default == null ? void 0 : slots.default()]), [[vShow, props.show]]);
    });
    return () => createVNode(Transition, {
      "name": "van-fade",
      "appear": true
    }, {
      default: renderOverlay
    });
  }
});

// node_modules/vant/es/overlay/index.js
var Overlay = withInstall(Overlay_default);

// node_modules/vant/es/popup/Popup.js
var popupProps = extend({}, popupSharedProps, {
  round: Boolean,
  position: makeStringProp("center"),
  closeIcon: makeStringProp("cross"),
  closeable: Boolean,
  transition: String,
  iconPrefix: String,
  closeOnPopstate: Boolean,
  closeIconPosition: makeStringProp("top-right"),
  safeAreaInsetBottom: Boolean
});
var [name10, bem10] = createNamespace("popup");
var globalZIndex = 2e3;
var Popup_default = defineComponent({
  name: name10,
  inheritAttrs: false,
  props: popupProps,
  emits: ["open", "close", "opened", "closed", "update:show", "click-overlay", "click-close-icon"],
  setup(props, _ref) {
    var {
      emit,
      attrs,
      slots
    } = _ref;
    var opened;
    var shouldReopen;
    var zIndex = ref();
    var popupRef = ref();
    var lazyRender = useLazyRender(() => props.show || !props.lazyRender);
    var style = computed(() => {
      var style2 = {
        zIndex: zIndex.value
      };
      if (isDef(props.duration)) {
        var key = props.position === "center" ? "animationDuration" : "transitionDuration";
        style2[key] = props.duration + "s";
      }
      return style2;
    });
    var open = () => {
      if (!opened) {
        if (props.zIndex !== void 0) {
          globalZIndex = +props.zIndex;
        }
        opened = true;
        zIndex.value = ++globalZIndex;
        emit("open");
      }
    };
    var close = () => {
      if (opened) {
        callInterceptor(props.beforeClose, {
          done() {
            opened = false;
            emit("close");
            emit("update:show", false);
          }
        });
      }
    };
    var onClickOverlay = (event) => {
      emit("click-overlay", event);
      if (props.closeOnClickOverlay) {
        close();
      }
    };
    var renderOverlay = () => {
      if (props.overlay) {
        return createVNode(Overlay, {
          "show": props.show,
          "class": props.overlayClass,
          "zIndex": zIndex.value,
          "duration": props.duration,
          "customStyle": props.overlayStyle,
          "onClick": onClickOverlay
        }, {
          default: slots["overlay-content"]
        });
      }
    };
    var onClickCloseIcon = (event) => {
      emit("click-close-icon", event);
      close();
    };
    var renderCloseIcon = () => {
      if (props.closeable) {
        return createVNode(Icon, {
          "role": "button",
          "tabindex": 0,
          "name": props.closeIcon,
          "class": [bem10("close-icon", props.closeIconPosition), HAPTICS_FEEDBACK],
          "classPrefix": props.iconPrefix,
          "onClick": onClickCloseIcon
        }, null);
      }
    };
    var onOpened = () => emit("opened");
    var onClosed = () => emit("closed");
    var renderPopup = lazyRender(() => {
      var {
        round: round2,
        position,
        safeAreaInsetBottom
      } = props;
      return withDirectives(createVNode("div", mergeProps({
        "ref": popupRef,
        "style": style.value,
        "class": [bem10({
          round: round2,
          [position]: position
        }), {
          "van-safe-area-bottom": safeAreaInsetBottom
        }]
      }, attrs), [slots.default == null ? void 0 : slots.default(), renderCloseIcon()]), [[vShow, props.show]]);
    });
    var renderTransition = () => {
      var {
        position,
        transition,
        transitionAppear
      } = props;
      var name96 = position === "center" ? "van-fade" : "van-popup-slide-" + position;
      return createVNode(Transition, {
        "name": transition || name96,
        "appear": transitionAppear,
        "onAfterEnter": onOpened,
        "onAfterLeave": onClosed
      }, {
        default: renderPopup
      });
    };
    watch(() => props.show, (value) => {
      if (value) {
        open();
      } else {
        opened = false;
        emit("close");
      }
    });
    useExpose({
      popupRef
    });
    useLockScroll(popupRef, () => props.show && props.lockScroll);
    useEventListener("popstate", () => {
      if (props.closeOnPopstate) {
        close();
        shouldReopen = false;
      }
    });
    onMounted(() => {
      if (props.show) {
        open();
      }
    });
    onActivated(() => {
      if (shouldReopen) {
        emit("update:show", true);
        shouldReopen = false;
      }
    });
    onDeactivated(() => {
      if (props.show) {
        close();
        shouldReopen = true;
      }
    });
    provide(POPUP_TOGGLE_KEY, () => props.show);
    return () => {
      if (props.teleport) {
        return createVNode(Teleport, {
          "to": props.teleport
        }, {
          default: () => [renderOverlay(), renderTransition()]
        });
      }
      return createVNode(Fragment, null, [renderOverlay(), renderTransition()]);
    };
  }
});

// node_modules/vant/es/popup/index.js
var Popup = withInstall(Popup_default);

// node_modules/vant/es/action-sheet/ActionSheet.js
var [name11, bem11] = createNamespace("action-sheet");
var actionSheetProps = extend({}, popupSharedProps, {
  title: String,
  round: truthProp,
  actions: makeArrayProp(),
  closeIcon: makeStringProp("cross"),
  closeable: truthProp,
  cancelText: String,
  description: String,
  closeOnPopstate: truthProp,
  closeOnClickAction: Boolean,
  safeAreaInsetBottom: truthProp
});
var popupInheritKeys = [...popupSharedPropKeys, "round", "closeOnPopstate", "safeAreaInsetBottom"];
var ActionSheet_default = defineComponent({
  name: name11,
  props: actionSheetProps,
  emits: ["select", "cancel", "update:show"],
  setup(props, _ref) {
    var {
      slots,
      emit
    } = _ref;
    var updateShow = (show) => emit("update:show", show);
    var onCancel = () => {
      updateShow(false);
      emit("cancel");
    };
    var renderHeader = () => {
      if (props.title) {
        return createVNode("div", {
          "class": bem11("header")
        }, [props.title, props.closeable && createVNode(Icon, {
          "name": props.closeIcon,
          "class": [bem11("close"), HAPTICS_FEEDBACK],
          "onClick": onCancel
        }, null)]);
      }
    };
    var renderCancel = () => {
      if (slots.cancel || props.cancelText) {
        return [createVNode("div", {
          "class": bem11("gap")
        }, null), createVNode("button", {
          "type": "button",
          "class": bem11("cancel"),
          "onClick": onCancel
        }, [slots.cancel ? slots.cancel() : props.cancelText])];
      }
    };
    var renderOption = (item, index) => {
      var {
        name: name96,
        color,
        subname,
        loading,
        callback,
        disabled,
        className
      } = item;
      var Content = loading ? createVNode(Loading, {
        "class": bem11("loading-icon")
      }, null) : [createVNode("span", {
        "class": bem11("name")
      }, [name96]), subname && createVNode("div", {
        "class": bem11("subname")
      }, [subname])];
      var onClick = () => {
        if (disabled || loading) {
          return;
        }
        if (callback) {
          callback(item);
        }
        if (props.closeOnClickAction) {
          updateShow(false);
        }
        nextTick(() => emit("select", item, index));
      };
      return createVNode("button", {
        "type": "button",
        "style": {
          color
        },
        "class": [bem11("item", {
          loading,
          disabled
        }), className],
        "onClick": onClick
      }, [Content]);
    };
    var renderDescription = () => {
      if (props.description || slots.description) {
        var content = slots.description ? slots.description() : props.description;
        return createVNode("div", {
          "class": bem11("description")
        }, [content]);
      }
    };
    return () => createVNode(Popup, mergeProps({
      "class": bem11(),
      "position": "bottom",
      "onUpdate:show": updateShow
    }, pick(props, popupInheritKeys)), {
      default: () => [renderHeader(), renderDescription(), createVNode("div", {
        "class": bem11("content")
      }, [props.actions.map(renderOption), slots.default == null ? void 0 : slots.default()]), renderCancel()]
    });
  }
});

// node_modules/vant/es/action-sheet/index.js
var ActionSheet = withInstall(ActionSheet_default);

// node_modules/vant/es/utils/deep-clone.js
function deepClone(obj) {
  if (!isDef(obj)) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => deepClone(item));
  }
  if (isObject(obj)) {
    var to = {};
    Object.keys(obj).forEach((key) => {
      to[key] = deepClone(obj[key]);
    });
    return to;
  }
  return obj;
}

// node_modules/vant/es/picker/PickerColumn.js
var DEFAULT_DURATION = 200;
var MOMENTUM_LIMIT_TIME = 300;
var MOMENTUM_LIMIT_DISTANCE = 15;
var [name12, bem12] = createNamespace("picker-column");
function getElementTranslateY(element) {
  var {
    transform
  } = window.getComputedStyle(element);
  var translateY = transform.slice(7, transform.length - 1).split(", ")[5];
  return Number(translateY);
}
var PICKER_KEY = Symbol(name12);
var isOptionDisabled = (option) => isObject(option) && option.disabled;
var PickerColumn_default = defineComponent({
  name: name12,
  props: {
    textKey: makeRequiredProp(String),
    readonly: Boolean,
    allowHtml: Boolean,
    className: unknownProp,
    itemHeight: makeRequiredProp(Number),
    defaultIndex: makeNumberProp(0),
    swipeDuration: makeRequiredProp(numericProp),
    initialOptions: makeArrayProp(),
    visibleItemCount: makeRequiredProp(numericProp)
  },
  emits: ["change"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var moving;
    var startOffset;
    var touchStartTime;
    var momentumOffset;
    var transitionEndTrigger;
    var wrapper = ref();
    var state = reactive({
      index: props.defaultIndex,
      offset: 0,
      duration: 0,
      options: deepClone(props.initialOptions)
    });
    var touch = useTouch();
    var count = () => state.options.length;
    var baseOffset = () => props.itemHeight * (+props.visibleItemCount - 1) / 2;
    var adjustIndex = (index) => {
      index = clamp(index, 0, count());
      for (var i = index; i < count(); i++) {
        if (!isOptionDisabled(state.options[i]))
          return i;
      }
      for (var _i = index - 1; _i >= 0; _i--) {
        if (!isOptionDisabled(state.options[_i]))
          return _i;
      }
    };
    var setIndex = (index, emitChange) => {
      index = adjustIndex(index) || 0;
      var offset2 = -index * props.itemHeight;
      var trigger = () => {
        if (index !== state.index) {
          state.index = index;
          if (emitChange) {
            emit("change", index);
          }
        }
      };
      if (moving && offset2 !== state.offset) {
        transitionEndTrigger = trigger;
      } else {
        trigger();
      }
      state.offset = offset2;
    };
    var setOptions = (options) => {
      if (JSON.stringify(options) !== JSON.stringify(state.options)) {
        state.options = deepClone(options);
        setIndex(props.defaultIndex);
      }
    };
    var onClickItem = (index) => {
      if (moving || props.readonly) {
        return;
      }
      transitionEndTrigger = null;
      state.duration = DEFAULT_DURATION;
      setIndex(index, true);
    };
    var getOptionText = (option) => {
      if (isObject(option) && props.textKey in option) {
        return option[props.textKey];
      }
      return option;
    };
    var getIndexByOffset = (offset2) => clamp(Math.round(-offset2 / props.itemHeight), 0, count() - 1);
    var momentum = (distance, duration) => {
      var speed = Math.abs(distance / duration);
      distance = state.offset + speed / 3e-3 * (distance < 0 ? -1 : 1);
      var index = getIndexByOffset(distance);
      state.duration = +props.swipeDuration;
      setIndex(index, true);
    };
    var stopMomentum = () => {
      moving = false;
      state.duration = 0;
      if (transitionEndTrigger) {
        transitionEndTrigger();
        transitionEndTrigger = null;
      }
    };
    var onTouchStart = (event) => {
      if (props.readonly) {
        return;
      }
      touch.start(event);
      if (moving) {
        var translateY = getElementTranslateY(wrapper.value);
        state.offset = Math.min(0, translateY - baseOffset());
        startOffset = state.offset;
      } else {
        startOffset = state.offset;
      }
      state.duration = 0;
      touchStartTime = Date.now();
      momentumOffset = startOffset;
      transitionEndTrigger = null;
    };
    var onTouchMove = (event) => {
      if (props.readonly) {
        return;
      }
      touch.move(event);
      if (touch.isVertical()) {
        moving = true;
        preventDefault(event, true);
      }
      state.offset = clamp(startOffset + touch.deltaY.value, -(count() * props.itemHeight), props.itemHeight);
      var now = Date.now();
      if (now - touchStartTime > MOMENTUM_LIMIT_TIME) {
        touchStartTime = now;
        momentumOffset = state.offset;
      }
    };
    var onTouchEnd = () => {
      if (props.readonly) {
        return;
      }
      var distance = state.offset - momentumOffset;
      var duration = Date.now() - touchStartTime;
      var allowMomentum = duration < MOMENTUM_LIMIT_TIME && Math.abs(distance) > MOMENTUM_LIMIT_DISTANCE;
      if (allowMomentum) {
        momentum(distance, duration);
        return;
      }
      var index = getIndexByOffset(state.offset);
      state.duration = DEFAULT_DURATION;
      setIndex(index, true);
      setTimeout(() => {
        moving = false;
      }, 0);
    };
    var renderOptions = () => {
      var optionStyle = {
        height: props.itemHeight + "px"
      };
      return state.options.map((option, index) => {
        var text = getOptionText(option);
        var disabled = isOptionDisabled(option);
        var data = {
          role: "button",
          style: optionStyle,
          tabindex: disabled ? -1 : 0,
          class: bem12("item", {
            disabled,
            selected: index === state.index
          }),
          onClick: () => onClickItem(index)
        };
        var childData = {
          class: "van-ellipsis",
          [props.allowHtml ? "innerHTML" : "textContent"]: text
        };
        return createVNode("li", data, [slots.option ? slots.option(option) : createVNode("div", childData, null)]);
      });
    };
    var setValue = (value) => {
      var {
        options
      } = state;
      for (var i = 0; i < options.length; i++) {
        if (getOptionText(options[i]) === value) {
          return setIndex(i);
        }
      }
    };
    var getValue = () => state.options[state.index];
    setIndex(state.index);
    useParent(PICKER_KEY);
    useExpose({
      state,
      setIndex,
      getValue,
      setValue,
      setOptions,
      stopMomentum
    });
    watch(() => props.initialOptions, setOptions);
    watch(() => props.defaultIndex, (value) => setIndex(value));
    return () => createVNode("div", {
      "class": [bem12(), props.className],
      "onTouchstart": onTouchStart,
      "onTouchmove": onTouchMove,
      "onTouchend": onTouchEnd,
      "onTouchcancel": onTouchEnd
    }, [createVNode("ul", {
      "ref": wrapper,
      "style": {
        transform: "translate3d(0, " + (state.offset + baseOffset()) + "px, 0)",
        transitionDuration: state.duration + "ms",
        transitionProperty: state.duration ? "all" : "none"
      },
      "class": bem12("wrapper"),
      "onTransitionend": stopMomentum
    }, [renderOptions()])]);
  }
});

// node_modules/vant/es/picker/Picker.js
var [name13, bem13, t] = createNamespace("picker");
var pickerSharedProps = {
  title: String,
  loading: Boolean,
  readonly: Boolean,
  allowHtml: Boolean,
  itemHeight: makeNumericProp(44),
  showToolbar: truthProp,
  swipeDuration: makeNumericProp(1e3),
  visibleItemCount: makeNumericProp(6),
  cancelButtonText: String,
  confirmButtonText: String
};
var pickerProps = extend({}, pickerSharedProps, {
  columns: makeArrayProp(),
  valueKey: String,
  defaultIndex: makeNumericProp(0),
  toolbarPosition: makeStringProp("top"),
  columnsFieldNames: Object
});
var Picker_default = defineComponent({
  name: name13,
  props: pickerProps,
  emits: ["confirm", "cancel", "change"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    if (true) {
      if (slots.default) {
        console.warn('[Vant] Picker: "default" slot is deprecated, please use "toolbar" slot instead.');
      }
      if (props.valueKey) {
        console.warn('[Vant] Picker: "valueKey" prop is deprecated, please use "columnsFieldNames" prop instead.');
      }
    }
    var formattedColumns = ref([]);
    var {
      text: textKey,
      values: valuesKey,
      children: childrenKey
    } = extend({
      text: props.valueKey || "text",
      values: "values",
      children: "children"
    }, props.columnsFieldNames);
    var {
      children,
      linkChildren
    } = useChildren(PICKER_KEY);
    linkChildren();
    var itemHeight = computed(() => unitToPx(props.itemHeight));
    var dataType = computed(() => {
      var firstColumn = props.columns[0];
      if (typeof firstColumn === "object") {
        if (childrenKey in firstColumn) {
          return "cascade";
        }
        if (valuesKey in firstColumn) {
          return "object";
        }
      }
      return "plain";
    });
    var formatCascade = () => {
      var formatted = [];
      var cursor = {
        [childrenKey]: props.columns
      };
      while (cursor && cursor[childrenKey]) {
        var _cursor$defaultIndex;
        var _children = cursor[childrenKey];
        var defaultIndex = (_cursor$defaultIndex = cursor.defaultIndex) != null ? _cursor$defaultIndex : +props.defaultIndex;
        while (_children[defaultIndex] && _children[defaultIndex].disabled) {
          if (defaultIndex < _children.length - 1) {
            defaultIndex++;
          } else {
            defaultIndex = 0;
            break;
          }
        }
        formatted.push({
          [valuesKey]: cursor[childrenKey],
          className: cursor.className,
          defaultIndex
        });
        cursor = _children[defaultIndex];
      }
      formattedColumns.value = formatted;
    };
    var format3 = () => {
      var {
        columns
      } = props;
      if (dataType.value === "plain") {
        formattedColumns.value = [{
          [valuesKey]: columns
        }];
      } else if (dataType.value === "cascade") {
        formatCascade();
      } else {
        formattedColumns.value = columns;
      }
    };
    var getIndexes = () => children.map((child) => child.state.index);
    var setColumnValues = (index, options) => {
      var column = children[index];
      if (column) {
        column.setOptions(options);
      }
    };
    var onCascadeChange = (columnIndex) => {
      var cursor = {
        [childrenKey]: props.columns
      };
      var indexes = getIndexes();
      for (var i = 0; i <= columnIndex; i++) {
        cursor = cursor[childrenKey][indexes[i]];
      }
      while (cursor && cursor[childrenKey]) {
        columnIndex++;
        setColumnValues(columnIndex, cursor[childrenKey]);
        cursor = cursor[childrenKey][cursor.defaultIndex || 0];
      }
    };
    var getChild = (index) => children[index];
    var getColumnValue = (index) => {
      var column = getChild(index);
      if (column) {
        return column.getValue();
      }
    };
    var setColumnValue = (index, value) => {
      var column = getChild(index);
      if (column) {
        column.setValue(value);
        if (dataType.value === "cascade") {
          onCascadeChange(index);
        }
      }
    };
    var getColumnIndex = (index) => {
      var column = getChild(index);
      if (column) {
        return column.state.index;
      }
    };
    var setColumnIndex = (columnIndex, optionIndex) => {
      var column = getChild(columnIndex);
      if (column) {
        column.setIndex(optionIndex);
        if (dataType.value === "cascade") {
          onCascadeChange(columnIndex);
        }
      }
    };
    var getColumnValues = (index) => {
      var column = getChild(index);
      if (column) {
        return column.state.options;
      }
    };
    var getValues = () => children.map((child) => child.getValue());
    var setValues = (values) => {
      values.forEach((value, index) => {
        setColumnValue(index, value);
      });
    };
    var setIndexes = (indexes) => {
      indexes.forEach((optionIndex, columnIndex) => {
        setColumnIndex(columnIndex, optionIndex);
      });
    };
    var emitAction = (event) => {
      if (dataType.value === "plain") {
        emit(event, getColumnValue(0), getColumnIndex(0));
      } else {
        emit(event, getValues(), getIndexes());
      }
    };
    var onChange = (columnIndex) => {
      if (dataType.value === "cascade") {
        onCascadeChange(columnIndex);
      }
      if (dataType.value === "plain") {
        emit("change", getColumnValue(0), getColumnIndex(0));
      } else {
        emit("change", getValues(), columnIndex);
      }
    };
    var confirm = () => {
      children.forEach((child) => child.stopMomentum());
      emitAction("confirm");
    };
    var cancel = () => emitAction("cancel");
    var renderTitle = () => {
      if (slots.title) {
        return slots.title();
      }
      if (props.title) {
        return createVNode("div", {
          "class": [bem13("title"), "van-ellipsis"]
        }, [props.title]);
      }
    };
    var renderCancel = () => {
      var text = props.cancelButtonText || t("cancel");
      return createVNode("button", {
        "type": "button",
        "class": [bem13("cancel"), HAPTICS_FEEDBACK],
        "onClick": cancel
      }, [slots.cancel ? slots.cancel() : text]);
    };
    var renderConfirm = () => {
      var text = props.confirmButtonText || t("confirm");
      return createVNode("button", {
        "type": "button",
        "class": [bem13("confirm"), HAPTICS_FEEDBACK],
        "onClick": confirm
      }, [slots.confirm ? slots.confirm() : text]);
    };
    var renderToolbar = () => {
      if (props.showToolbar) {
        var slot = slots.toolbar || slots.default;
        return createVNode("div", {
          "class": bem13("toolbar")
        }, [slot ? slot() : [renderCancel(), renderTitle(), renderConfirm()]]);
      }
    };
    var renderColumnItems = () => formattedColumns.value.map((item, columnIndex) => {
      var _item$defaultIndex;
      return createVNode(PickerColumn_default, {
        "textKey": textKey,
        "readonly": props.readonly,
        "allowHtml": props.allowHtml,
        "className": item.className,
        "itemHeight": itemHeight.value,
        "defaultIndex": (_item$defaultIndex = item.defaultIndex) != null ? _item$defaultIndex : +props.defaultIndex,
        "swipeDuration": props.swipeDuration,
        "initialOptions": item[valuesKey],
        "visibleItemCount": props.visibleItemCount,
        "onChange": () => onChange(columnIndex)
      }, {
        option: slots.option
      });
    });
    var renderColumns = () => {
      var wrapHeight = itemHeight.value * +props.visibleItemCount;
      var frameStyle = {
        height: itemHeight.value + "px"
      };
      var columnsStyle = {
        height: wrapHeight + "px"
      };
      var maskStyle = {
        backgroundSize: "100% " + (wrapHeight - itemHeight.value) / 2 + "px"
      };
      return createVNode("div", {
        "class": bem13("columns"),
        "style": columnsStyle,
        "onTouchmove": preventDefault
      }, [renderColumnItems(), createVNode("div", {
        "class": bem13("mask"),
        "style": maskStyle
      }, null), createVNode("div", {
        "class": [BORDER_UNSET_TOP_BOTTOM, bem13("frame")],
        "style": frameStyle
      }, null)]);
    };
    watch(() => props.columns, format3, {
      immediate: true
    });
    useExpose({
      confirm,
      getValues,
      setValues,
      getIndexes,
      setIndexes,
      getColumnIndex,
      setColumnIndex,
      getColumnValue,
      setColumnValue,
      getColumnValues,
      setColumnValues
    });
    return () => {
      var _slots$columnsTop, _slots$columnsBottom;
      return createVNode("div", {
        "class": bem13()
      }, [props.toolbarPosition === "top" ? renderToolbar() : null, props.loading ? createVNode(Loading, {
        "class": bem13("loading")
      }, null) : null, (_slots$columnsTop = slots["columns-top"]) == null ? void 0 : _slots$columnsTop.call(slots), renderColumns(), (_slots$columnsBottom = slots["columns-bottom"]) == null ? void 0 : _slots$columnsBottom.call(slots), props.toolbarPosition === "bottom" ? renderToolbar() : null]);
    };
  }
});

// node_modules/vant/es/picker/index.js
var Picker = withInstall(Picker_default);

// node_modules/vant/es/area/Area.js
var [name14, bem14] = createNamespace("area");
var EMPTY_CODE = "000000";
var INHERIT_SLOTS = ["title", "cancel", "confirm", "toolbar", "columns-top", "columns-bottom"];
var INHERIT_PROPS = ["title", "loading", "readonly", "itemHeight", "swipeDuration", "visibleItemCount", "cancelButtonText", "confirmButtonText"];
var isOverseaCode = (code) => code[0] === "9";
var areaProps = extend({}, pickerSharedProps, {
  value: String,
  columnsNum: makeNumericProp(3),
  columnsPlaceholder: makeArrayProp(),
  areaList: {
    type: Object,
    default: () => ({})
  },
  isOverseaCode: {
    type: Function,
    default: isOverseaCode
  }
});
var Area_default = defineComponent({
  name: name14,
  props: areaProps,
  emits: ["change", "confirm", "cancel"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var pickerRef = ref();
    var state = reactive({
      code: props.value,
      columns: [{
        values: []
      }, {
        values: []
      }, {
        values: []
      }]
    });
    var areaList = computed(() => {
      var {
        areaList: areaList2
      } = props;
      return {
        province: areaList2.province_list || {},
        city: areaList2.city_list || {},
        county: areaList2.county_list || {}
      };
    });
    var placeholderMap = computed(() => {
      var {
        columnsPlaceholder
      } = props;
      return {
        province: columnsPlaceholder[0] || "",
        city: columnsPlaceholder[1] || "",
        county: columnsPlaceholder[2] || ""
      };
    });
    var getDefaultCode = () => {
      if (props.columnsPlaceholder.length) {
        return EMPTY_CODE;
      }
      var {
        county,
        city
      } = areaList.value;
      var countyCodes = Object.keys(county);
      if (countyCodes[0]) {
        return countyCodes[0];
      }
      var cityCodes = Object.keys(city);
      if (cityCodes[0]) {
        return cityCodes[0];
      }
      return "";
    };
    var getColumnValues = (type, code) => {
      var column = [];
      if (type !== "province" && !code) {
        return column;
      }
      var list = areaList.value[type];
      column = Object.keys(list).map((listCode) => ({
        code: listCode,
        name: list[listCode]
      }));
      if (code) {
        if (type === "city" && props.isOverseaCode(code)) {
          code = "9";
        }
        column = column.filter((item) => item.code.indexOf(code) === 0);
      }
      if (placeholderMap.value[type] && column.length) {
        var codeFill = "";
        if (type === "city") {
          codeFill = EMPTY_CODE.slice(2, 4);
        } else if (type === "county") {
          codeFill = EMPTY_CODE.slice(4, 6);
        }
        column.unshift({
          code: code + codeFill,
          name: placeholderMap.value[type]
        });
      }
      return column;
    };
    var getIndex = (type, code) => {
      var compareNum = code.length;
      if (type === "province") {
        compareNum = props.isOverseaCode(code) ? 1 : 2;
      }
      if (type === "city") {
        compareNum = 4;
      }
      code = code.slice(0, compareNum);
      var list = getColumnValues(type, compareNum > 2 ? code.slice(0, compareNum - 2) : "");
      for (var i = 0; i < list.length; i++) {
        if (list[i].code.slice(0, compareNum) === code) {
          return i;
        }
      }
      return 0;
    };
    var setValues = () => {
      var code = state.code || getDefaultCode();
      var picker = pickerRef.value;
      var province = getColumnValues("province");
      var city = getColumnValues("city", code.slice(0, 2));
      if (!picker) {
        return;
      }
      picker.setColumnValues(0, province);
      picker.setColumnValues(1, city);
      if (city.length && code.slice(2, 4) === "00" && !props.isOverseaCode(code)) {
        [{
          code
        }] = city;
      }
      picker.setColumnValues(2, getColumnValues("county", code.slice(0, 4)));
      picker.setIndexes([getIndex("province", code), getIndex("city", code), getIndex("county", code)]);
    };
    var parseValues = (values) => values.map((value, index) => {
      if (value) {
        value = deepClone(value);
        if (!value.code || value.name === props.columnsPlaceholder[index]) {
          value.code = "";
          value.name = "";
        }
      }
      return value;
    });
    var getValues = () => {
      if (pickerRef.value) {
        var values = pickerRef.value.getValues().filter(Boolean);
        return parseValues(values);
      }
      return [];
    };
    var getArea = () => {
      var values = getValues();
      var area = {
        code: "",
        country: "",
        province: "",
        city: "",
        county: ""
      };
      if (!values.length) {
        return area;
      }
      var names = values.map((item) => item.name);
      var validValues = values.filter((value) => value.code);
      area.code = validValues.length ? validValues[validValues.length - 1].code : "";
      if (props.isOverseaCode(area.code)) {
        area.country = names[1] || "";
        area.province = names[2] || "";
      } else {
        area.province = names[0] || "";
        area.city = names[1] || "";
        area.county = names[2] || "";
      }
      return area;
    };
    var reset = function(newCode) {
      if (newCode === void 0) {
        newCode = "";
      }
      state.code = newCode;
      setValues();
    };
    var onChange = (values, index) => {
      state.code = values[index].code;
      setValues();
      if (pickerRef.value) {
        var parsedValues = parseValues(pickerRef.value.getValues());
        emit("change", parsedValues, index);
      }
    };
    var onConfirm = (values, index) => {
      setValues();
      emit("confirm", parseValues(values), index);
    };
    var onCancel = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return emit("cancel", ...args);
    };
    onMounted(setValues);
    watch(() => props.value, (value) => {
      state.code = value;
      setValues();
    });
    watch(() => props.areaList, setValues, {
      deep: true
    });
    watch(() => props.columnsNum, () => nextTick(setValues));
    useExpose({
      reset,
      getArea,
      getValues
    });
    return () => {
      var columns = state.columns.slice(0, +props.columnsNum);
      return createVNode(Picker, mergeProps({
        "ref": pickerRef,
        "class": bem14(),
        "columns": columns,
        "columnsFieldNames": {
          text: "name"
        },
        "onChange": onChange,
        "onCancel": onCancel,
        "onConfirm": onConfirm
      }, pick(props, INHERIT_PROPS)), pick(slots, INHERIT_SLOTS));
    };
  }
});

// node_modules/vant/es/area/index.js
var Area = withInstall(Area_default);

// node_modules/vant/es/cell/Cell.js
var [name15, bem15] = createNamespace("cell");
var cellSharedProps = {
  icon: String,
  size: String,
  title: numericProp,
  value: numericProp,
  label: numericProp,
  center: Boolean,
  isLink: Boolean,
  border: truthProp,
  required: Boolean,
  iconPrefix: String,
  valueClass: unknownProp,
  labelClass: unknownProp,
  titleClass: unknownProp,
  titleStyle: null,
  arrowDirection: String,
  clickable: {
    type: Boolean,
    default: null
  }
};
var cellProps = extend({}, cellSharedProps, routeProps);
var Cell_default = defineComponent({
  name: name15,
  props: cellProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var route2 = useRoute();
    var renderLabel = () => {
      var showLabel = slots.label || isDef(props.label);
      if (showLabel) {
        return createVNode("div", {
          "class": [bem15("label"), props.labelClass]
        }, [slots.label ? slots.label() : props.label]);
      }
    };
    var renderTitle = () => {
      if (slots.title || isDef(props.title)) {
        return createVNode("div", {
          "class": [bem15("title"), props.titleClass],
          "style": props.titleStyle
        }, [slots.title ? slots.title() : createVNode("span", null, [props.title]), renderLabel()]);
      }
    };
    var renderValue = () => {
      var slot = slots.value || slots.default;
      var hasValue = slot || isDef(props.value);
      if (hasValue) {
        var hasTitle = slots.title || isDef(props.title);
        return createVNode("div", {
          "class": [bem15("value", {
            alone: !hasTitle
          }), props.valueClass]
        }, [slot ? slot() : createVNode("span", null, [props.value])]);
      }
    };
    var renderLeftIcon = () => {
      if (slots.icon) {
        return slots.icon();
      }
      if (props.icon) {
        return createVNode(Icon, {
          "name": props.icon,
          "class": bem15("left-icon"),
          "classPrefix": props.iconPrefix
        }, null);
      }
    };
    var renderRightIcon = () => {
      if (slots["right-icon"]) {
        return slots["right-icon"]();
      }
      if (props.isLink) {
        var _name = props.arrowDirection ? "arrow-" + props.arrowDirection : "arrow";
        return createVNode(Icon, {
          "name": _name,
          "class": bem15("right-icon")
        }, null);
      }
    };
    return () => {
      var _props$clickable;
      var {
        size,
        center,
        border,
        isLink,
        required
      } = props;
      var clickable = (_props$clickable = props.clickable) != null ? _props$clickable : isLink;
      var classes = {
        center,
        required,
        clickable,
        borderless: !border
      };
      if (size) {
        classes[size] = !!size;
      }
      return createVNode("div", {
        "class": bem15(classes),
        "role": clickable ? "button" : void 0,
        "tabindex": clickable ? 0 : void 0,
        "onClick": route2
      }, [renderLeftIcon(), renderTitle(), renderValue(), renderRightIcon(), slots.extra == null ? void 0 : slots.extra()]);
    };
  }
});

// node_modules/vant/es/cell/index.js
var Cell = withInstall(Cell_default);

// node_modules/vant/es/form/Form.js
var [name16, bem16] = createNamespace("form");
var formProps = {
  colon: Boolean,
  disabled: Boolean,
  readonly: Boolean,
  showError: Boolean,
  labelWidth: numericProp,
  labelAlign: String,
  inputAlign: String,
  scrollToError: Boolean,
  validateFirst: Boolean,
  submitOnEnter: truthProp,
  validateTrigger: makeStringProp("onBlur"),
  showErrorMessage: truthProp,
  errorMessageAlign: String
};
var Form_default = defineComponent({
  name: name16,
  props: formProps,
  emits: ["submit", "failed"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var {
      children,
      linkChildren
    } = useChildren(FORM_KEY);
    var getFieldsByNames = (names) => {
      if (names) {
        return children.filter((field) => names.includes(field.name));
      }
      return children;
    };
    var validateSeq = (names) => new Promise((resolve, reject) => {
      var errors = [];
      var fields = getFieldsByNames(names);
      fields.reduce((promise, field) => promise.then(() => {
        if (!errors.length) {
          return field.validate().then((error) => {
            if (error) {
              errors.push(error);
            }
          });
        }
      }), Promise.resolve()).then(() => {
        if (errors.length) {
          reject(errors);
        } else {
          resolve();
        }
      });
    });
    var validateAll = (names) => new Promise((resolve, reject) => {
      var fields = getFieldsByNames(names);
      Promise.all(fields.map((item) => item.validate())).then((errors) => {
        errors = errors.filter(Boolean);
        if (errors.length) {
          reject(errors);
        } else {
          resolve();
        }
      });
    });
    var validateField = (name96) => {
      var matched = children.find((item) => item.name === name96);
      if (matched) {
        return new Promise((resolve, reject) => {
          matched.validate().then((error) => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          });
        });
      }
      return Promise.reject();
    };
    var validate = (name96) => {
      if (typeof name96 === "string") {
        return validateField(name96);
      }
      return props.validateFirst ? validateSeq(name96) : validateAll(name96);
    };
    var resetValidation = (name96) => {
      if (typeof name96 === "string") {
        name96 = [name96];
      }
      var fields = getFieldsByNames(name96);
      fields.forEach((item) => {
        item.resetValidation();
      });
    };
    var scrollToField = (name96, options) => {
      children.some((item) => {
        if (item.name === name96) {
          item.$el.scrollIntoView(options);
          return true;
        }
        return false;
      });
    };
    var getValues = () => children.reduce((form, field) => {
      form[field.name] = field.formValue.value;
      return form;
    }, {});
    var submit = () => {
      var values = getValues();
      validate().then(() => emit("submit", values)).catch((errors) => {
        emit("failed", {
          values,
          errors
        });
        if (props.scrollToError && errors[0].name) {
          scrollToField(errors[0].name);
        }
      });
    };
    var onSubmit = (event) => {
      preventDefault(event);
      submit();
    };
    linkChildren({
      props
    });
    useExpose({
      submit,
      validate,
      scrollToField,
      resetValidation
    });
    return () => createVNode("form", {
      "class": bem16(),
      "onSubmit": onSubmit
    }, [slots.default == null ? void 0 : slots.default()]);
  }
});

// node_modules/vant/es/form/index.js
var Form = withInstall(Form_default);

// node_modules/vant/es/field/utils.js
function isEmptyValue(value) {
  if (Array.isArray(value)) {
    return !value.length;
  }
  if (value === 0) {
    return false;
  }
  return !value;
}
function runSyncRule(value, rule) {
  if (rule.required && isEmptyValue(value)) {
    return false;
  }
  if (rule.pattern && !rule.pattern.test(String(value))) {
    return false;
  }
  return true;
}
function runRuleValidator(value, rule) {
  return new Promise((resolve) => {
    var returnVal = rule.validator(value, rule);
    if (isPromise(returnVal)) {
      return returnVal.then(resolve);
    }
    resolve(returnVal);
  });
}
function getRuleMessage(value, rule) {
  var {
    message
  } = rule;
  if (isFunction(message)) {
    return message(value, rule);
  }
  return message || "";
}
function startComposing(_ref) {
  var {
    target
  } = _ref;
  target.composing = true;
}
function endComposing(_ref2) {
  var {
    target
  } = _ref2;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
function resizeTextarea(input, autosize) {
  var scrollTop = getRootScrollTop();
  input.style.height = "auto";
  var height2 = input.scrollHeight;
  if (isObject(autosize)) {
    var {
      maxHeight,
      minHeight
    } = autosize;
    if (maxHeight !== void 0) {
      height2 = Math.min(height2, maxHeight);
    }
    if (minHeight !== void 0) {
      height2 = Math.max(height2, minHeight);
    }
  }
  if (height2) {
    input.style.height = height2 + "px";
    setRootScrollTop(scrollTop);
  }
}
function mapInputType(type) {
  if (type === "number") {
    return {
      type: "text",
      inputmode: "decimal"
    };
  }
  if (type === "digit") {
    return {
      type: "tel",
      inputmode: "numeric"
    };
  }
  return {
    type
  };
}
function getStringLength(str) {
  return [...str].length;
}
function cutString(str, maxlength) {
  return [...str].slice(0, maxlength).join("");
}

// node_modules/vant/es/composables/use-id.js
var current = 0;
function useId() {
  var vm = getCurrentInstance();
  var {
    name: name96 = "unknown"
  } = (vm == null ? void 0 : vm.type) || {};
  if (false) {
    return name96;
  }
  return name96 + "-" + ++current;
}

// node_modules/vant/es/field/Field.js
var [name17, bem17] = createNamespace("field");
var fieldSharedProps = {
  id: String,
  name: String,
  leftIcon: String,
  rightIcon: String,
  autofocus: Boolean,
  clearable: Boolean,
  maxlength: numericProp,
  formatter: Function,
  clearIcon: makeStringProp("clear"),
  modelValue: makeNumericProp(""),
  inputAlign: String,
  placeholder: String,
  autocomplete: String,
  errorMessage: String,
  clearTrigger: makeStringProp("focus"),
  formatTrigger: makeStringProp("onChange"),
  error: {
    type: Boolean,
    default: null
  },
  disabled: {
    type: Boolean,
    default: null
  },
  readonly: {
    type: Boolean,
    default: null
  }
};
var fieldProps = extend({}, cellSharedProps, fieldSharedProps, {
  rows: numericProp,
  type: makeStringProp("text"),
  rules: Array,
  autosize: [Boolean, Object],
  labelWidth: numericProp,
  labelClass: unknownProp,
  labelAlign: String,
  showWordLimit: Boolean,
  errorMessageAlign: String,
  colon: {
    type: Boolean,
    default: null
  }
});
var Field_default = defineComponent({
  name: name17,
  props: fieldProps,
  emits: ["blur", "focus", "clear", "keypress", "click-input", "click-left-icon", "click-right-icon", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var id = useId();
    var state = reactive({
      focused: false,
      validateFailed: false,
      validateMessage: ""
    });
    var inputRef = ref();
    var customValue = ref();
    var {
      parent: form
    } = useParent(FORM_KEY);
    var getModelValue = () => {
      var _props$modelValue;
      return String((_props$modelValue = props.modelValue) != null ? _props$modelValue : "");
    };
    var getProp = (key) => {
      if (isDef(props[key])) {
        return props[key];
      }
      if (form && isDef(form.props[key])) {
        return form.props[key];
      }
    };
    var showClear = computed(() => {
      var readonly = getProp("readonly");
      if (props.clearable && !readonly) {
        var hasValue = getModelValue() !== "";
        var trigger = props.clearTrigger === "always" || props.clearTrigger === "focus" && state.focused;
        return hasValue && trigger;
      }
      return false;
    });
    var formValue = computed(() => {
      if (customValue.value && slots.input) {
        return customValue.value();
      }
      return props.modelValue;
    });
    var runRules = (rules) => rules.reduce((promise, rule) => promise.then(() => {
      if (state.validateFailed) {
        return;
      }
      var {
        value
      } = formValue;
      if (rule.formatter) {
        value = rule.formatter(value, rule);
      }
      if (!runSyncRule(value, rule)) {
        state.validateFailed = true;
        state.validateMessage = getRuleMessage(value, rule);
        return;
      }
      if (rule.validator) {
        return runRuleValidator(value, rule).then((result) => {
          if (result && typeof result === "string") {
            state.validateFailed = true;
            state.validateMessage = result;
          } else if (result === false) {
            state.validateFailed = true;
            state.validateMessage = getRuleMessage(value, rule);
          }
        });
      }
    }), Promise.resolve());
    var resetValidation = () => {
      if (state.validateFailed) {
        state.validateFailed = false;
        state.validateMessage = "";
      }
    };
    var validate = function(rules) {
      if (rules === void 0) {
        rules = props.rules;
      }
      return new Promise((resolve) => {
        resetValidation();
        if (rules) {
          runRules(rules).then(() => {
            if (state.validateFailed) {
              resolve({
                name: props.name,
                message: state.validateMessage
              });
            } else {
              resolve();
            }
          });
        } else {
          resolve();
        }
      });
    };
    var validateWithTrigger = (trigger) => {
      if (form && props.rules) {
        var defaultTrigger = form.props.validateTrigger === trigger;
        var rules = props.rules.filter((rule) => {
          if (rule.trigger) {
            return rule.trigger === trigger;
          }
          return defaultTrigger;
        });
        if (rules.length) {
          validate(rules);
        }
      }
    };
    var limitValueLength = (value) => {
      var {
        maxlength
      } = props;
      if (isDef(maxlength) && getStringLength(value) > maxlength) {
        var modelValue = getModelValue();
        if (modelValue && getStringLength(modelValue) === +maxlength) {
          return modelValue;
        }
        return cutString(value, +maxlength);
      }
      return value;
    };
    var updateValue = function(value, trigger) {
      if (trigger === void 0) {
        trigger = "onChange";
      }
      value = limitValueLength(value);
      if (props.type === "number" || props.type === "digit") {
        var isNumber = props.type === "number";
        value = formatNumber(value, isNumber, isNumber);
      }
      if (props.formatter && trigger === props.formatTrigger) {
        value = props.formatter(value);
      }
      if (inputRef.value && inputRef.value.value !== value) {
        inputRef.value.value = value;
      }
      if (value !== props.modelValue) {
        emit("update:modelValue", value);
      }
    };
    var onInput = (event) => {
      if (!event.target.composing) {
        updateValue(event.target.value);
      }
    };
    var blur = () => {
      var _inputRef$value;
      return (_inputRef$value = inputRef.value) == null ? void 0 : _inputRef$value.blur();
    };
    var focus = () => {
      var _inputRef$value2;
      return (_inputRef$value2 = inputRef.value) == null ? void 0 : _inputRef$value2.focus();
    };
    var adjustTextareaSize = () => {
      var input = inputRef.value;
      if (props.type === "textarea" && props.autosize && input) {
        resizeTextarea(input, props.autosize);
      }
    };
    var onFocus = (event) => {
      state.focused = true;
      emit("focus", event);
      nextTick(adjustTextareaSize);
      if (getProp("readonly")) {
        blur();
      }
    };
    var onBlur = (event) => {
      if (getProp("readonly")) {
        return;
      }
      state.focused = false;
      updateValue(getModelValue(), "onBlur");
      emit("blur", event);
      validateWithTrigger("onBlur");
      nextTick(adjustTextareaSize);
      resetScroll();
    };
    var onClickInput = (event) => emit("click-input", event);
    var onClickLeftIcon = (event) => emit("click-left-icon", event);
    var onClickRightIcon = (event) => emit("click-right-icon", event);
    var onClear = (event) => {
      preventDefault(event);
      emit("update:modelValue", "");
      emit("clear", event);
    };
    var showError = computed(() => {
      if (typeof props.error === "boolean") {
        return props.error;
      }
      if (form && form.props.showError && state.validateFailed) {
        return true;
      }
    });
    var labelStyle = computed(() => {
      var labelWidth = getProp("labelWidth");
      if (labelWidth) {
        return {
          width: addUnit(labelWidth)
        };
      }
    });
    var onKeypress = (event) => {
      var ENTER_CODE = 13;
      if (event.keyCode === ENTER_CODE) {
        var submitOnEnter = form && form.props.submitOnEnter;
        if (!submitOnEnter && props.type !== "textarea") {
          preventDefault(event);
        }
        if (props.type === "search") {
          blur();
        }
      }
      emit("keypress", event);
    };
    var getInputId = () => props.id || id + "-input";
    var renderInput = () => {
      var controlClass = bem17("control", [getProp("inputAlign"), {
        error: showError.value,
        custom: !!slots.input,
        "min-height": props.type === "textarea" && !props.autosize
      }]);
      if (slots.input) {
        return createVNode("div", {
          "class": controlClass,
          "onClick": onClickInput
        }, [slots.input()]);
      }
      var inputAttrs = {
        id: getInputId(),
        ref: inputRef,
        name: props.name,
        rows: props.rows !== void 0 ? +props.rows : void 0,
        class: controlClass,
        value: props.modelValue,
        disabled: getProp("disabled"),
        readonly: getProp("readonly"),
        autofocus: props.autofocus,
        placeholder: props.placeholder,
        autocomplete: props.autocomplete,
        "aria-labelledby": props.label ? id + "-label" : void 0,
        onBlur,
        onFocus,
        onInput,
        onClick: onClickInput,
        onChange: endComposing,
        onKeypress,
        onCompositionend: endComposing,
        onCompositionstart: startComposing
      };
      if (props.type === "textarea") {
        return createVNode("textarea", inputAttrs, null);
      }
      return createVNode("input", mergeProps(mapInputType(props.type), inputAttrs), null);
    };
    var renderLeftIcon = () => {
      var leftIconSlot = slots["left-icon"];
      if (props.leftIcon || leftIconSlot) {
        return createVNode("div", {
          "class": bem17("left-icon"),
          "onClick": onClickLeftIcon
        }, [leftIconSlot ? leftIconSlot() : createVNode(Icon, {
          "name": props.leftIcon,
          "classPrefix": props.iconPrefix
        }, null)]);
      }
    };
    var renderRightIcon = () => {
      var rightIconSlot = slots["right-icon"];
      if (props.rightIcon || rightIconSlot) {
        return createVNode("div", {
          "class": bem17("right-icon"),
          "onClick": onClickRightIcon
        }, [rightIconSlot ? rightIconSlot() : createVNode(Icon, {
          "name": props.rightIcon,
          "classPrefix": props.iconPrefix
        }, null)]);
      }
    };
    var renderWordLimit = () => {
      if (props.showWordLimit && props.maxlength) {
        var count = getStringLength(getModelValue());
        return createVNode("div", {
          "class": bem17("word-limit")
        }, [createVNode("span", {
          "class": bem17("word-num")
        }, [count]), createTextVNode("/"), props.maxlength]);
      }
    };
    var renderMessage = () => {
      if (form && form.props.showErrorMessage === false) {
        return;
      }
      var message = props.errorMessage || state.validateMessage;
      if (message) {
        var slot = slots["error-message"];
        var errorMessageAlign = getProp("errorMessageAlign");
        return createVNode("div", {
          "class": bem17("error-message", errorMessageAlign)
        }, [slot ? slot({
          message
        }) : message]);
      }
    };
    var renderLabel = () => {
      var colon = getProp("colon") ? ":" : "";
      if (slots.label) {
        return [slots.label(), colon];
      }
      if (props.label) {
        return createVNode("label", {
          "id": id + "-label",
          "for": getInputId()
        }, [props.label + colon]);
      }
    };
    var renderFieldBody = () => [createVNode("div", {
      "class": bem17("body")
    }, [renderInput(), showClear.value && createVNode(Icon, {
      "name": props.clearIcon,
      "class": bem17("clear"),
      "onTouchstart": onClear
    }, null), renderRightIcon(), slots.button && createVNode("div", {
      "class": bem17("button")
    }, [slots.button()])]), renderWordLimit(), renderMessage()];
    useExpose({
      blur,
      focus,
      validate,
      formValue,
      resetValidation
    });
    provide(CUSTOM_FIELD_INJECTION_KEY, {
      customValue,
      resetValidation,
      validateWithTrigger
    });
    watch(() => props.modelValue, () => {
      updateValue(getModelValue());
      resetValidation();
      validateWithTrigger("onChange");
      nextTick(adjustTextareaSize);
    });
    onMounted(() => {
      updateValue(getModelValue(), props.formatTrigger);
      nextTick(adjustTextareaSize);
    });
    return () => {
      var disabled = getProp("disabled");
      var labelAlign = getProp("labelAlign");
      var Label = renderLabel();
      var LeftIcon = renderLeftIcon();
      return createVNode(Cell, {
        "size": props.size,
        "icon": props.leftIcon,
        "class": bem17({
          error: showError.value,
          disabled,
          ["label-" + labelAlign]: labelAlign
        }),
        "center": props.center,
        "border": props.border,
        "isLink": props.isLink,
        "clickable": props.clickable,
        "titleStyle": labelStyle.value,
        "valueClass": bem17("value"),
        "titleClass": [bem17("label", [labelAlign, {
          required: props.required
        }]), props.labelClass],
        "arrowDirection": props.arrowDirection
      }, {
        icon: LeftIcon ? () => LeftIcon : null,
        title: Label ? () => Label : null,
        value: renderFieldBody,
        extra: slots.extra
      });
    };
  }
});

// node_modules/vant/es/field/index.js
var Field = withInstall(Field_default);

// node_modules/vant/es/utils/mount-component.js
function usePopupState() {
  var state = reactive({
    show: false
  });
  var toggle = (show) => {
    state.show = show;
  };
  var open = (props) => {
    extend(state, props, {
      transitionAppear: true
    });
    toggle(true);
  };
  var close = () => toggle(false);
  useExpose({
    open,
    close,
    toggle
  });
  return {
    open,
    close,
    state,
    toggle
  };
}
function mountComponent(RootComponent) {
  var app = createApp(RootComponent);
  var root = document.createElement("div");
  document.body.appendChild(root);
  return {
    instance: app.mount(root),
    unmount() {
      app.unmount();
      document.body.removeChild(root);
    }
  };
}

// node_modules/vant/es/toast/lock-click.js
var lockCount = 0;
function lockClick(lock) {
  if (lock) {
    if (!lockCount) {
      document.body.classList.add("van-toast--unclickable");
    }
    lockCount++;
  } else if (lockCount) {
    lockCount--;
    if (!lockCount) {
      document.body.classList.remove("van-toast--unclickable");
    }
  }
}

// node_modules/vant/es/toast/Toast.js
var [name18, bem18] = createNamespace("toast");
var popupInheritProps = ["show", "overlay", "transition", "overlayClass", "overlayStyle", "closeOnClickOverlay"];
var toastProps = {
  icon: String,
  show: Boolean,
  type: makeStringProp("text"),
  overlay: Boolean,
  message: numericProp,
  iconSize: numericProp,
  duration: makeNumberProp(2e3),
  position: makeStringProp("middle"),
  className: unknownProp,
  iconPrefix: String,
  transition: makeStringProp("van-fade"),
  loadingType: String,
  forbidClick: Boolean,
  overlayClass: unknownProp,
  overlayStyle: Object,
  closeOnClick: Boolean,
  closeOnClickOverlay: Boolean
};
var Toast_default = defineComponent({
  name: name18,
  props: toastProps,
  emits: ["update:show"],
  setup(props, _ref) {
    var {
      emit
    } = _ref;
    var timer2;
    var clickable = false;
    var toggleClickable = () => {
      var newValue = props.show && props.forbidClick;
      if (clickable !== newValue) {
        clickable = newValue;
        lockClick(clickable);
      }
    };
    var updateShow = (show) => emit("update:show", show);
    var onClick = () => {
      if (props.closeOnClick) {
        updateShow(false);
      }
    };
    var clearTimer = () => clearTimeout(timer2);
    var renderIcon = () => {
      var {
        icon,
        type,
        iconSize,
        iconPrefix,
        loadingType
      } = props;
      var hasIcon = icon || type === "success" || type === "fail";
      if (hasIcon) {
        return createVNode(Icon, {
          "name": icon || type,
          "size": iconSize,
          "class": bem18("icon"),
          "classPrefix": iconPrefix
        }, null);
      }
      if (type === "loading") {
        return createVNode(Loading, {
          "class": bem18("loading"),
          "size": iconSize,
          "type": loadingType
        }, null);
      }
    };
    var renderMessage = () => {
      var {
        type,
        message
      } = props;
      if (isDef(message) && message !== "") {
        return type === "html" ? createVNode("div", {
          "class": bem18("text"),
          "innerHTML": String(message)
        }, null) : createVNode("div", {
          "class": bem18("text")
        }, [message]);
      }
    };
    watch(() => [props.show, props.forbidClick], toggleClickable);
    watch(() => [props.show, props.type, props.message, props.duration], () => {
      clearTimer();
      if (props.show && props.duration > 0) {
        timer2 = setTimeout(() => {
          updateShow(false);
        }, props.duration);
      }
    });
    onMounted(toggleClickable);
    onUnmounted(toggleClickable);
    return () => createVNode(Popup, mergeProps({
      "class": [bem18([props.position, {
        [props.type]: !props.icon
      }]), props.className],
      "lockScroll": false,
      "onClick": onClick,
      "onClosed": clearTimer,
      "onUpdate:show": updateShow
    }, pick(props, popupInheritProps)), {
      default: () => [renderIcon(), renderMessage()]
    });
  }
});

// node_modules/vant/es/toast/function-call.js
var defaultOptions = {
  icon: "",
  type: "text",
  message: "",
  className: "",
  overlay: false,
  onClose: void 0,
  onOpened: void 0,
  duration: 2e3,
  teleport: "body",
  iconSize: void 0,
  iconPrefix: void 0,
  position: "middle",
  transition: "van-fade",
  forbidClick: false,
  loadingType: void 0,
  overlayClass: "",
  overlayStyle: void 0,
  closeOnClick: false,
  closeOnClickOverlay: false
};
var queue = [];
var allowMultiple = false;
var currentOptions = extend({}, defaultOptions);
var defaultOptionsMap = new Map();
function parseOptions(message) {
  if (isObject(message)) {
    return message;
  }
  return {
    message
  };
}
function createInstance() {
  var {
    instance: instance4,
    unmount
  } = mountComponent({
    setup() {
      var message = ref("");
      var {
        open,
        state,
        close,
        toggle
      } = usePopupState();
      var onClosed = () => {
        if (allowMultiple) {
          queue = queue.filter((item) => item !== instance4);
          unmount();
        }
      };
      var render = () => {
        var attrs = {
          onClosed,
          "onUpdate:show": toggle
        };
        return createVNode(Toast_default, mergeProps(state, attrs), null);
      };
      watch(message, (val) => {
        state.message = val;
      });
      getCurrentInstance().render = render;
      return {
        open,
        clear: close,
        message
      };
    }
  });
  return instance4;
}
function getInstance() {
  if (!queue.length || allowMultiple) {
    var instance4 = createInstance();
    queue.push(instance4);
  }
  return queue[queue.length - 1];
}
function Toast(options) {
  if (options === void 0) {
    options = {};
  }
  if (!inBrowser) {
    return {};
  }
  var toast = getInstance();
  var parsedOptions = parseOptions(options);
  toast.open(extend({}, currentOptions, defaultOptionsMap.get(parsedOptions.type || currentOptions.type), parsedOptions));
  return toast;
}
var createMethod = (type) => (options) => Toast(extend({
  type
}, parseOptions(options)));
Toast.loading = createMethod("loading");
Toast.success = createMethod("success");
Toast.fail = createMethod("fail");
Toast.clear = (all) => {
  if (queue.length) {
    if (all) {
      queue.forEach((toast) => {
        toast.clear();
      });
      queue = [];
    } else if (!allowMultiple) {
      queue[0].clear();
    } else {
      var _queue$shift;
      (_queue$shift = queue.shift()) == null ? void 0 : _queue$shift.clear();
    }
  }
};
function setDefaultOptions(type, options) {
  if (typeof type === "string") {
    defaultOptionsMap.set(type, options);
  } else {
    extend(currentOptions, type);
  }
}
Toast.setDefaultOptions = setDefaultOptions;
Toast.resetDefaultOptions = (type) => {
  if (typeof type === "string") {
    defaultOptionsMap.delete(type);
  } else {
    currentOptions = extend({}, defaultOptions);
    defaultOptionsMap.clear();
  }
};
Toast.allowMultiple = function(value) {
  if (value === void 0) {
    value = true;
  }
  allowMultiple = value;
};
Toast.install = (app) => {
  app.use(withInstall(Toast_default));
  app.config.globalProperties.$toast = Toast;
};

// node_modules/vant/es/switch/Switch.js
var [name19, bem19] = createNamespace("switch");
var switchProps = {
  size: numericProp,
  loading: Boolean,
  disabled: Boolean,
  modelValue: unknownProp,
  activeColor: String,
  inactiveColor: String,
  activeValue: {
    type: unknownProp,
    default: true
  },
  inactiveValue: {
    type: unknownProp,
    default: false
  }
};
var Switch_default = defineComponent({
  name: name19,
  props: switchProps,
  emits: ["change", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit
    } = _ref;
    var isChecked = () => props.modelValue === props.activeValue;
    var onClick = () => {
      if (!props.disabled && !props.loading) {
        var newValue = isChecked() ? props.inactiveValue : props.activeValue;
        emit("update:modelValue", newValue);
        emit("change", newValue);
      }
    };
    var renderLoading = () => {
      if (props.loading) {
        var color = isChecked() ? props.activeColor : props.inactiveColor;
        return createVNode(Loading, {
          "class": bem19("loading"),
          "color": color
        }, null);
      }
    };
    useCustomFieldValue(() => props.modelValue);
    return () => {
      var {
        size,
        loading,
        disabled,
        activeColor,
        inactiveColor
      } = props;
      var checked = isChecked();
      var style = {
        fontSize: addUnit(size),
        backgroundColor: checked ? activeColor : inactiveColor
      };
      return createVNode("div", {
        "role": "switch",
        "class": bem19({
          on: checked,
          loading,
          disabled
        }),
        "style": style,
        "tabindex": disabled ? void 0 : 0,
        "aria-checked": checked,
        "onClick": onClick
      }, [createVNode("div", {
        "class": bem19("node")
      }, [renderLoading()])]);
    };
  }
});

// node_modules/vant/es/switch/index.js
var Switch = withInstall(Switch_default);

// node_modules/vant/es/address-edit/AddressEditDetail.js
var [name20, bem20, t2] = createNamespace("address-edit-detail");
var AddressEditDetail_default = defineComponent({
  name: name20,
  props: {
    show: Boolean,
    rows: numericProp,
    value: String,
    rules: Array,
    focused: Boolean,
    maxlength: numericProp,
    searchResult: Array,
    showSearchResult: Boolean
  },
  emits: ["blur", "focus", "input", "select-search"],
  setup(props, _ref) {
    var {
      emit
    } = _ref;
    var field = ref();
    var showSearchResult = () => props.focused && props.searchResult && props.showSearchResult;
    var onSelect = (express) => {
      emit("select-search", express);
      emit("input", ((express.address || "") + " " + (express.name || "")).trim());
    };
    var renderSearchTitle = (express) => {
      if (express.name) {
        var text = express.name.replace(props.value, "<span class=" + bem20("keyword") + ">" + props.value + "</span>");
        return createVNode("div", {
          "innerHTML": text
        }, null);
      }
    };
    var renderSearchResult = () => {
      if (!showSearchResult()) {
        return;
      }
      var {
        searchResult
      } = props;
      return searchResult.map((express) => createVNode(Cell, {
        "clickable": true,
        "key": express.name + express.address,
        "icon": "location-o",
        "label": express.address,
        "class": bem20("search-item"),
        "border": false,
        "onClick": () => onSelect(express)
      }, {
        title: () => renderSearchTitle(express)
      }));
    };
    var onBlur = (event) => emit("blur", event);
    var onFocus = (event) => emit("focus", event);
    var onInput = (value) => emit("input", value);
    return () => {
      if (props.show) {
        return createVNode(Fragment, null, [createVNode(Field, {
          "autosize": true,
          "clearable": true,
          "ref": field,
          "class": bem20(),
          "rows": props.rows,
          "type": "textarea",
          "rules": props.rules,
          "label": t2("label"),
          "border": !showSearchResult(),
          "maxlength": props.maxlength,
          "modelValue": props.value,
          "placeholder": t2("placeholder"),
          "onBlur": onBlur,
          "onFocus": onFocus,
          "onUpdate:modelValue": onInput
        }, null), renderSearchResult()]);
      }
    };
  }
});

// node_modules/vant/es/address-edit/AddressEdit.js
var [name21, bem21, t3] = createNamespace("address-edit");
var DEFAULT_DATA = {
  name: "",
  tel: "",
  city: "",
  county: "",
  country: "",
  province: "",
  areaCode: "",
  isDefault: false,
  postalCode: "",
  addressDetail: ""
};
var isPostal = (value) => /^\d{6}$/.test(value);
var addressEditProps = {
  areaList: Object,
  isSaving: Boolean,
  isDeleting: Boolean,
  validator: Function,
  showArea: truthProp,
  showDetail: truthProp,
  showDelete: Boolean,
  showPostal: Boolean,
  disableArea: Boolean,
  searchResult: Array,
  telMaxlength: numericProp,
  showSetDefault: Boolean,
  saveButtonText: String,
  areaPlaceholder: String,
  deleteButtonText: String,
  showSearchResult: Boolean,
  detailRows: makeNumericProp(1),
  detailMaxlength: makeNumericProp(200),
  areaColumnsPlaceholder: makeArrayProp(),
  addressInfo: {
    type: Object,
    default: () => extend({}, DEFAULT_DATA)
  },
  telValidator: {
    type: Function,
    default: isMobile
  },
  postalValidator: {
    type: Function,
    default: isPostal
  }
};
var AddressEdit_default = defineComponent({
  name: name21,
  props: addressEditProps,
  emits: ["save", "focus", "delete", "click-area", "change-area", "change-detail", "select-search", "change-default"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var areaRef = ref();
    var data = reactive({});
    var showAreaPopup = ref(false);
    var detailFocused = ref(false);
    var areaListLoaded = computed(() => isObject(props.areaList) && Object.keys(props.areaList).length);
    var areaText = computed(() => {
      var {
        country,
        province,
        city,
        county,
        areaCode
      } = data;
      if (areaCode) {
        var arr = [country, province, city, county];
        if (province && province === city) {
          arr.splice(1, 1);
        }
        return arr.filter(Boolean).join("/");
      }
      return "";
    });
    var hideBottomFields = computed(() => {
      var _props$searchResult;
      return ((_props$searchResult = props.searchResult) == null ? void 0 : _props$searchResult.length) && detailFocused.value;
    });
    var assignAreaValues = () => {
      if (areaRef.value) {
        var detail = areaRef.value.getArea();
        detail.areaCode = detail.code;
        delete detail.code;
        extend(data, detail);
      }
    };
    var onFocus = (key) => {
      detailFocused.value = key === "addressDetail";
      emit("focus", key);
    };
    var rules = computed(() => {
      var {
        validator,
        telValidator,
        postalValidator
      } = props;
      var makeRule = (name96, emptyMessage) => ({
        validator: (value) => {
          if (validator) {
            var message = validator(name96, value);
            if (message) {
              return message;
            }
          }
          if (!value) {
            return emptyMessage;
          }
          return true;
        }
      });
      return {
        name: [makeRule("name", t3("nameEmpty"))],
        tel: [makeRule("tel", t3("telInvalid")), {
          validator: telValidator,
          message: t3("telInvalid")
        }],
        areaCode: [makeRule("areaCode", t3("areaEmpty"))],
        addressDetail: [makeRule("addressDetail", t3("addressEmpty"))],
        postalCode: [makeRule("addressDetail", t3("postalEmpty")), {
          validator: postalValidator,
          message: t3("postalEmpty")
        }]
      };
    });
    var onSave = () => emit("save", data);
    var onChangeDetail = (val) => {
      data.addressDetail = val;
      emit("change-detail", val);
    };
    var onAreaConfirm = (values) => {
      values = values.filter(Boolean);
      if (values.some((value) => !value.code)) {
        Toast(t3("areaEmpty"));
      } else {
        showAreaPopup.value = false;
        assignAreaValues();
        emit("change-area", values);
      }
    };
    var onDelete = () => emit("delete", data);
    var getArea = () => {
      var _areaRef$value;
      return ((_areaRef$value = areaRef.value) == null ? void 0 : _areaRef$value.getValues()) || [];
    };
    var setAreaCode = (code) => {
      data.areaCode = code || "";
      if (code) {
        nextTick(assignAreaValues);
      }
    };
    var onDetailBlur = () => {
      setTimeout(() => {
        detailFocused.value = false;
      });
    };
    var setAddressDetail = (value) => {
      data.addressDetail = value;
    };
    var renderSetDefaultCell = () => {
      if (props.showSetDefault) {
        var _slots = {
          "right-icon": () => createVNode(Switch, {
            "modelValue": data.isDefault,
            "onUpdate:modelValue": ($event) => data.isDefault = $event,
            "size": "24",
            "onChange": (event) => emit("change-default", event)
          }, null)
        };
        return withDirectives(createVNode(Cell, {
          "center": true,
          "title": t3("defaultAddress"),
          "class": bem21("default")
        }, _slots), [[vShow, !hideBottomFields.value]]);
      }
    };
    useExpose({
      getArea,
      setAreaCode,
      setAddressDetail
    });
    watch(() => props.areaList, () => setAreaCode(data.areaCode));
    watch(() => props.addressInfo, (value) => {
      extend(data, DEFAULT_DATA, value);
      setAreaCode(value.areaCode);
    }, {
      deep: true,
      immediate: true
    });
    return () => {
      var {
        disableArea
      } = props;
      return createVNode(Form, {
        "class": bem21(),
        "onSubmit": onSave
      }, {
        default: () => [createVNode("div", {
          "class": bem21("fields")
        }, [createVNode(Field, {
          "modelValue": data.name,
          "onUpdate:modelValue": ($event) => data.name = $event,
          "clearable": true,
          "label": t3("name"),
          "rules": rules.value.name,
          "placeholder": t3("name"),
          "onFocus": () => onFocus("name")
        }, null), createVNode(Field, {
          "modelValue": data.tel,
          "onUpdate:modelValue": ($event) => data.tel = $event,
          "clearable": true,
          "type": "tel",
          "label": t3("tel"),
          "rules": rules.value.tel,
          "maxlength": props.telMaxlength,
          "placeholder": t3("tel"),
          "onFocus": () => onFocus("tel")
        }, null), withDirectives(createVNode(Field, {
          "readonly": true,
          "label": t3("area"),
          "is-link": !disableArea,
          "modelValue": areaText.value,
          "rules": rules.value.areaCode,
          "placeholder": props.areaPlaceholder || t3("area"),
          "onFocus": () => onFocus("areaCode"),
          "onClick": () => {
            emit("click-area");
            showAreaPopup.value = !disableArea;
          }
        }, null), [[vShow, props.showArea]]), createVNode(AddressEditDetail_default, {
          "show": props.showDetail,
          "rows": props.detailRows,
          "rules": rules.value.addressDetail,
          "value": data.addressDetail,
          "focused": detailFocused.value,
          "maxlength": props.detailMaxlength,
          "searchResult": props.searchResult,
          "showSearchResult": props.showSearchResult,
          "onBlur": onDetailBlur,
          "onFocus": () => onFocus("addressDetail"),
          "onInput": onChangeDetail,
          "onSelect-search": (event) => emit("select-search", event)
        }, null), props.showPostal && withDirectives(createVNode(Field, {
          "modelValue": data.postalCode,
          "onUpdate:modelValue": ($event) => data.postalCode = $event,
          "type": "tel",
          "rules": rules.value.postalCode,
          "label": t3("postal"),
          "maxlength": "6",
          "placeholder": t3("postal"),
          "onFocus": () => onFocus("postalCode")
        }, null), [[vShow, !hideBottomFields.value]]), slots.default == null ? void 0 : slots.default()]), renderSetDefaultCell(), withDirectives(createVNode("div", {
          "class": bem21("buttons")
        }, [createVNode(Button, {
          "block": true,
          "round": true,
          "type": "danger",
          "text": props.saveButtonText || t3("save"),
          "class": bem21("button"),
          "loading": props.isSaving,
          "nativeType": "submit"
        }, null), props.showDelete && createVNode(Button, {
          "block": true,
          "round": true,
          "class": bem21("button"),
          "loading": props.isDeleting,
          "text": props.deleteButtonText || t3("delete"),
          "onClick": onDelete
        }, null)]), [[vShow, !hideBottomFields.value]]), createVNode(Popup, {
          "show": showAreaPopup.value,
          "onUpdate:show": ($event) => showAreaPopup.value = $event,
          "round": true,
          "teleport": "body",
          "position": "bottom",
          "lazyRender": false
        }, {
          default: () => [createVNode(Area, {
            "ref": areaRef,
            "value": data.areaCode,
            "loading": !areaListLoaded.value,
            "areaList": props.areaList,
            "columnsPlaceholder": props.areaColumnsPlaceholder,
            "onConfirm": onAreaConfirm,
            "onCancel": () => {
              showAreaPopup.value = false;
            }
          }, null)]
        })]
      });
    };
  }
});

// node_modules/vant/es/address-edit/index.js
var AddressEdit = withInstall(AddressEdit_default);

// node_modules/vant/es/radio-group/RadioGroup.js
var [name22, bem22] = createNamespace("radio-group");
var radioGroupProps = {
  disabled: Boolean,
  iconSize: numericProp,
  direction: String,
  modelValue: unknownProp,
  checkedColor: String
};
var RADIO_KEY = Symbol(name22);
var RadioGroup_default = defineComponent({
  name: name22,
  props: radioGroupProps,
  emits: ["change", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var {
      linkChildren
    } = useChildren(RADIO_KEY);
    var updateValue = (value) => emit("update:modelValue", value);
    watch(() => props.modelValue, (value) => emit("change", value));
    linkChildren({
      props,
      updateValue
    });
    useCustomFieldValue(() => props.modelValue);
    return () => createVNode("div", {
      "class": bem22([props.direction]),
      "role": "radiogroup"
    }, [slots.default == null ? void 0 : slots.default()]);
  }
});

// node_modules/vant/es/radio-group/index.js
var RadioGroup = withInstall(RadioGroup_default);

// node_modules/vant/es/tag/Tag.js
var [name23, bem23] = createNamespace("tag");
var tagProps = {
  size: String,
  mark: Boolean,
  show: truthProp,
  type: makeStringProp("default"),
  color: String,
  plain: Boolean,
  round: Boolean,
  textColor: String,
  closeable: Boolean
};
var Tag_default = defineComponent({
  name: name23,
  props: tagProps,
  emits: ["close"],
  setup(props, _ref) {
    var {
      slots,
      emit
    } = _ref;
    var onClose = (event) => {
      event.stopPropagation();
      emit("close", event);
    };
    var getStyle = () => {
      if (props.plain) {
        return {
          color: props.textColor || props.color,
          borderColor: props.color
        };
      }
      return {
        color: props.textColor,
        background: props.color
      };
    };
    var renderTag = () => {
      var {
        type,
        mark,
        plain,
        round: round2,
        size,
        closeable
      } = props;
      var classes = {
        mark,
        plain,
        round: round2
      };
      if (size) {
        classes[size] = size;
      }
      var CloseIcon = closeable && createVNode(Icon, {
        "name": "cross",
        "class": bem23("close"),
        "onClick": onClose
      }, null);
      return createVNode("span", {
        "style": getStyle(),
        "class": bem23([classes, type])
      }, [slots.default == null ? void 0 : slots.default(), CloseIcon]);
    };
    return () => createVNode(Transition, {
      "name": props.closeable ? "van-fade" : void 0
    }, {
      default: () => [props.show ? renderTag() : null]
    });
  }
});

// node_modules/vant/es/tag/index.js
var Tag = withInstall(Tag_default);

// node_modules/vant/es/checkbox/Checker.js
var checkerProps = {
  name: unknownProp,
  shape: makeStringProp("round"),
  disabled: Boolean,
  iconSize: numericProp,
  modelValue: unknownProp,
  checkedColor: String,
  labelPosition: String,
  labelDisabled: Boolean
};
var Checker_default = defineComponent({
  props: extend({}, checkerProps, {
    bem: makeRequiredProp(Function),
    role: String,
    parent: Object,
    checked: Boolean,
    bindGroup: truthProp
  }),
  emits: ["click", "toggle"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var iconRef = ref();
    var getParentProp = (name96) => {
      if (props.parent && props.bindGroup) {
        return props.parent.props[name96];
      }
    };
    var disabled = computed(() => getParentProp("disabled") || props.disabled);
    var direction = computed(() => getParentProp("direction"));
    var iconStyle = computed(() => {
      var checkedColor = props.checkedColor || getParentProp("checkedColor");
      if (checkedColor && props.checked && !disabled.value) {
        return {
          borderColor: checkedColor,
          backgroundColor: checkedColor
        };
      }
    });
    var onClick = (event) => {
      var {
        target
      } = event;
      var icon = iconRef.value;
      var iconClicked = icon === target || (icon == null ? void 0 : icon.contains(target));
      if (!disabled.value && (iconClicked || !props.labelDisabled)) {
        emit("toggle");
      }
      emit("click", event);
    };
    var renderIcon = () => {
      var {
        bem: bem92,
        shape,
        checked
      } = props;
      var iconSize = props.iconSize || getParentProp("iconSize");
      return createVNode("div", {
        "ref": iconRef,
        "class": bem92("icon", [shape, {
          disabled: disabled.value,
          checked
        }]),
        "style": {
          fontSize: addUnit(iconSize)
        }
      }, [slots.icon ? slots.icon({
        checked,
        disabled: disabled.value
      }) : createVNode(Icon, {
        "name": "success",
        "style": iconStyle.value
      }, null)]);
    };
    var renderLabel = () => {
      if (slots.default) {
        return createVNode("span", {
          "class": props.bem("label", [props.labelPosition, {
            disabled: disabled.value
          }])
        }, [slots.default()]);
      }
    };
    return () => {
      var nodes = props.labelPosition === "left" ? [renderLabel(), renderIcon()] : [renderIcon(), renderLabel()];
      return createVNode("div", {
        "role": props.role,
        "class": props.bem([{
          disabled: disabled.value,
          "label-disabled": props.labelDisabled
        }, direction.value]),
        "tabindex": disabled.value ? void 0 : 0,
        "aria-checked": props.checked,
        "onClick": onClick
      }, [nodes]);
    };
  }
});

// node_modules/vant/es/radio/Radio.js
var [name24, bem24] = createNamespace("radio");
var Radio_default = defineComponent({
  name: name24,
  props: checkerProps,
  emits: ["update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var {
      parent
    } = useParent(RADIO_KEY);
    var checked = () => {
      var value = parent ? parent.props.modelValue : props.modelValue;
      return value === props.name;
    };
    var toggle = () => {
      if (parent) {
        parent.updateValue(props.name);
      } else {
        emit("update:modelValue", props.name);
      }
    };
    return () => createVNode(Checker_default, mergeProps({
      "bem": bem24,
      "role": "radio",
      "parent": parent,
      "checked": checked(),
      "onToggle": toggle
    }, props), pick(slots, ["default", "icon"]));
  }
});

// node_modules/vant/es/radio/index.js
var Radio = withInstall(Radio_default);

// node_modules/vant/es/address-list/AddressListItem.js
var [name25, bem25] = createNamespace("address-item");
var AddressListItem_default = defineComponent({
  name: name25,
  props: {
    address: makeRequiredProp(Object),
    disabled: Boolean,
    switchable: Boolean,
    defaultTagText: String
  },
  emits: ["edit", "click", "select"],
  setup(props, _ref) {
    var {
      slots,
      emit
    } = _ref;
    var onClick = () => {
      if (props.switchable) {
        emit("select");
      }
      emit("click");
    };
    var renderRightIcon = () => createVNode(Icon, {
      "name": "edit",
      "class": bem25("edit"),
      "onClick": (event) => {
        event.stopPropagation();
        emit("edit");
        emit("click");
      }
    }, null);
    var renderTag = () => {
      if (slots.tag) {
        return slots.tag(props.address);
      }
      if (props.address.isDefault && props.defaultTagText) {
        return createVNode(Tag, {
          "type": "danger",
          "round": true,
          "class": bem25("tag")
        }, {
          default: () => [props.defaultTagText]
        });
      }
    };
    var renderContent = () => {
      var {
        address,
        disabled,
        switchable
      } = props;
      var Info = [createVNode("div", {
        "class": bem25("name")
      }, [address.name + " " + address.tel, renderTag()]), createVNode("div", {
        "class": bem25("address")
      }, [address.address])];
      if (switchable && !disabled) {
        return createVNode(Radio, {
          "name": address.id,
          "iconSize": 18
        }, {
          default: () => [Info]
        });
      }
      return Info;
    };
    return () => {
      var {
        disabled
      } = props;
      return createVNode("div", {
        "class": bem25({
          disabled
        }),
        "onClick": onClick
      }, [createVNode(Cell, {
        "border": false,
        "valueClass": bem25("value")
      }, {
        value: renderContent,
        "right-icon": renderRightIcon
      }), slots.bottom == null ? void 0 : slots.bottom(extend({}, props.address, {
        disabled
      }))]);
    };
  }
});

// node_modules/vant/es/address-list/AddressList.js
var [name26, bem26, t4] = createNamespace("address-list");
var addressListProps = {
  list: makeArrayProp(),
  modelValue: numericProp,
  switchable: truthProp,
  disabledText: String,
  disabledList: makeArrayProp(),
  addButtonText: String,
  defaultTagText: String
};
var AddressList_default = defineComponent({
  name: name26,
  props: addressListProps,
  emits: ["add", "edit", "select", "click-item", "edit-disabled", "select-disabled", "update:modelValue"],
  setup(props, _ref) {
    var {
      slots,
      emit
    } = _ref;
    var renderItem = (item, index, disabled) => {
      var onEdit = () => emit(disabled ? "edit-disabled" : "edit", item, index);
      var onClick = () => emit("click-item", item, index);
      var onSelect = () => {
        emit(disabled ? "select-disabled" : "select", item, index);
        if (!disabled) {
          emit("update:modelValue", item.id);
        }
      };
      return createVNode(AddressListItem_default, {
        "key": item.id,
        "address": item,
        "disabled": disabled,
        "switchable": props.switchable,
        "defaultTagText": props.defaultTagText,
        "onEdit": onEdit,
        "onClick": onClick,
        "onSelect": onSelect
      }, {
        bottom: slots["item-bottom"],
        tag: slots.tag
      });
    };
    var renderList = (list, disabled) => {
      if (list) {
        return list.map((item, index) => renderItem(item, index, disabled));
      }
    };
    var renderBottom = () => createVNode("div", {
      "class": [bem26("bottom"), "van-safe-area-bottom"]
    }, [createVNode(Button, {
      "round": true,
      "block": true,
      "type": "danger",
      "text": props.addButtonText || t4("add"),
      "class": bem26("add"),
      "onClick": () => emit("add")
    }, null)]);
    return () => {
      var List2 = renderList(props.list);
      var DisabledList = renderList(props.disabledList, true);
      var DisabledText = props.disabledText && createVNode("div", {
        "class": bem26("disabled-text")
      }, [props.disabledText]);
      return createVNode("div", {
        "class": bem26()
      }, [slots.top == null ? void 0 : slots.top(), createVNode(RadioGroup, {
        "modelValue": props.modelValue
      }, {
        default: () => [List2]
      }), DisabledText, DisabledList, slots.default == null ? void 0 : slots.default(), renderBottom()]);
    };
  }
});

// node_modules/vant/es/address-list/index.js
var AddressList = withInstall(AddressList_default);

// node_modules/vant/es/calendar/utils.js
var [name27, bem27, t5] = createNamespace("calendar");
var formatMonthTitle = (date) => t5("monthTitle", date.getFullYear(), date.getMonth() + 1);
function compareMonth(date1, date2) {
  var year1 = date1.getFullYear();
  var year2 = date2.getFullYear();
  if (year1 === year2) {
    var month1 = date1.getMonth();
    var month2 = date2.getMonth();
    return month1 === month2 ? 0 : month1 > month2 ? 1 : -1;
  }
  return year1 > year2 ? 1 : -1;
}
function compareDay(day1, day2) {
  var compareMonthResult = compareMonth(day1, day2);
  if (compareMonthResult === 0) {
    var date1 = day1.getDate();
    var date2 = day2.getDate();
    return date1 === date2 ? 0 : date1 > date2 ? 1 : -1;
  }
  return compareMonthResult;
}
var cloneDate = (date) => new Date(date);
var cloneDates = (dates) => Array.isArray(dates) ? dates.map(cloneDate) : cloneDate(dates);
function getDayByOffset(date, offset2) {
  var cloned = cloneDate(date);
  cloned.setDate(cloned.getDate() + offset2);
  return cloned;
}
var getPrevDay = (date) => getDayByOffset(date, -1);
var getNextDay = (date) => getDayByOffset(date, 1);
var getToday = () => {
  var today = new Date();
  today.setHours(0, 0, 0, 0);
  return today;
};
function calcDateNum(date) {
  var day1 = date[0].getTime();
  var day2 = date[1].getTime();
  return (day2 - day1) / (1e3 * 60 * 60 * 24) + 1;
}

// node_modules/vant/es/composables/use-refs.js
function useRefs() {
  var refs = ref([]);
  onBeforeUpdate(() => {
    refs.value = [];
  });
  var setRefs = (index) => (el) => {
    refs.value[index] = el;
  };
  return [refs, setRefs];
}

// node_modules/vant/es/datetime-picker/utils.js
var sharedProps = extend({}, pickerSharedProps, {
  filter: Function,
  columnsOrder: Array,
  formatter: {
    type: Function,
    default: (type, value) => value
  }
});
var pickerInheritKeys = Object.keys(pickerSharedProps);
function times(n, iteratee) {
  var index = -1;
  var result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
function getTrueValue(value) {
  if (!value) {
    return 0;
  }
  while (Number.isNaN(parseInt(value, 10))) {
    if (value.length > 1) {
      value = value.slice(1);
    } else {
      return 0;
    }
  }
  return parseInt(value, 10);
}
var getMonthEndDay = (year, month) => 32 - new Date(year, month - 1, 32).getDate();
var proxyPickerMethods = (picker, callback) => {
  var methods = ["setValues", "setIndexes", "setColumnIndex", "setColumnValue"];
  return new Proxy(picker, {
    get: (target, prop) => {
      if (methods.includes(prop)) {
        return function() {
          target[prop](...arguments);
          callback();
        };
      }
      return target[prop];
    }
  });
};

// node_modules/vant/es/composables/use-height.js
var useHeight = (element) => {
  var height2 = ref();
  onMounted(() => nextTick(() => {
    height2.value = useRect(element).height;
  }));
  return height2;
};

// node_modules/vant/es/calendar/CalendarDay.js
var [name28] = createNamespace("calendar-day");
var CalendarDay_default = defineComponent({
  name: name28,
  props: {
    item: makeRequiredProp(Object),
    color: String,
    index: Number,
    offset: makeNumberProp(0),
    rowHeight: String
  },
  emits: ["click"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var style = computed(() => {
      var {
        item,
        index,
        color,
        offset: offset2,
        rowHeight
      } = props;
      var style2 = {
        height: rowHeight
      };
      if (item.type === "placeholder") {
        style2.width = "100%";
        return style2;
      }
      if (index === 0) {
        style2.marginLeft = 100 * offset2 / 7 + "%";
      }
      if (color) {
        switch (item.type) {
          case "end":
          case "start":
          case "start-end":
          case "multiple-middle":
          case "multiple-selected":
            style2.background = color;
            break;
          case "middle":
            style2.color = color;
            break;
        }
      }
      return style2;
    });
    var onClick = () => {
      if (props.item.type !== "disabled") {
        emit("click", props.item);
      }
    };
    var renderTopInfo = () => {
      var {
        topInfo
      } = props.item;
      if (topInfo || slots["top-info"]) {
        return createVNode("div", {
          "class": bem27("top-info")
        }, [slots["top-info"] ? slots["top-info"](props.item) : topInfo]);
      }
    };
    var renderBottomInfo = () => {
      var {
        bottomInfo
      } = props.item;
      if (bottomInfo || slots["bottom-info"]) {
        return createVNode("div", {
          "class": bem27("bottom-info")
        }, [slots["bottom-info"] ? slots["bottom-info"](props.item) : bottomInfo]);
      }
    };
    var renderContent = () => {
      var {
        item,
        color,
        rowHeight
      } = props;
      var {
        type,
        text
      } = item;
      var Nodes = [renderTopInfo(), text, renderBottomInfo()];
      if (type === "selected") {
        return createVNode("div", {
          "class": bem27("selected-day"),
          "style": {
            width: rowHeight,
            height: rowHeight,
            background: color
          }
        }, [Nodes]);
      }
      return Nodes;
    };
    return () => {
      var {
        type,
        className
      } = props.item;
      if (type === "placeholder") {
        return createVNode("div", {
          "class": bem27("day"),
          "style": style.value
        }, null);
      }
      return createVNode("div", {
        "role": "gridcell",
        "style": style.value,
        "class": [bem27("day", type), className],
        "tabindex": type === "disabled" ? void 0 : -1,
        "onClick": onClick
      }, [renderContent()]);
    };
  }
});

// node_modules/vant/es/calendar/CalendarMonth.js
var [name29] = createNamespace("calendar-month");
var calendarMonthProps = {
  date: makeRequiredProp(Date),
  type: String,
  color: String,
  minDate: makeRequiredProp(Date),
  maxDate: makeRequiredProp(Date),
  showMark: Boolean,
  rowHeight: numericProp,
  formatter: Function,
  lazyRender: Boolean,
  currentDate: [Date, Array],
  allowSameDay: Boolean,
  showSubtitle: Boolean,
  showMonthTitle: Boolean,
  firstDayOfWeek: Number
};
var CalendarMonth_default = defineComponent({
  name: name29,
  props: calendarMonthProps,
  emits: ["click", "update-height"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var [visible, setVisible] = useToggle();
    var daysRef = ref();
    var monthRef = ref();
    var height2 = useHeight(monthRef);
    var title = computed(() => formatMonthTitle(props.date));
    var rowHeight = computed(() => addUnit(props.rowHeight));
    var offset2 = computed(() => {
      var realDay = props.date.getDay();
      if (props.firstDayOfWeek) {
        return (realDay + 7 - props.firstDayOfWeek) % 7;
      }
      return realDay;
    });
    var totalDay = computed(() => getMonthEndDay(props.date.getFullYear(), props.date.getMonth() + 1));
    var shouldRender = computed(() => visible.value || !props.lazyRender);
    var getTitle = () => title.value;
    var getMultipleDayType = (day) => {
      var isSelected = (date) => props.currentDate.some((item) => compareDay(item, date) === 0);
      if (isSelected(day)) {
        var prevDay = getPrevDay(day);
        var nextDay = getNextDay(day);
        var prevSelected = isSelected(prevDay);
        var nextSelected = isSelected(nextDay);
        if (prevSelected && nextSelected) {
          return "multiple-middle";
        }
        if (prevSelected) {
          return "end";
        }
        if (nextSelected) {
          return "start";
        }
        return "multiple-selected";
      }
      return "";
    };
    var getRangeDayType = (day) => {
      var [startDay, endDay] = props.currentDate;
      if (!startDay) {
        return "";
      }
      var compareToStart = compareDay(day, startDay);
      if (!endDay) {
        return compareToStart === 0 ? "start" : "";
      }
      var compareToEnd = compareDay(day, endDay);
      if (props.allowSameDay && compareToStart === 0 && compareToEnd === 0) {
        return "start-end";
      }
      if (compareToStart === 0) {
        return "start";
      }
      if (compareToEnd === 0) {
        return "end";
      }
      if (compareToStart > 0 && compareToEnd < 0) {
        return "middle";
      }
      return "";
    };
    var getDayType = (day) => {
      var {
        type,
        minDate,
        maxDate,
        currentDate
      } = props;
      if (compareDay(day, minDate) < 0 || compareDay(day, maxDate) > 0) {
        return "disabled";
      }
      if (currentDate === null) {
        return "";
      }
      if (Array.isArray(currentDate)) {
        if (type === "multiple") {
          return getMultipleDayType(day);
        }
        if (type === "range") {
          return getRangeDayType(day);
        }
      } else if (type === "single") {
        return compareDay(day, currentDate) === 0 ? "selected" : "";
      }
      return "";
    };
    var getBottomInfo = (dayType) => {
      if (props.type === "range") {
        if (dayType === "start" || dayType === "end") {
          return t5(dayType);
        }
        if (dayType === "start-end") {
          return t5("startEnd");
        }
      }
    };
    var renderTitle = () => {
      if (props.showMonthTitle) {
        return createVNode("div", {
          "class": bem27("month-title")
        }, [title.value]);
      }
    };
    var renderMark = () => {
      if (props.showMark && shouldRender.value) {
        return createVNode("div", {
          "class": bem27("month-mark")
        }, [props.date.getMonth() + 1]);
      }
    };
    var placeholders = computed(() => {
      var count = Math.ceil((totalDay.value + offset2.value) / 7);
      return Array(count).fill({
        type: "placeholder"
      });
    });
    var days = computed(() => {
      var days2 = [];
      var year = props.date.getFullYear();
      var month = props.date.getMonth();
      for (var day = 1; day <= totalDay.value; day++) {
        var date = new Date(year, month, day);
        var type = getDayType(date);
        var config = {
          date,
          type,
          text: day,
          bottomInfo: getBottomInfo(type)
        };
        if (props.formatter) {
          config = props.formatter(config);
        }
        days2.push(config);
      }
      return days2;
    });
    var disabledDays = computed(() => days.value.filter((day) => day.type === "disabled"));
    var scrollToDate = (body, targetDate) => {
      if (daysRef.value) {
        var daysRect = useRect(daysRef.value);
        var totalRows = placeholders.value.length;
        var currentRow = Math.ceil((targetDate.getDate() + offset2.value) / 7);
        var rowOffset = (currentRow - 1) * daysRect.height / totalRows;
        setScrollTop(body, daysRect.top + rowOffset + body.scrollTop - useRect(body).top);
      }
    };
    var renderDay = (item, index) => createVNode(CalendarDay_default, {
      "item": item,
      "index": index,
      "color": props.color,
      "offset": offset2.value,
      "rowHeight": rowHeight.value,
      "onClick": (item2) => emit("click", item2)
    }, pick(slots, ["top-info", "bottom-info"]));
    var renderDays = () => createVNode("div", {
      "ref": daysRef,
      "role": "grid",
      "class": bem27("days")
    }, [renderMark(), (shouldRender.value ? days : placeholders).value.map(renderDay)]);
    useExpose({
      getTitle,
      getHeight: () => height2.value,
      setVisible,
      scrollToDate,
      disabledDays
    });
    return () => createVNode("div", {
      "class": bem27("month"),
      "ref": monthRef
    }, [renderTitle(), renderDays()]);
  }
});

// node_modules/vant/es/calendar/CalendarHeader.js
var [name30] = createNamespace("calendar-header");
var CalendarHeader_default = defineComponent({
  name: name30,
  props: {
    title: String,
    subtitle: String,
    showTitle: Boolean,
    showSubtitle: Boolean,
    firstDayOfWeek: Number
  },
  emits: ["click-subtitle"],
  setup(props, _ref) {
    var {
      slots,
      emit
    } = _ref;
    var renderTitle = () => {
      if (props.showTitle) {
        var text = props.title || t5("title");
        var title = slots.title ? slots.title() : text;
        return createVNode("div", {
          "class": bem27("header-title")
        }, [title]);
      }
    };
    var onClickSubtitle = (event) => emit("click-subtitle", event);
    var renderSubtitle = () => {
      if (props.showSubtitle) {
        var title = slots.subtitle ? slots.subtitle() : props.subtitle;
        return createVNode("div", {
          "class": bem27("header-subtitle"),
          "onClick": onClickSubtitle
        }, [title]);
      }
    };
    var renderWeekDays = () => {
      var {
        firstDayOfWeek
      } = props;
      var weekdays = t5("weekdays");
      var renderWeekDays2 = [...weekdays.slice(firstDayOfWeek, 7), ...weekdays.slice(0, firstDayOfWeek)];
      return createVNode("div", {
        "class": bem27("weekdays")
      }, [renderWeekDays2.map((text) => createVNode("span", {
        "class": bem27("weekday")
      }, [text]))]);
    };
    return () => createVNode("div", {
      "class": bem27("header")
    }, [renderTitle(), renderSubtitle(), renderWeekDays()]);
  }
});

// node_modules/vant/es/calendar/Calendar.js
var calendarProps = {
  show: Boolean,
  type: makeStringProp("single"),
  title: String,
  color: String,
  round: truthProp,
  readonly: Boolean,
  poppable: truthProp,
  maxRange: makeNumericProp(null),
  position: makeStringProp("bottom"),
  teleport: [String, Object],
  showMark: truthProp,
  showTitle: truthProp,
  formatter: Function,
  rowHeight: numericProp,
  confirmText: String,
  rangePrompt: String,
  lazyRender: truthProp,
  showConfirm: truthProp,
  defaultDate: [Date, Array],
  allowSameDay: Boolean,
  showSubtitle: truthProp,
  closeOnPopstate: truthProp,
  showRangePrompt: truthProp,
  confirmDisabledText: String,
  closeOnClickOverlay: truthProp,
  safeAreaInsetBottom: truthProp,
  minDate: {
    type: Date,
    validator: isDate,
    default: getToday
  },
  maxDate: {
    type: Date,
    validator: isDate,
    default: () => {
      var now = getToday();
      return new Date(now.getFullYear(), now.getMonth() + 6, now.getDate());
    }
  },
  firstDayOfWeek: {
    type: numericProp,
    default: 0,
    validator: (val) => val >= 0 && val <= 6
  }
};
var Calendar_default = defineComponent({
  name: name27,
  props: calendarProps,
  emits: ["select", "confirm", "unselect", "month-show", "over-range", "update:show", "click-subtitle"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var limitDateRange = function(date, minDate, maxDate) {
      if (minDate === void 0) {
        minDate = props.minDate;
      }
      if (maxDate === void 0) {
        maxDate = props.maxDate;
      }
      if (compareDay(date, minDate) === -1) {
        return minDate;
      }
      if (compareDay(date, maxDate) === 1) {
        return maxDate;
      }
      return date;
    };
    var getInitialDate = function(defaultDate) {
      if (defaultDate === void 0) {
        defaultDate = props.defaultDate;
      }
      var {
        type,
        minDate,
        maxDate
      } = props;
      if (defaultDate === null) {
        return defaultDate;
      }
      var now = getToday();
      if (type === "range") {
        if (!Array.isArray(defaultDate)) {
          defaultDate = [];
        }
        var start2 = limitDateRange(defaultDate[0] || now, minDate, getPrevDay(maxDate));
        var end2 = limitDateRange(defaultDate[1] || now, getNextDay(minDate));
        return [start2, end2];
      }
      if (type === "multiple") {
        if (Array.isArray(defaultDate)) {
          return defaultDate.map((date) => limitDateRange(date));
        }
        return [limitDateRange(now)];
      }
      if (!defaultDate || Array.isArray(defaultDate)) {
        defaultDate = now;
      }
      return limitDateRange(defaultDate);
    };
    var bodyHeight;
    var bodyRef = ref();
    var subtitle = ref("");
    var currentDate = ref(getInitialDate());
    var [monthRefs, setMonthRefs] = useRefs();
    var dayOffset = computed(() => props.firstDayOfWeek ? +props.firstDayOfWeek % 7 : 0);
    var months = computed(() => {
      var months2 = [];
      var cursor = new Date(props.minDate);
      cursor.setDate(1);
      do {
        months2.push(new Date(cursor));
        cursor.setMonth(cursor.getMonth() + 1);
      } while (compareMonth(cursor, props.maxDate) !== 1);
      return months2;
    });
    var buttonDisabled = computed(() => {
      if (currentDate.value) {
        if (props.type === "range") {
          return !currentDate.value[0] || !currentDate.value[1];
        }
        if (props.type === "multiple") {
          return !currentDate.value.length;
        }
      }
      return !currentDate.value;
    });
    var onScroll = () => {
      var top2 = getScrollTop(bodyRef.value);
      var bottom2 = top2 + bodyHeight;
      var heights = months.value.map((item, index) => monthRefs.value[index].getHeight());
      var heightSum = heights.reduce((a, b) => a + b, 0);
      if (bottom2 > heightSum && top2 > 0) {
        return;
      }
      var height2 = 0;
      var currentMonth;
      var visibleRange = [-1, -1];
      for (var i = 0; i < months.value.length; i++) {
        var month = monthRefs.value[i];
        var visible = height2 <= bottom2 && height2 + heights[i] >= top2;
        if (visible) {
          visibleRange[1] = i;
          if (!currentMonth) {
            currentMonth = month;
            visibleRange[0] = i;
          }
          if (!monthRefs.value[i].showed) {
            monthRefs.value[i].showed = true;
            emit("month-show", {
              date: month.date,
              title: month.getTitle()
            });
          }
        }
        height2 += heights[i];
      }
      months.value.forEach((month2, index) => {
        var visible2 = index >= visibleRange[0] - 1 && index <= visibleRange[1] + 1;
        monthRefs.value[index].setVisible(visible2);
      });
      if (currentMonth) {
        subtitle.value = currentMonth.getTitle();
      }
    };
    var scrollToDate = (targetDate) => {
      raf(() => {
        months.value.some((month, index) => {
          if (compareMonth(month, targetDate) === 0) {
            if (bodyRef.value) {
              monthRefs.value[index].scrollToDate(bodyRef.value, targetDate);
            }
            return true;
          }
          return false;
        });
        onScroll();
      });
    };
    var scrollToCurrentDate = () => {
      if (props.poppable && !props.show) {
        return;
      }
      if (currentDate.value) {
        var targetDate = props.type === "single" ? currentDate.value : currentDate.value[0];
        scrollToDate(targetDate);
      } else {
        raf(onScroll);
      }
    };
    var init = () => {
      if (props.poppable && !props.show) {
        return;
      }
      raf(() => {
        bodyHeight = Math.floor(useRect(bodyRef).height);
        scrollToCurrentDate();
      });
    };
    var reset = function(date) {
      if (date === void 0) {
        date = getInitialDate();
      }
      currentDate.value = date;
      scrollToCurrentDate();
    };
    var checkRange = (date) => {
      var {
        maxRange,
        rangePrompt,
        showRangePrompt
      } = props;
      if (maxRange && calcDateNum(date) > maxRange) {
        if (showRangePrompt) {
          Toast(rangePrompt || t5("rangePrompt", maxRange));
        }
        emit("over-range");
        return false;
      }
      return true;
    };
    var onConfirm = () => {
      var _currentDate$value;
      return emit("confirm", (_currentDate$value = currentDate.value) != null ? _currentDate$value : cloneDates(currentDate.value));
    };
    var select = (date, complete) => {
      var setCurrentDate = (date2) => {
        currentDate.value = date2;
        emit("select", cloneDates(date2));
      };
      if (complete && props.type === "range") {
        var valid = checkRange(date);
        if (!valid) {
          setCurrentDate([date[0], getDayByOffset(date[0], +props.maxRange - 1)]);
          return;
        }
      }
      setCurrentDate(date);
      if (complete && !props.showConfirm) {
        onConfirm();
      }
    };
    var getDisabledDate = (disabledDays2, startDay, date) => {
      var _disabledDays$find;
      return (_disabledDays$find = disabledDays2.find((day) => compareDay(startDay, day.date) === -1 && compareDay(day.date, date) === -1)) == null ? void 0 : _disabledDays$find.date;
    };
    var disabledDays = computed(() => monthRefs.value.reduce((arr, ref2) => {
      var _ref$disabledDays$val, _ref$disabledDays;
      arr.push(...(_ref$disabledDays$val = (_ref$disabledDays = ref2.disabledDays) == null ? void 0 : _ref$disabledDays.value) != null ? _ref$disabledDays$val : []);
      return arr;
    }, []));
    var onClickDay = (item) => {
      if (props.readonly || !item.date) {
        return;
      }
      var {
        date
      } = item;
      var {
        type
      } = props;
      if (type === "range") {
        if (!currentDate.value) {
          select([date]);
          return;
        }
        var [startDay, endDay] = currentDate.value;
        if (startDay && !endDay) {
          var compareToStart = compareDay(date, startDay);
          if (compareToStart === 1) {
            var disabledDay = getDisabledDate(disabledDays.value, startDay, date);
            if (disabledDay) {
              select([startDay, getPrevDay(disabledDay)]);
            } else {
              select([startDay, date], true);
            }
          } else if (compareToStart === -1) {
            select([date]);
          } else if (props.allowSameDay) {
            select([date, date], true);
          }
        } else {
          select([date]);
        }
      } else if (type === "multiple") {
        if (!currentDate.value) {
          select([date]);
          return;
        }
        var dates = currentDate.value;
        var selectedIndex = dates.findIndex((dateItem) => compareDay(dateItem, date) === 0);
        if (selectedIndex !== -1) {
          var [unselectedDate] = dates.splice(selectedIndex, 1);
          emit("unselect", cloneDate(unselectedDate));
        } else if (props.maxRange && dates.length >= props.maxRange) {
          Toast(props.rangePrompt || t5("rangePrompt", props.maxRange));
        } else {
          select([...dates, date]);
        }
      } else {
        select(date, true);
      }
    };
    var updateShow = (value) => emit("update:show", value);
    var renderMonth = (date, index) => {
      var showMonthTitle = index !== 0 || !props.showSubtitle;
      return createVNode(CalendarMonth_default, mergeProps({
        "ref": setMonthRefs(index),
        "date": date,
        "currentDate": currentDate.value,
        "showMonthTitle": showMonthTitle,
        "firstDayOfWeek": dayOffset.value
      }, pick(props, ["type", "color", "minDate", "maxDate", "showMark", "formatter", "rowHeight", "lazyRender", "showSubtitle", "allowSameDay"]), {
        "onClick": onClickDay
      }), pick(slots, ["top-info", "bottom-info"]));
    };
    var renderFooterButton = () => {
      if (slots.footer) {
        return slots.footer();
      }
      if (props.showConfirm) {
        var slot = slots["confirm-text"];
        var disabled = buttonDisabled.value;
        var text = disabled ? props.confirmDisabledText : props.confirmText;
        return createVNode(Button, {
          "round": true,
          "block": true,
          "type": "danger",
          "color": props.color,
          "class": bem27("confirm"),
          "disabled": disabled,
          "nativeType": "button",
          "onClick": onConfirm
        }, {
          default: () => [slot ? slot({
            disabled
          }) : text || t5("confirm")]
        });
      }
    };
    var renderFooter = () => createVNode("div", {
      "class": [bem27("footer"), {
        "van-safe-area-bottom": props.safeAreaInsetBottom
      }]
    }, [renderFooterButton()]);
    var renderCalendar = () => createVNode("div", {
      "class": bem27()
    }, [createVNode(CalendarHeader_default, {
      "title": props.title,
      "subtitle": subtitle.value,
      "showTitle": props.showTitle,
      "showSubtitle": props.showSubtitle,
      "firstDayOfWeek": dayOffset.value,
      "onClick-subtitle": (event) => emit("click-subtitle", event)
    }, pick(slots, ["title", "subtitle"])), createVNode("div", {
      "ref": bodyRef,
      "class": bem27("body"),
      "onScroll": onScroll
    }, [months.value.map(renderMonth)]), renderFooter()]);
    watch(() => props.show, init);
    watch(() => [props.type, props.minDate, props.maxDate], () => reset(getInitialDate(currentDate.value)));
    watch(() => props.defaultDate, function(value) {
      if (value === void 0) {
        value = null;
      }
      currentDate.value = value;
      scrollToCurrentDate();
    });
    useExpose({
      reset,
      scrollToDate
    });
    onMountedOrActivated(init);
    return () => {
      if (props.poppable) {
        return createVNode(Popup, {
          "show": props.show,
          "class": bem27("popup"),
          "round": props.round,
          "position": props.position,
          "closeable": props.showTitle || props.showSubtitle,
          "teleport": props.teleport,
          "closeOnPopstate": props.closeOnPopstate,
          "closeOnClickOverlay": props.closeOnClickOverlay,
          "onUpdate:show": updateShow
        }, {
          default: renderCalendar
        });
      }
      return renderCalendar();
    };
  }
});

// node_modules/vant/es/calendar/index.js
var Calendar = withInstall(Calendar_default);

// node_modules/vant/es/image/Image.js
var [name31, bem28] = createNamespace("image");
var imageProps = {
  src: String,
  alt: String,
  fit: String,
  round: Boolean,
  width: numericProp,
  height: numericProp,
  radius: numericProp,
  lazyLoad: Boolean,
  iconSize: numericProp,
  showError: truthProp,
  errorIcon: makeStringProp("photo-fail"),
  iconPrefix: String,
  showLoading: truthProp,
  loadingIcon: makeStringProp("photo")
};
var Image_default = defineComponent({
  name: name31,
  props: imageProps,
  emits: ["load", "error"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var error = ref(false);
    var loading = ref(true);
    var imageRef = ref();
    var {
      $Lazyload
    } = getCurrentInstance().proxy;
    var style = computed(() => {
      var style2 = {
        width: addUnit(props.width),
        height: addUnit(props.height)
      };
      if (isDef(props.radius)) {
        style2.overflow = "hidden";
        style2.borderRadius = addUnit(props.radius);
      }
      return style2;
    });
    watch(() => props.src, () => {
      error.value = false;
      loading.value = true;
    });
    var onLoad = (event) => {
      loading.value = false;
      emit("load", event);
    };
    var onError = (event) => {
      error.value = true;
      loading.value = false;
      emit("error", event);
    };
    var renderIcon = (name96, className, slot) => {
      if (slot) {
        return slot();
      }
      return createVNode(Icon, {
        "name": name96,
        "size": props.iconSize,
        "class": className,
        "classPrefix": props.iconPrefix
      }, null);
    };
    var renderPlaceholder = () => {
      if (loading.value && props.showLoading) {
        return createVNode("div", {
          "class": bem28("loading")
        }, [renderIcon(props.loadingIcon, bem28("loading-icon"), slots.loading)]);
      }
      if (error.value && props.showError) {
        return createVNode("div", {
          "class": bem28("error")
        }, [renderIcon(props.errorIcon, bem28("error-icon"), slots.error)]);
      }
    };
    var renderImage = () => {
      if (error.value || !props.src) {
        return;
      }
      var attrs = {
        alt: props.alt,
        class: bem28("img"),
        style: {
          objectFit: props.fit
        }
      };
      if (props.lazyLoad) {
        return withDirectives(createVNode("img", mergeProps({
          "ref": imageRef
        }, attrs), null), [[resolveDirective("lazy"), props.src]]);
      }
      return createVNode("img", mergeProps({
        "src": props.src,
        "onLoad": onLoad,
        "onError": onError
      }, attrs), null);
    };
    var onLazyLoaded = (_ref2) => {
      var {
        el
      } = _ref2;
      if (el === imageRef.value && loading.value) {
        onLoad();
      }
    };
    var onLazyLoadError = (_ref3) => {
      var {
        el
      } = _ref3;
      if (el === imageRef.value && !error.value) {
        onError();
      }
    };
    if ($Lazyload && inBrowser) {
      $Lazyload.$on("loaded", onLazyLoaded);
      $Lazyload.$on("error", onLazyLoadError);
      onBeforeUnmount(() => {
        $Lazyload.$off("loaded", onLazyLoaded);
        $Lazyload.$off("error", onLazyLoadError);
      });
    }
    return () => createVNode("div", {
      "class": bem28({
        round: props.round
      }),
      "style": style.value
    }, [renderImage(), renderPlaceholder(), slots.default == null ? void 0 : slots.default()]);
  }
});

// node_modules/vant/es/image/index.js
var Image2 = withInstall(Image_default);

// node_modules/vant/es/card/Card.js
var [name32, bem29] = createNamespace("card");
var cardProps = {
  tag: String,
  num: numericProp,
  desc: String,
  thumb: String,
  title: String,
  price: numericProp,
  centered: Boolean,
  lazyLoad: Boolean,
  currency: makeStringProp("\xA5"),
  thumbLink: String,
  originPrice: numericProp
};
var Card_default = defineComponent({
  name: name32,
  props: cardProps,
  emits: ["click-thumb"],
  setup(props, _ref) {
    var {
      slots,
      emit
    } = _ref;
    var renderTitle = () => {
      if (slots.title) {
        return slots.title();
      }
      if (props.title) {
        return createVNode("div", {
          "class": [bem29("title"), "van-multi-ellipsis--l2"]
        }, [props.title]);
      }
    };
    var renderThumbTag = () => {
      if (slots.tag || props.tag) {
        return createVNode("div", {
          "class": bem29("tag")
        }, [slots.tag ? slots.tag() : createVNode(Tag, {
          "mark": true,
          "type": "danger"
        }, {
          default: () => [props.tag]
        })]);
      }
    };
    var renderThumbImage = () => {
      if (slots.thumb) {
        return slots.thumb();
      }
      return createVNode(Image2, {
        "src": props.thumb,
        "fit": "cover",
        "width": "100%",
        "height": "100%",
        "lazyLoad": props.lazyLoad
      }, null);
    };
    var renderThumb = () => {
      if (slots.thumb || props.thumb) {
        return createVNode("a", {
          "href": props.thumbLink,
          "class": bem29("thumb"),
          "onClick": (event) => emit("click-thumb", event)
        }, [renderThumbImage(), renderThumbTag()]);
      }
    };
    var renderDesc = () => {
      if (slots.desc) {
        return slots.desc();
      }
      if (props.desc) {
        return createVNode("div", {
          "class": [bem29("desc"), "van-ellipsis"]
        }, [props.desc]);
      }
    };
    var renderPriceText = () => {
      var priceArr = props.price.toString().split(".");
      return createVNode("div", null, [createVNode("span", {
        "class": bem29("price-currency")
      }, [props.currency]), createVNode("span", {
        "class": bem29("price-integer")
      }, [priceArr[0]]), createTextVNode("."), createVNode("span", {
        "class": bem29("price-decimal")
      }, [priceArr[1]])]);
    };
    return () => {
      var _slots$priceTop;
      var showNum = slots.num || isDef(props.num);
      var showPrice = slots.price || isDef(props.price);
      var showOriginPrice = slots["origin-price"] || isDef(props.originPrice);
      var showBottom = showNum || showPrice || showOriginPrice || slots.bottom;
      var Price = showPrice && createVNode("div", {
        "class": bem29("price")
      }, [slots.price ? slots.price() : renderPriceText()]);
      var OriginPrice = showOriginPrice && createVNode("div", {
        "class": bem29("origin-price")
      }, [slots["origin-price"] ? slots["origin-price"]() : props.currency + " " + props.originPrice]);
      var Num = showNum && createVNode("div", {
        "class": bem29("num")
      }, [slots.num ? slots.num() : "x" + props.num]);
      var Footer = slots.footer && createVNode("div", {
        "class": bem29("footer")
      }, [slots.footer()]);
      var Bottom = showBottom && createVNode("div", {
        "class": bem29("bottom")
      }, [(_slots$priceTop = slots["price-top"]) == null ? void 0 : _slots$priceTop.call(slots), Price, OriginPrice, Num, slots.bottom == null ? void 0 : slots.bottom()]);
      return createVNode("div", {
        "class": bem29()
      }, [createVNode("div", {
        "class": bem29("header")
      }, [renderThumb(), createVNode("div", {
        "class": bem29("content", {
          centered: props.centered
        })
      }, [createVNode("div", null, [renderTitle(), renderDesc(), slots.tags == null ? void 0 : slots.tags()]), Bottom])]), Footer]);
    };
  }
});

// node_modules/vant/es/card/index.js
var Card = withInstall(Card_default);

// node_modules/vant/es/tabs/utils.js
function scrollLeftTo(scroller, to, duration) {
  var count = 0;
  var from = scroller.scrollLeft;
  var frames = duration === 0 ? 1 : Math.round(duration * 1e3 / 16);
  function animate() {
    scroller.scrollLeft += (to - from) / frames;
    if (++count < frames) {
      raf(animate);
    }
  }
  animate();
}
function scrollTopTo(scroller, to, duration, callback) {
  var current2 = getScrollTop(scroller);
  var isDown = current2 < to;
  var frames = duration === 0 ? 1 : Math.round(duration * 1e3 / 16);
  var step = (to - current2) / frames;
  function animate() {
    current2 += step;
    if (isDown && current2 > to || !isDown && current2 < to) {
      current2 = to;
    }
    setScrollTop(scroller, current2);
    if (isDown && current2 < to || !isDown && current2 > to) {
      raf(animate);
    } else if (callback) {
      raf(callback);
    }
  }
  animate();
}

// node_modules/vant/es/composables/use-visibility-change.js
function useVisibilityChange(target, onChange) {
  if (!inBrowser || !window.IntersectionObserver) {
    return;
  }
  var observer = new IntersectionObserver((entries) => {
    onChange(entries[0].intersectionRatio > 0);
  }, {
    root: document.body
  });
  var observe = () => {
    if (target.value) {
      observer.observe(target.value);
    }
  };
  var unobserve = () => {
    if (target.value) {
      observer.unobserve(target.value);
    }
  };
  onDeactivated(unobserve);
  onBeforeUnmount(unobserve);
  onMountedOrActivated(observe);
}

// node_modules/vant/es/sticky/Sticky.js
var [name33, bem30] = createNamespace("sticky");
var stickyProps = {
  zIndex: numericProp,
  position: makeStringProp("top"),
  container: Object,
  offsetTop: makeNumericProp(0),
  offsetBottom: makeNumericProp(0)
};
var Sticky_default = defineComponent({
  name: name33,
  props: stickyProps,
  emits: ["scroll", "change"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var root = ref();
    var scrollParent = useScrollParent(root);
    var state = reactive({
      fixed: false,
      width: 0,
      height: 0,
      transform: 0
    });
    var offset2 = computed(() => unitToPx(props.position === "top" ? props.offsetTop : props.offsetBottom));
    var rootStyle = computed(() => {
      var {
        fixed,
        height: height2,
        width: width2
      } = state;
      if (fixed) {
        return {
          width: width2 + "px",
          height: height2 + "px"
        };
      }
    });
    var stickyStyle = computed(() => {
      if (!state.fixed) {
        return;
      }
      var style = extend(getZIndexStyle(props.zIndex), {
        width: state.width + "px",
        height: state.height + "px",
        [props.position]: offset2.value + "px"
      });
      if (state.transform) {
        style.transform = "translate3d(0, " + state.transform + "px, 0)";
      }
      return style;
    });
    var emitScroll = (scrollTop) => emit("scroll", {
      scrollTop,
      isFixed: state.fixed
    });
    var onScroll = () => {
      if (!root.value || isHidden(root)) {
        return;
      }
      var {
        container,
        position
      } = props;
      var rootRect = useRect(root);
      var scrollTop = getScrollTop(window);
      state.width = rootRect.width;
      state.height = rootRect.height;
      if (position === "top") {
        if (container) {
          var containerRect = useRect(container);
          var difference = containerRect.bottom - offset2.value - state.height;
          state.fixed = offset2.value > rootRect.top && containerRect.bottom > 0;
          state.transform = difference < 0 ? difference : 0;
        } else {
          state.fixed = offset2.value > rootRect.top;
        }
      } else {
        var {
          clientHeight
        } = document.documentElement;
        if (container) {
          var _containerRect = useRect(container);
          var _difference = clientHeight - _containerRect.top - offset2.value - state.height;
          state.fixed = clientHeight - offset2.value < rootRect.bottom && clientHeight > _containerRect.top;
          state.transform = _difference < 0 ? -_difference : 0;
        } else {
          state.fixed = clientHeight - offset2.value < rootRect.bottom;
        }
      }
      emitScroll(scrollTop);
    };
    watch(() => state.fixed, (value) => emit("change", value));
    useEventListener("scroll", onScroll, {
      target: scrollParent
    });
    useVisibilityChange(root, onScroll);
    return () => createVNode("div", {
      "ref": root,
      "style": rootStyle.value
    }, [createVNode("div", {
      "class": bem30({
        fixed: state.fixed
      }),
      "style": stickyStyle.value
    }, [slots.default == null ? void 0 : slots.default()])]);
  }
});

// node_modules/vant/es/sticky/index.js
var Sticky = withInstall(Sticky_default);

// node_modules/vant/es/tabs/TabsTitle.js
var [name34, bem31] = createNamespace("tab");
var TabsTitle_default = defineComponent({
  name: name34,
  props: {
    id: String,
    dot: Boolean,
    type: String,
    color: String,
    title: String,
    badge: numericProp,
    isActive: Boolean,
    disabled: Boolean,
    controls: String,
    scrollable: Boolean,
    activeColor: String,
    renderTitle: Function,
    inactiveColor: String,
    showZeroBadge: truthProp
  },
  setup(props) {
    var style = computed(() => {
      var style2 = {};
      var {
        type,
        color,
        disabled,
        isActive,
        activeColor,
        inactiveColor
      } = props;
      var isCard = type === "card";
      if (color && isCard) {
        style2.borderColor = color;
        if (!disabled) {
          if (isActive) {
            style2.backgroundColor = color;
          } else {
            style2.color = color;
          }
        }
      }
      var titleColor = isActive ? activeColor : inactiveColor;
      if (titleColor) {
        style2.color = titleColor;
      }
      return style2;
    });
    var renderText = () => {
      var Text = createVNode("span", {
        "class": bem31("text", {
          ellipsis: !props.scrollable
        })
      }, [props.renderTitle ? props.renderTitle() : props.title]);
      if (props.dot || isDef(props.badge) && props.badge !== "") {
        return createVNode(Badge, {
          "dot": props.dot,
          "content": props.badge,
          "showZero": props.showZeroBadge
        }, {
          default: () => [Text]
        });
      }
      return Text;
    };
    return () => createVNode("div", {
      "id": props.id,
      "role": "tab",
      "class": [bem31({
        active: props.isActive,
        disabled: props.disabled
      })],
      "style": style.value,
      "tabindex": props.disabled ? void 0 : props.isActive ? 0 : -1,
      "aria-selected": props.isActive,
      "aria-disabled": props.disabled || void 0,
      "aria-controls": props.controls
    }, [renderText()]);
  }
});

// node_modules/vant/es/swipe/Swipe.js
var [name35, bem32] = createNamespace("swipe");
var swipeProps = {
  loop: truthProp,
  width: numericProp,
  height: numericProp,
  vertical: Boolean,
  autoplay: makeNumericProp(0),
  duration: makeNumericProp(500),
  touchable: truthProp,
  lazyRender: Boolean,
  initialSwipe: makeNumericProp(0),
  indicatorColor: String,
  showIndicators: truthProp,
  stopPropagation: truthProp
};
var SWIPE_KEY = Symbol(name35);
var Swipe_default = defineComponent({
  name: name35,
  props: swipeProps,
  emits: ["change"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var root = ref();
    var state = reactive({
      rect: null,
      width: 0,
      height: 0,
      offset: 0,
      active: 0,
      swiping: false
    });
    var touch = useTouch();
    var {
      children,
      linkChildren
    } = useChildren(SWIPE_KEY);
    var count = computed(() => children.length);
    var size = computed(() => state[props.vertical ? "height" : "width"]);
    var delta = computed(() => props.vertical ? touch.deltaY.value : touch.deltaX.value);
    var minOffset = computed(() => {
      if (state.rect) {
        var base = props.vertical ? state.rect.height : state.rect.width;
        return base - size.value * count.value;
      }
      return 0;
    });
    var maxCount = computed(() => Math.ceil(Math.abs(minOffset.value) / size.value));
    var trackSize = computed(() => count.value * size.value);
    var activeIndicator = computed(() => (state.active + count.value) % count.value);
    var isCorrectDirection = computed(() => {
      var expect = props.vertical ? "vertical" : "horizontal";
      return touch.direction.value === expect;
    });
    var trackStyle = computed(() => {
      var style = {
        transitionDuration: (state.swiping ? 0 : props.duration) + "ms",
        transform: "translate" + (props.vertical ? "Y" : "X") + "(" + state.offset + "px)"
      };
      if (size.value) {
        var mainAxis = props.vertical ? "height" : "width";
        var crossAxis = props.vertical ? "width" : "height";
        style[mainAxis] = trackSize.value + "px";
        style[crossAxis] = props[crossAxis] ? props[crossAxis] + "px" : "";
      }
      return style;
    });
    var getTargetActive = (pace) => {
      var {
        active
      } = state;
      if (pace) {
        if (props.loop) {
          return clamp(active + pace, -1, count.value);
        }
        return clamp(active + pace, 0, maxCount.value);
      }
      return active;
    };
    var getTargetOffset = function(targetActive, offset2) {
      if (offset2 === void 0) {
        offset2 = 0;
      }
      var currentPosition = targetActive * size.value;
      if (!props.loop) {
        currentPosition = Math.min(currentPosition, -minOffset.value);
      }
      var targetOffset = offset2 - currentPosition;
      if (!props.loop) {
        targetOffset = clamp(targetOffset, minOffset.value, 0);
      }
      return targetOffset;
    };
    var move = (_ref2) => {
      var {
        pace = 0,
        offset: offset2 = 0,
        emitChange
      } = _ref2;
      if (count.value <= 1) {
        return;
      }
      var {
        active
      } = state;
      var targetActive = getTargetActive(pace);
      var targetOffset = getTargetOffset(targetActive, offset2);
      if (props.loop) {
        if (children[0] && targetOffset !== minOffset.value) {
          var outRightBound = targetOffset < minOffset.value;
          children[0].setOffset(outRightBound ? trackSize.value : 0);
        }
        if (children[count.value - 1] && targetOffset !== 0) {
          var outLeftBound = targetOffset > 0;
          children[count.value - 1].setOffset(outLeftBound ? -trackSize.value : 0);
        }
      }
      state.active = targetActive;
      state.offset = targetOffset;
      if (emitChange && targetActive !== active) {
        emit("change", activeIndicator.value);
      }
    };
    var correctPosition = () => {
      state.swiping = true;
      if (state.active <= -1) {
        move({
          pace: count.value
        });
      } else if (state.active >= count.value) {
        move({
          pace: -count.value
        });
      }
    };
    var prev = () => {
      correctPosition();
      touch.reset();
      doubleRaf(() => {
        state.swiping = false;
        move({
          pace: -1,
          emitChange: true
        });
      });
    };
    var next = () => {
      correctPosition();
      touch.reset();
      doubleRaf(() => {
        state.swiping = false;
        move({
          pace: 1,
          emitChange: true
        });
      });
    };
    var autoplayTimer;
    var stopAutoplay = () => clearTimeout(autoplayTimer);
    var autoplay = () => {
      stopAutoplay();
      if (props.autoplay > 0 && count.value > 1) {
        autoplayTimer = setTimeout(() => {
          next();
          autoplay();
        }, +props.autoplay);
      }
    };
    var initialize = function(active) {
      if (active === void 0) {
        active = +props.initialSwipe;
      }
      if (!root.value) {
        return;
      }
      if (!isHidden(root)) {
        var _props$width, _props$height;
        var rect = {
          width: root.value.offsetWidth,
          height: root.value.offsetHeight
        };
        state.rect = rect;
        state.width = +((_props$width = props.width) != null ? _props$width : rect.width);
        state.height = +((_props$height = props.height) != null ? _props$height : rect.height);
      }
      if (count.value) {
        active = Math.min(count.value - 1, active);
      }
      state.active = active;
      state.swiping = true;
      state.offset = getTargetOffset(active);
      children.forEach((swipe) => {
        swipe.setOffset(0);
      });
      autoplay();
    };
    var resize = () => initialize(state.active);
    var touchStartTime;
    var onTouchStart = (event) => {
      if (!props.touchable)
        return;
      touch.start(event);
      touchStartTime = Date.now();
      stopAutoplay();
      correctPosition();
    };
    var onTouchMove = (event) => {
      if (props.touchable && state.swiping) {
        touch.move(event);
        var shouldPrevent = isCorrectDirection.value || touch.offsetY.value > touch.offsetX.value === props.vertical;
        if (shouldPrevent) {
          preventDefault(event, props.stopPropagation);
        }
        if (isCorrectDirection.value) {
          move({
            offset: delta.value
          });
        }
      }
    };
    var onTouchEnd = () => {
      if (!props.touchable || !state.swiping) {
        return;
      }
      var duration = Date.now() - touchStartTime;
      var speed = delta.value / duration;
      var shouldSwipe = Math.abs(speed) > 0.25 || Math.abs(delta.value) > size.value / 2;
      if (shouldSwipe && isCorrectDirection.value) {
        var offset2 = props.vertical ? touch.offsetY.value : touch.offsetX.value;
        var pace = 0;
        if (props.loop) {
          pace = offset2 > 0 ? delta.value > 0 ? -1 : 1 : 0;
        } else {
          pace = -Math[delta.value > 0 ? "ceil" : "floor"](delta.value / size.value);
        }
        move({
          pace,
          emitChange: true
        });
      } else if (delta.value) {
        move({
          pace: 0
        });
      }
      state.swiping = false;
      autoplay();
    };
    var swipeTo = function(index, options) {
      if (options === void 0) {
        options = {};
      }
      correctPosition();
      touch.reset();
      doubleRaf(() => {
        var targetIndex;
        if (props.loop && index === count.value) {
          targetIndex = state.active === 0 ? 0 : index;
        } else {
          targetIndex = index % count.value;
        }
        if (options.immediate) {
          doubleRaf(() => {
            state.swiping = false;
          });
        } else {
          state.swiping = false;
        }
        move({
          pace: targetIndex - state.active,
          emitChange: true
        });
      });
    };
    var renderDot = (_, index) => {
      var active = index === activeIndicator.value;
      var style = active ? {
        backgroundColor: props.indicatorColor
      } : void 0;
      return createVNode("i", {
        "style": style,
        "class": bem32("indicator", {
          active
        })
      }, null);
    };
    var renderIndicator = () => {
      if (slots.indicator) {
        return slots.indicator({
          active: activeIndicator.value
        });
      }
      if (props.showIndicators && count.value > 1) {
        return createVNode("div", {
          "class": bem32("indicators", {
            vertical: props.vertical
          })
        }, [Array(count.value).fill("").map(renderDot)]);
      }
    };
    useExpose({
      prev,
      next,
      state,
      resize,
      swipeTo
    });
    linkChildren({
      size,
      props,
      count,
      activeIndicator
    });
    watch(() => props.initialSwipe, (value) => initialize(+value));
    watch(count, () => initialize(state.active));
    watch(() => props.autoplay, autoplay);
    watch([windowWidth, windowHeight], resize);
    watch(usePageVisibility(), (visible) => {
      if (visible === "visible") {
        autoplay();
      } else {
        stopAutoplay();
      }
    });
    onMounted(initialize);
    onActivated(() => initialize(state.active));
    onPopupReopen(() => initialize(state.active));
    onDeactivated(stopAutoplay);
    onBeforeUnmount(stopAutoplay);
    return () => createVNode("div", {
      "ref": root,
      "class": bem32()
    }, [createVNode("div", {
      "style": trackStyle.value,
      "class": bem32("track", {
        vertical: props.vertical
      }),
      "onTouchstart": onTouchStart,
      "onTouchmove": onTouchMove,
      "onTouchend": onTouchEnd,
      "onTouchcancel": onTouchEnd
    }, [slots.default == null ? void 0 : slots.default()]), renderIndicator()]);
  }
});

// node_modules/vant/es/swipe/index.js
var Swipe = withInstall(Swipe_default);

// node_modules/vant/es/tabs/TabsContent.js
var [name36, bem33] = createNamespace("tabs");
var TabsContent_default = defineComponent({
  name: name36,
  props: {
    count: makeRequiredProp(Number),
    inited: Boolean,
    animated: Boolean,
    duration: makeRequiredProp(numericProp),
    swipeable: Boolean,
    lazyRender: Boolean,
    currentIndex: makeRequiredProp(Number)
  },
  emits: ["change"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var swipeRef = ref();
    var onChange = (index) => emit("change", index);
    var renderChildren = () => {
      var Content = slots.default == null ? void 0 : slots.default();
      if (props.animated || props.swipeable) {
        return createVNode(Swipe, {
          "ref": swipeRef,
          "loop": false,
          "class": bem33("track"),
          "duration": +props.duration * 1e3,
          "touchable": props.swipeable,
          "lazyRender": props.lazyRender,
          "showIndicators": false,
          "onChange": onChange
        }, {
          default: () => [Content]
        });
      }
      return Content;
    };
    var swipeToCurrentTab = (index) => {
      var swipe = swipeRef.value;
      if (swipe && swipe.state.active !== index) {
        swipe.swipeTo(index, {
          immediate: !props.inited
        });
      }
    };
    watch(() => props.currentIndex, swipeToCurrentTab);
    onMounted(() => {
      swipeToCurrentTab(props.currentIndex);
    });
    return () => createVNode("div", {
      "class": bem33("content", {
        animated: props.animated || props.swipeable
      })
    }, [renderChildren()]);
  }
});

// node_modules/vant/es/tabs/Tabs.js
var [name37, bem34] = createNamespace("tabs");
var tabsProps = {
  type: makeStringProp("line"),
  color: String,
  border: Boolean,
  sticky: Boolean,
  active: makeNumericProp(0),
  duration: makeNumericProp(0.3),
  animated: Boolean,
  ellipsis: truthProp,
  swipeable: Boolean,
  scrollspy: Boolean,
  offsetTop: makeNumericProp(0),
  background: String,
  lazyRender: truthProp,
  lineWidth: numericProp,
  lineHeight: numericProp,
  beforeChange: Function,
  swipeThreshold: makeNumericProp(5),
  titleActiveColor: String,
  titleInactiveColor: String
};
var TABS_KEY = Symbol(name37);
var Tabs_default = defineComponent({
  name: name37,
  props: tabsProps,
  emits: ["click", "change", "scroll", "disabled", "rendered", "click-tab", "update:active"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    if (true) {
      var _getCurrentInstance, _getCurrentInstance$v;
      var _props = (_getCurrentInstance = getCurrentInstance()) == null ? void 0 : (_getCurrentInstance$v = _getCurrentInstance.vnode) == null ? void 0 : _getCurrentInstance$v.props;
      if (_props && "onClick" in _props) {
        console.warn('[Vant] Tabs: "click" event is deprecated, using "click-tab" instead.');
      }
      if (_props && "onDisabled" in _props) {
        console.warn('[Vant] Tabs: "disabled" event is deprecated, using "click-tab" instead.');
      }
    }
    var tabHeight;
    var lockScroll;
    var stickyFixed;
    var root = ref();
    var navRef = ref();
    var wrapRef = ref();
    var id = useId();
    var scroller = useScrollParent(root);
    var [titleRefs, setTitleRefs] = useRefs();
    var {
      children,
      linkChildren
    } = useChildren(TABS_KEY);
    var state = reactive({
      inited: false,
      position: "",
      lineStyle: {},
      currentIndex: -1
    });
    var scrollable = computed(() => children.length > props.swipeThreshold || !props.ellipsis);
    var navStyle = computed(() => ({
      borderColor: props.color,
      background: props.background
    }));
    var getTabName = (tab, index) => {
      var _tab$name;
      return (_tab$name = tab.name) != null ? _tab$name : index;
    };
    var currentName = computed(() => {
      var activeTab = children[state.currentIndex];
      if (activeTab) {
        return getTabName(activeTab, state.currentIndex);
      }
    });
    var offsetTopPx = computed(() => unitToPx(props.offsetTop));
    var scrollOffset = computed(() => {
      if (props.sticky) {
        return offsetTopPx.value + tabHeight;
      }
      return 0;
    });
    var scrollIntoView = (immediate) => {
      var nav = navRef.value;
      var titles = titleRefs.value;
      if (!scrollable.value || !nav || !titles || !titles[state.currentIndex]) {
        return;
      }
      var title = titles[state.currentIndex].$el;
      var to = title.offsetLeft - (nav.offsetWidth - title.offsetWidth) / 2;
      scrollLeftTo(nav, to, immediate ? 0 : +props.duration);
    };
    var setLine = () => {
      var shouldAnimate = state.inited;
      nextTick(() => {
        var titles = titleRefs.value;
        if (!titles || !titles[state.currentIndex] || props.type !== "line" || isHidden(root.value)) {
          return;
        }
        var title = titles[state.currentIndex].$el;
        var {
          lineWidth,
          lineHeight
        } = props;
        var left2 = title.offsetLeft + title.offsetWidth / 2;
        var lineStyle = {
          width: addUnit(lineWidth),
          backgroundColor: props.color,
          transform: "translateX(" + left2 + "px) translateX(-50%)"
        };
        if (shouldAnimate) {
          lineStyle.transitionDuration = props.duration + "s";
        }
        if (isDef(lineHeight)) {
          var height2 = addUnit(lineHeight);
          lineStyle.height = height2;
          lineStyle.borderRadius = height2;
        }
        state.lineStyle = lineStyle;
      });
    };
    var findAvailableTab = (index) => {
      var diff = index < state.currentIndex ? -1 : 1;
      while (index >= 0 && index < children.length) {
        if (!children[index].disabled) {
          return index;
        }
        index += diff;
      }
    };
    var setCurrentIndex = (currentIndex) => {
      var newIndex = findAvailableTab(currentIndex);
      if (!isDef(newIndex)) {
        return;
      }
      var newTab = children[newIndex];
      var newName = getTabName(newTab, newIndex);
      var shouldEmitChange = state.currentIndex !== null;
      state.currentIndex = newIndex;
      if (newName !== props.active) {
        emit("update:active", newName);
        if (shouldEmitChange) {
          emit("change", newName, newTab.title);
        }
      }
    };
    var setCurrentIndexByName = (name96) => {
      var matched = children.find((tab, index2) => getTabName(tab, index2) === name96);
      var index = matched ? children.indexOf(matched) : 0;
      setCurrentIndex(index);
    };
    var scrollToCurrentContent = function(immediate) {
      if (immediate === void 0) {
        immediate = false;
      }
      if (props.scrollspy) {
        var target = children[state.currentIndex].$el;
        if (target && scroller.value) {
          var to = getElementTop(target, scroller.value) - scrollOffset.value;
          lockScroll = true;
          scrollTopTo(scroller.value, to, immediate ? 0 : +props.duration, () => {
            lockScroll = false;
          });
        }
      }
    };
    var onClickTab = (item, index, event) => {
      var {
        title,
        disabled
      } = children[index];
      var name96 = getTabName(children[index], index);
      if (disabled) {
        emit("disabled", name96, title);
      } else {
        callInterceptor(props.beforeChange, {
          args: [name96],
          done: () => {
            setCurrentIndex(index);
            scrollToCurrentContent();
          }
        });
        emit("click", name96, title);
        route(item);
      }
      emit("click-tab", {
        name: name96,
        title,
        event,
        disabled
      });
    };
    var onStickyScroll = (params) => {
      stickyFixed = params.isFixed;
      emit("scroll", params);
    };
    var scrollTo = (name96) => {
      nextTick(() => {
        setCurrentIndexByName(name96);
        scrollToCurrentContent(true);
      });
    };
    var getCurrentIndexOnScroll = () => {
      for (var index = 0; index < children.length; index++) {
        var {
          top: top2
        } = useRect(children[index].$el);
        if (top2 > scrollOffset.value) {
          return index === 0 ? 0 : index - 1;
        }
      }
      return children.length - 1;
    };
    var onScroll = () => {
      if (props.scrollspy && !lockScroll) {
        var index = getCurrentIndexOnScroll();
        setCurrentIndex(index);
      }
    };
    var renderNav = () => children.map((item, index) => createVNode(TabsTitle_default, mergeProps({
      "id": id + "-" + index,
      "ref": setTitleRefs(index),
      "type": props.type,
      "color": props.color,
      "style": item.titleStyle,
      "class": item.titleClass,
      "isActive": index === state.currentIndex,
      "controls": item.id,
      "scrollable": scrollable.value,
      "renderTitle": item.$slots.title,
      "activeColor": props.titleActiveColor,
      "inactiveColor": props.titleInactiveColor,
      "onClick": (event) => onClickTab(item, index, event)
    }, pick(item, ["dot", "badge", "title", "disabled", "showZeroBadge"])), null));
    var renderHeader = () => {
      var _slots$navLeft, _slots$navRight;
      var {
        type,
        border
      } = props;
      return createVNode("div", {
        "ref": wrapRef,
        "class": [bem34("wrap", {
          scrollable: scrollable.value
        }), {
          [BORDER_TOP_BOTTOM]: type === "line" && border
        }]
      }, [createVNode("div", {
        "ref": navRef,
        "role": "tablist",
        "class": bem34("nav", [type, {
          complete: scrollable.value
        }]),
        "style": navStyle.value,
        "aria-orientation": "horizontal"
      }, [(_slots$navLeft = slots["nav-left"]) == null ? void 0 : _slots$navLeft.call(slots), renderNav(), type === "line" && createVNode("div", {
        "class": bem34("line"),
        "style": state.lineStyle
      }, null), (_slots$navRight = slots["nav-right"]) == null ? void 0 : _slots$navRight.call(slots)])]);
    };
    watch([() => props.color, windowWidth], setLine);
    watch(() => props.active, (value) => {
      if (value !== currentName.value) {
        setCurrentIndexByName(value);
      }
    });
    watch(() => children.length, () => {
      if (state.inited) {
        setCurrentIndexByName(props.active);
        setLine();
        nextTick(() => {
          scrollIntoView(true);
        });
      }
    });
    watch(() => state.currentIndex, () => {
      scrollIntoView();
      setLine();
      if (stickyFixed && !props.scrollspy) {
        setRootScrollTop(Math.ceil(getElementTop(root.value) - offsetTopPx.value));
      }
    });
    var init = () => {
      setCurrentIndexByName(props.active);
      nextTick(() => {
        state.inited = true;
        if (wrapRef.value) {
          tabHeight = useRect(wrapRef.value).height;
        }
        scrollIntoView(true);
      });
    };
    var onRendered = (name96, title) => emit("rendered", name96, title);
    useExpose({
      resize: setLine,
      scrollTo
    });
    onActivated(setLine);
    onPopupReopen(setLine);
    onMountedOrActivated(init);
    useEventListener("scroll", onScroll, {
      target: scroller
    });
    linkChildren({
      id,
      props,
      setLine,
      onRendered,
      currentName,
      scrollIntoView
    });
    return () => {
      var _slots$navBottom, _slots$navBottom2;
      return createVNode("div", {
        "ref": root,
        "class": bem34([props.type])
      }, [props.sticky ? createVNode(Sticky, {
        "container": root.value,
        "offsetTop": offsetTopPx.value,
        "onScroll": onStickyScroll
      }, {
        default: () => [renderHeader(), (_slots$navBottom = slots["nav-bottom"]) == null ? void 0 : _slots$navBottom.call(slots)]
      }) : [renderHeader(), (_slots$navBottom2 = slots["nav-bottom"]) == null ? void 0 : _slots$navBottom2.call(slots)], createVNode(TabsContent_default, {
        "count": children.length,
        "inited": state.inited,
        "animated": props.animated,
        "duration": props.duration,
        "swipeable": props.swipeable,
        "lazyRender": props.lazyRender,
        "currentIndex": state.currentIndex,
        "onChange": setCurrentIndex
      }, {
        default: () => [slots.default == null ? void 0 : slots.default()]
      })]);
    };
  }
});

// node_modules/vant/es/composables/use-tab-status.js
var TAB_STATUS_KEY = Symbol();
var useTabStatus = () => inject(TAB_STATUS_KEY, null);

// node_modules/vant/es/swipe-item/SwipeItem.js
var [name38, bem35] = createNamespace("swipe-item");
var SwipeItem_default = defineComponent({
  name: name38,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var rendered;
    var state = reactive({
      offset: 0,
      inited: false,
      mounted: false
    });
    var {
      parent,
      index
    } = useParent(SWIPE_KEY);
    if (!parent) {
      if (true) {
        console.error("[Vant] <SwipeItem> must be a child component of <Swipe>.");
      }
      return;
    }
    var style = computed(() => {
      var style2 = {};
      var {
        vertical
      } = parent.props;
      if (parent.size.value) {
        style2[vertical ? "height" : "width"] = parent.size.value + "px";
      }
      if (state.offset) {
        style2.transform = "translate" + (vertical ? "Y" : "X") + "(" + state.offset + "px)";
      }
      return style2;
    });
    var shouldRender = computed(() => {
      var {
        loop,
        lazyRender
      } = parent.props;
      if (!lazyRender || rendered) {
        return true;
      }
      if (!state.mounted) {
        return false;
      }
      var active = parent.activeIndicator.value;
      var maxActive = parent.count.value - 1;
      var prevActive = active === 0 && loop ? maxActive : active - 1;
      var nextActive = active === maxActive && loop ? 0 : active + 1;
      rendered = index.value === active || index.value === prevActive || index.value === nextActive;
      return rendered;
    });
    var setOffset = (offset2) => {
      state.offset = offset2;
    };
    onMounted(() => {
      nextTick(() => {
        state.mounted = true;
      });
    });
    useExpose({
      setOffset
    });
    return () => createVNode("div", {
      "class": bem35(),
      "style": style.value
    }, [shouldRender.value ? slots.default == null ? void 0 : slots.default() : null]);
  }
});

// node_modules/vant/es/swipe-item/index.js
var SwipeItem = withInstall(SwipeItem_default);

// node_modules/vant/es/tab/Tab.js
var [name39, bem36] = createNamespace("tab");
var tabProps = extend({}, routeProps, {
  dot: Boolean,
  name: numericProp,
  badge: numericProp,
  title: String,
  disabled: Boolean,
  titleClass: unknownProp,
  titleStyle: [String, Object],
  showZeroBadge: truthProp
});
var Tab_default = defineComponent({
  name: name39,
  props: tabProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var id = useId();
    var inited = ref(false);
    var {
      parent,
      index
    } = useParent(TABS_KEY);
    if (!parent) {
      if (true) {
        console.error("[Vant] <Tab> must be a child component of <Tabs>.");
      }
      return;
    }
    var getName = () => {
      var _props$name;
      return (_props$name = props.name) != null ? _props$name : index.value;
    };
    var init = () => {
      inited.value = true;
      if (parent.props.lazyRender) {
        nextTick(() => {
          parent.onRendered(getName(), props.title);
        });
      }
    };
    var active = computed(() => {
      var isActive = getName() === parent.currentName.value;
      if (isActive && !inited.value) {
        init();
      }
      return isActive;
    });
    watch(() => props.title, () => {
      parent.setLine();
      parent.scrollIntoView();
    });
    provide(TAB_STATUS_KEY, active);
    return () => {
      var label = parent.id + "-" + index.value;
      var {
        animated,
        swipeable,
        scrollspy,
        lazyRender
      } = parent.props;
      if (!slots.default && !animated) {
        return;
      }
      var show = scrollspy || active.value;
      if (animated || swipeable) {
        return createVNode(SwipeItem, {
          "id": id,
          "role": "tabpanel",
          "class": bem36("panel-wrapper", {
            inactive: !active.value
          }),
          "tabindex": active.value ? 0 : -1,
          "aria-hidden": !active.value,
          "aria-labelledby": label
        }, {
          default: () => [createVNode("div", {
            "class": bem36("panel")
          }, [slots.default == null ? void 0 : slots.default()])]
        });
      }
      var shouldRender = inited.value || scrollspy || !lazyRender;
      var Content = shouldRender ? slots.default == null ? void 0 : slots.default() : null;
      useExpose({
        id
      });
      return withDirectives(createVNode("div", {
        "id": id,
        "role": "tabpanel",
        "class": bem36("panel"),
        "tabindex": show ? 0 : -1,
        "aria-labelledby": label
      }, [Content]), [[vShow, show]]);
    };
  }
});

// node_modules/vant/es/tab/index.js
var Tab = withInstall(Tab_default);

// node_modules/vant/es/tabs/index.js
var Tabs = withInstall(Tabs_default);

// node_modules/vant/es/cascader/Cascader.js
var [name40, bem37, t6] = createNamespace("cascader");
var cascaderProps = {
  title: String,
  options: makeArrayProp(),
  closeable: truthProp,
  swipeable: truthProp,
  closeIcon: makeStringProp("cross"),
  modelValue: numericProp,
  fieldNames: Object,
  placeholder: String,
  activeColor: String
};
var Cascader_default = defineComponent({
  name: name40,
  props: cascaderProps,
  emits: ["close", "change", "finish", "click-tab", "update:modelValue"],
  setup(props, _ref) {
    var {
      slots,
      emit
    } = _ref;
    var tabs = ref([]);
    var activeTab = ref(0);
    var {
      text: textKey,
      value: valueKey,
      children: childrenKey
    } = extend({
      text: "text",
      value: "value",
      children: "children"
    }, props.fieldNames);
    var getSelectedOptionsByValue = (options, value) => {
      for (var option of options) {
        if (option[valueKey] === value) {
          return [option];
        }
        if (option[childrenKey]) {
          var selectedOptions = getSelectedOptionsByValue(option[childrenKey], value);
          if (selectedOptions) {
            return [option, ...selectedOptions];
          }
        }
      }
    };
    var updateTabs = () => {
      var {
        options,
        modelValue
      } = props;
      if (modelValue !== void 0) {
        var selectedOptions = getSelectedOptionsByValue(options, modelValue);
        if (selectedOptions) {
          var optionsCursor = options;
          tabs.value = selectedOptions.map((option) => {
            var tab = {
              options: optionsCursor,
              selected: option
            };
            var next = optionsCursor.find((item) => item[valueKey] === option[valueKey]);
            if (next) {
              optionsCursor = next[childrenKey];
            }
            return tab;
          });
          if (optionsCursor) {
            tabs.value.push({
              options: optionsCursor,
              selected: null
            });
          }
          nextTick(() => {
            activeTab.value = tabs.value.length - 1;
          });
          return;
        }
      }
      tabs.value = [{
        options,
        selected: null
      }];
    };
    var onSelect = (option, tabIndex) => {
      if (option.disabled) {
        return;
      }
      tabs.value[tabIndex].selected = option;
      if (tabs.value.length > tabIndex + 1) {
        tabs.value = tabs.value.slice(0, tabIndex + 1);
      }
      if (option[childrenKey]) {
        var nextTab = {
          options: option[childrenKey],
          selected: null
        };
        if (tabs.value[tabIndex + 1]) {
          tabs.value[tabIndex + 1] = nextTab;
        } else {
          tabs.value.push(nextTab);
        }
        nextTick(() => {
          activeTab.value++;
        });
      }
      var selectedOptions = tabs.value.map((tab) => tab.selected).filter(Boolean);
      emit("update:modelValue", option[valueKey]);
      var params = {
        value: option[valueKey],
        tabIndex,
        selectedOptions
      };
      emit("change", params);
      if (!option[childrenKey]) {
        emit("finish", params);
      }
    };
    var onClose = () => emit("close");
    var onClickTab = (_ref2) => {
      var {
        name: name96,
        title
      } = _ref2;
      return emit("click-tab", name96, title);
    };
    var renderHeader = () => createVNode("div", {
      "class": bem37("header")
    }, [createVNode("h2", {
      "class": bem37("title")
    }, [slots.title ? slots.title() : props.title]), props.closeable ? createVNode(Icon, {
      "name": props.closeIcon,
      "class": [bem37("close-icon"), HAPTICS_FEEDBACK],
      "onClick": onClose
    }, null) : null]);
    var renderOption = (option, selectedOption, tabIndex) => {
      var {
        disabled
      } = option;
      var selected = !!(selectedOption && option[valueKey] === selectedOption[valueKey]);
      var color = option.color || (selected ? props.activeColor : void 0);
      var Text = slots.option ? slots.option({
        option,
        selected
      }) : createVNode("span", null, [option[textKey]]);
      return createVNode("li", {
        "role": "menuitemradio",
        "class": [bem37("option", {
          selected,
          disabled
        }), option.className],
        "style": {
          color
        },
        "tabindex": disabled ? void 0 : selected ? 0 : -1,
        "aria-checked": selected,
        "aria-disabled": disabled || void 0,
        "onClick": () => onSelect(option, tabIndex)
      }, [Text, selected ? createVNode(Icon, {
        "name": "success",
        "class": bem37("selected-icon")
      }, null) : null]);
    };
    var renderOptions = (options, selectedOption, tabIndex) => createVNode("ul", {
      "role": "menu",
      "class": bem37("options")
    }, [options.map((option) => renderOption(option, selectedOption, tabIndex))]);
    var renderTab = (tab, tabIndex) => {
      var _slots$optionsTop, _slots$optionsBottom;
      var {
        options,
        selected
      } = tab;
      var placeholder = props.placeholder || t6("select");
      var title = selected ? selected[textKey] : placeholder;
      return createVNode(Tab, {
        "title": title,
        "titleClass": bem37("tab", {
          unselected: !selected
        })
      }, {
        default: () => [(_slots$optionsTop = slots["options-top"]) == null ? void 0 : _slots$optionsTop.call(slots, {
          tabIndex
        }), renderOptions(options, selected, tabIndex), (_slots$optionsBottom = slots["options-bottom"]) == null ? void 0 : _slots$optionsBottom.call(slots, {
          tabIndex
        })]
      });
    };
    var renderTabs = () => createVNode(Tabs, {
      "active": activeTab.value,
      "onUpdate:active": ($event) => activeTab.value = $event,
      "animated": true,
      "class": bem37("tabs"),
      "color": props.activeColor,
      "swipeThreshold": 0,
      "swipeable": props.swipeable,
      "onClick-tab": onClickTab
    }, {
      default: () => [tabs.value.map(renderTab)]
    });
    updateTabs();
    watch(() => props.options, updateTabs, {
      deep: true
    });
    watch(() => props.modelValue, (value) => {
      if (value !== void 0) {
        var values = tabs.value.map((tab) => {
          var _tab$selected;
          return (_tab$selected = tab.selected) == null ? void 0 : _tab$selected[valueKey];
        });
        if (values.includes(value)) {
          return;
        }
      }
      updateTabs();
    });
    return () => createVNode("div", {
      "class": bem37()
    }, [renderHeader(), renderTabs()]);
  }
});

// node_modules/vant/es/cascader/index.js
var Cascader = withInstall(Cascader_default);

// node_modules/vant/es/cell-group/CellGroup.js
var [name41, bem38] = createNamespace("cell-group");
var cellGroupProps = {
  title: String,
  inset: Boolean,
  border: truthProp
};
var CellGroup_default = defineComponent({
  name: name41,
  inheritAttrs: false,
  props: cellGroupProps,
  setup(props, _ref) {
    var {
      slots,
      attrs
    } = _ref;
    var renderGroup = () => createVNode("div", mergeProps({
      "class": [bem38({
        inset: props.inset
      }), {
        [BORDER_TOP_BOTTOM]: props.border && !props.inset
      }]
    }, attrs), [slots.default == null ? void 0 : slots.default()]);
    var renderTitle = () => createVNode("div", {
      "class": bem38("title", {
        inset: props.inset
      })
    }, [slots.title ? slots.title() : props.title]);
    return () => {
      if (props.title || slots.title) {
        return createVNode(Fragment, null, [renderTitle(), renderGroup()]);
      }
      return renderGroup();
    };
  }
});

// node_modules/vant/es/cell-group/index.js
var CellGroup = withInstall(CellGroup_default);

// node_modules/vant/es/checkbox-group/CheckboxGroup.js
var [name42, bem39] = createNamespace("checkbox-group");
var checkboxGroupProps = {
  max: numericProp,
  disabled: Boolean,
  iconSize: numericProp,
  direction: String,
  modelValue: makeArrayProp(),
  checkedColor: String
};
var CHECKBOX_GROUP_KEY = Symbol(name42);
var CheckboxGroup_default = defineComponent({
  name: name42,
  props: checkboxGroupProps,
  emits: ["change", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var {
      children,
      linkChildren
    } = useChildren(CHECKBOX_GROUP_KEY);
    var updateValue = (value) => emit("update:modelValue", value);
    var toggleAll = function(options) {
      if (options === void 0) {
        options = {};
      }
      if (typeof options === "boolean") {
        options = {
          checked: options
        };
      }
      var {
        checked,
        skipDisabled
      } = options;
      var checkedChildren = children.filter((item) => {
        if (!item.props.bindGroup) {
          return false;
        }
        if (item.props.disabled && skipDisabled) {
          return item.checked.value;
        }
        return checked != null ? checked : !item.checked.value;
      });
      var names = checkedChildren.map((item) => item.name);
      updateValue(names);
    };
    watch(() => props.modelValue, (value) => emit("change", value));
    useExpose({
      toggleAll
    });
    useCustomFieldValue(() => props.modelValue);
    linkChildren({
      props,
      updateValue
    });
    return () => createVNode("div", {
      "class": bem39([props.direction])
    }, [slots.default == null ? void 0 : slots.default()]);
  }
});

// node_modules/vant/es/checkbox/Checkbox.js
var [name43, bem40] = createNamespace("checkbox");
var checkboxProps = extend({}, checkerProps, {
  bindGroup: truthProp
});
var Checkbox_default = defineComponent({
  name: name43,
  props: checkboxProps,
  emits: ["change", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var {
      parent
    } = useParent(CHECKBOX_GROUP_KEY);
    var setParentValue = (checked2) => {
      var {
        name: name96
      } = props;
      var {
        max,
        modelValue
      } = parent.props;
      var value = modelValue.slice();
      if (checked2) {
        var overlimit = max && value.length >= max;
        if (!overlimit && !value.includes(name96)) {
          value.push(name96);
          if (props.bindGroup) {
            parent.updateValue(value);
          }
        }
      } else {
        var index = value.indexOf(name96);
        if (index !== -1) {
          value.splice(index, 1);
          if (props.bindGroup) {
            parent.updateValue(value);
          }
        }
      }
    };
    var checked = computed(() => {
      if (parent && props.bindGroup) {
        return parent.props.modelValue.indexOf(props.name) !== -1;
      }
      return !!props.modelValue;
    });
    var toggle = function(newValue) {
      if (newValue === void 0) {
        newValue = !checked.value;
      }
      if (parent && props.bindGroup) {
        setParentValue(newValue);
      } else {
        emit("update:modelValue", newValue);
      }
    };
    watch(() => props.modelValue, (value) => emit("change", value));
    useExpose({
      toggle,
      props,
      checked
    });
    useCustomFieldValue(() => props.modelValue);
    return () => createVNode(Checker_default, mergeProps({
      "bem": bem40,
      "role": "checkbox",
      "parent": parent,
      "checked": checked.value,
      "onToggle": toggle
    }, props), pick(slots, ["default", "icon"]));
  }
});

// node_modules/vant/es/checkbox/index.js
var Checkbox = withInstall(Checkbox_default);

// node_modules/vant/es/checkbox-group/index.js
var CheckboxGroup = withInstall(CheckboxGroup_default);

// node_modules/vant/es/circle/Circle.js
var [name44, bem41] = createNamespace("circle");
var uid = 0;
var format = (rate) => Math.min(Math.max(+rate, 0), 100);
function getPath(clockwise, viewBoxSize) {
  var sweepFlag = clockwise ? 1 : 0;
  return "M " + viewBoxSize / 2 + " " + viewBoxSize / 2 + " m 0, -500 a 500, 500 0 1, " + sweepFlag + " 0, 1000 a 500, 500 0 1, " + sweepFlag + " 0, -1000";
}
var circleProps = {
  text: String,
  size: numericProp,
  fill: makeStringProp("none"),
  rate: makeNumericProp(100),
  speed: makeNumericProp(0),
  color: [String, Object],
  clockwise: truthProp,
  layerColor: String,
  currentRate: makeNumberProp(0),
  strokeWidth: makeNumericProp(40),
  strokeLinecap: String,
  startPosition: makeStringProp("top")
};
var Circle_default = defineComponent({
  name: name44,
  props: circleProps,
  emits: ["update:currentRate"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var id = "van-circle-" + uid++;
    var viewBoxSize = computed(() => +props.strokeWidth + 1e3);
    var path = computed(() => getPath(props.clockwise, viewBoxSize.value));
    var svgStyle = computed(() => {
      var ROTATE_ANGLE_MAP = {
        top: 0,
        right: 90,
        bottom: 180,
        left: 270
      };
      var angleValue = ROTATE_ANGLE_MAP[props.startPosition];
      if (angleValue) {
        return {
          transform: "rotate(" + angleValue + "deg)"
        };
      }
    });
    watch(() => props.rate, (rate) => {
      var rafId;
      var startTime = Date.now();
      var startRate = props.currentRate;
      var endRate = format(rate);
      var duration = Math.abs((startRate - endRate) * 1e3 / +props.speed);
      var animate = () => {
        var now = Date.now();
        var progress = Math.min((now - startTime) / duration, 1);
        var rate2 = progress * (endRate - startRate) + startRate;
        emit("update:currentRate", format(parseFloat(rate2.toFixed(1))));
        if (endRate > startRate ? rate2 < endRate : rate2 > endRate) {
          rafId = raf(animate);
        }
      };
      if (props.speed) {
        if (rafId) {
          cancelRaf(rafId);
        }
        rafId = raf(animate);
      } else {
        emit("update:currentRate", endRate);
      }
    }, {
      immediate: true
    });
    var renderHover = () => {
      var PERIMETER = 3140;
      var {
        strokeWidth,
        currentRate,
        strokeLinecap
      } = props;
      var offset2 = PERIMETER * currentRate / 100;
      var color = isObject(props.color) ? "url(#" + id + ")" : props.color;
      var style = {
        stroke: color,
        strokeWidth: +strokeWidth + 1 + "px",
        strokeLinecap,
        strokeDasharray: offset2 + "px " + PERIMETER + "px"
      };
      return createVNode("path", {
        "d": path.value,
        "style": style,
        "class": bem41("hover"),
        "stroke": color
      }, null);
    };
    var renderLayer = () => {
      var style = {
        fill: props.fill,
        stroke: props.layerColor,
        strokeWidth: props.strokeWidth + "px"
      };
      return createVNode("path", {
        "class": bem41("layer"),
        "style": style,
        "d": path.value
      }, null);
    };
    var renderGradient = () => {
      var {
        color
      } = props;
      if (!isObject(color)) {
        return;
      }
      var Stops = Object.keys(color).sort((a, b) => parseFloat(a) - parseFloat(b)).map((key, index) => createVNode("stop", {
        "key": index,
        "offset": key,
        "stop-color": color[key]
      }, null));
      return createVNode("defs", null, [createVNode("linearGradient", {
        "id": id,
        "x1": "100%",
        "y1": "0%",
        "x2": "0%",
        "y2": "0%"
      }, [Stops])]);
    };
    var renderText = () => {
      if (slots.default) {
        return slots.default();
      }
      if (props.text) {
        return createVNode("div", {
          "class": bem41("text")
        }, [props.text]);
      }
    };
    return () => createVNode("div", {
      "class": bem41(),
      "style": getSizeStyle(props.size)
    }, [createVNode("svg", {
      "viewBox": "0 0 " + viewBoxSize.value + " " + viewBoxSize.value,
      "style": svgStyle.value
    }, [renderGradient(), renderLayer(), renderHover()]), renderText()]);
  }
});

// node_modules/vant/es/circle/index.js
var Circle = withInstall(Circle_default);

// node_modules/vant/es/row/Row.js
var [name45, bem42] = createNamespace("row");
var ROW_KEY = Symbol(name45);
var rowProps = {
  tag: makeStringProp("div"),
  wrap: truthProp,
  align: String,
  gutter: makeNumericProp(0),
  justify: String
};
var Row_default = defineComponent({
  name: name45,
  props: rowProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var {
      children,
      linkChildren
    } = useChildren(ROW_KEY);
    var groups = computed(() => {
      var groups2 = [[]];
      var totalSpan = 0;
      children.forEach((child, index) => {
        totalSpan += Number(child.span);
        if (totalSpan > 24) {
          groups2.push([index]);
          totalSpan -= 24;
        } else {
          groups2[groups2.length - 1].push(index);
        }
      });
      return groups2;
    });
    var spaces = computed(() => {
      var gutter = Number(props.gutter);
      var spaces2 = [];
      if (!gutter) {
        return spaces2;
      }
      groups.value.forEach((group) => {
        var averagePadding = gutter * (group.length - 1) / group.length;
        group.forEach((item, index) => {
          if (index === 0) {
            spaces2.push({
              right: averagePadding
            });
          } else {
            var left2 = gutter - spaces2[item - 1].right;
            var right2 = averagePadding - left2;
            spaces2.push({
              left: left2,
              right: right2
            });
          }
        });
      });
      return spaces2;
    });
    linkChildren({
      spaces
    });
    return () => {
      var {
        tag,
        wrap,
        align,
        justify
      } = props;
      return createVNode(tag, {
        "class": bem42({
          ["align-" + align]: align,
          ["justify-" + justify]: justify,
          nowrap: !wrap
        })
      }, {
        default: () => [slots.default == null ? void 0 : slots.default()]
      });
    };
  }
});

// node_modules/vant/es/col/Col.js
var [name46, bem43] = createNamespace("col");
var colProps = {
  tag: makeStringProp("div"),
  span: makeNumericProp(0),
  offset: numericProp
};
var Col_default = defineComponent({
  name: name46,
  props: colProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var {
      parent,
      index
    } = useParent(ROW_KEY);
    var style = computed(() => {
      if (!parent) {
        return;
      }
      var {
        spaces
      } = parent;
      if (spaces && spaces.value && spaces.value[index.value]) {
        var {
          left: left2,
          right: right2
        } = spaces.value[index.value];
        return {
          paddingLeft: left2 ? left2 + "px" : null,
          paddingRight: right2 ? right2 + "px" : null
        };
      }
    });
    return () => {
      var {
        tag,
        span,
        offset: offset2
      } = props;
      return createVNode(tag, {
        "style": style.value,
        "class": bem43({
          [span]: span,
          ["offset-" + offset2]: offset2
        })
      }, {
        default: () => [slots.default == null ? void 0 : slots.default()]
      });
    };
  }
});

// node_modules/vant/es/col/index.js
var Col = withInstall(Col_default);

// node_modules/vant/es/collapse/Collapse.js
var [name47, bem44] = createNamespace("collapse");
var COLLAPSE_KEY = Symbol(name47);
var collapseProps = {
  border: truthProp,
  accordion: Boolean,
  modelValue: {
    type: [String, Number, Array],
    default: ""
  }
};
function validateModelValue(modelValue, accordion) {
  if (accordion && Array.isArray(modelValue)) {
    console.error('[Vant] Collapse: "v-model" should not be Array in accordion mode');
    return false;
  }
  if (!accordion && !Array.isArray(modelValue)) {
    console.error('[Vant] Collapse: "v-model" should be Array in non-accordion mode');
    return false;
  }
  return true;
}
var Collapse_default = defineComponent({
  name: name47,
  props: collapseProps,
  emits: ["change", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var {
      linkChildren
    } = useChildren(COLLAPSE_KEY);
    var updateName = (name96) => {
      emit("change", name96);
      emit("update:modelValue", name96);
    };
    var toggle = (name96, expanded) => {
      var {
        accordion,
        modelValue
      } = props;
      if (accordion) {
        updateName(name96 === modelValue ? "" : name96);
      } else if (expanded) {
        updateName(modelValue.concat(name96));
      } else {
        updateName(modelValue.filter((activeName) => activeName !== name96));
      }
    };
    var isExpanded = (name96) => {
      var {
        accordion,
        modelValue
      } = props;
      if (!validateModelValue(modelValue, accordion)) {
        return false;
      }
      return accordion ? modelValue === name96 : modelValue.includes(name96);
    };
    linkChildren({
      toggle,
      isExpanded
    });
    return () => createVNode("div", {
      "class": [bem44(), {
        [BORDER_TOP_BOTTOM]: props.border
      }]
    }, [slots.default == null ? void 0 : slots.default()]);
  }
});

// node_modules/vant/es/collapse/index.js
var Collapse = withInstall(Collapse_default);

// node_modules/vant/es/collapse-item/CollapseItem.js
var [name48, bem45] = createNamespace("collapse-item");
var CELL_SLOTS = ["icon", "title", "value", "label", "right-icon"];
var collapseItemProps = extend({}, cellSharedProps, {
  name: numericProp,
  isLink: truthProp,
  disabled: Boolean,
  readonly: Boolean
});
var CollapseItem_default = defineComponent({
  name: name48,
  props: collapseItemProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var wrapperRef = ref();
    var contentRef = ref();
    var {
      parent,
      index
    } = useParent(COLLAPSE_KEY);
    if (!parent) {
      if (true) {
        console.error("[Vant] <CollapseItem> must be a child component of <Collapse>.");
      }
      return;
    }
    var name96 = computed(() => {
      var _props$name;
      return (_props$name = props.name) != null ? _props$name : index.value;
    });
    var expanded = computed(() => parent.isExpanded(name96.value));
    var show = ref(expanded.value);
    var lazyRender = useLazyRender(show);
    var onTransitionEnd = () => {
      if (!expanded.value) {
        show.value = false;
      } else if (wrapperRef.value) {
        wrapperRef.value.style.height = "";
      }
    };
    watch(expanded, (value, oldValue) => {
      if (oldValue === null) {
        return;
      }
      if (value) {
        show.value = true;
      }
      var tick = value ? nextTick : raf;
      tick(() => {
        if (!contentRef.value || !wrapperRef.value) {
          return;
        }
        var {
          offsetHeight
        } = contentRef.value;
        if (offsetHeight) {
          var contentHeight = offsetHeight + "px";
          wrapperRef.value.style.height = value ? "0" : contentHeight;
          doubleRaf(() => {
            if (wrapperRef.value) {
              wrapperRef.value.style.height = value ? contentHeight : "0";
            }
          });
        } else {
          onTransitionEnd();
        }
      });
    });
    var toggle = function(newValue) {
      if (newValue === void 0) {
        newValue = !expanded.value;
      }
      parent.toggle(name96.value, newValue);
    };
    var onClickTitle = () => {
      if (!props.disabled && !props.readonly) {
        toggle();
      }
    };
    var renderTitle = () => {
      var {
        border,
        disabled,
        readonly
      } = props;
      var attrs = pick(props, Object.keys(cellSharedProps));
      if (readonly) {
        attrs.isLink = false;
      }
      if (disabled || readonly) {
        attrs.clickable = false;
      }
      return createVNode(Cell, mergeProps({
        "role": "button",
        "class": bem45("title", {
          disabled,
          expanded: expanded.value,
          borderless: !border
        }),
        "aria-expanded": String(expanded.value),
        "onClick": onClickTitle
      }, attrs), pick(slots, CELL_SLOTS));
    };
    var renderContent = lazyRender(() => withDirectives(createVNode("div", {
      "ref": wrapperRef,
      "class": bem45("wrapper"),
      "onTransitionend": onTransitionEnd
    }, [createVNode("div", {
      "ref": contentRef,
      "class": bem45("content")
    }, [slots.default == null ? void 0 : slots.default()])]), [[vShow, show.value]]));
    useExpose({
      toggle
    });
    return () => createVNode("div", {
      "class": [bem45({
        border: index.value && props.border
      })]
    }, [renderTitle(), renderContent()]);
  }
});

// node_modules/vant/es/collapse-item/index.js
var CollapseItem = withInstall(CollapseItem_default);

// node_modules/vant/es/config-provider/index.js
var ConfigProvider = withInstall(ConfigProvider_default);

// node_modules/vant/es/contact-card/ContactCard.js
var [name49, bem46, t7] = createNamespace("contact-card");
var contactCardProps = {
  tel: String,
  name: String,
  type: makeStringProp("add"),
  addText: String,
  editable: truthProp
};
var ContactCard_default = defineComponent({
  name: name49,
  props: contactCardProps,
  emits: ["click"],
  setup(props, _ref) {
    var {
      emit
    } = _ref;
    var onClick = (event) => {
      if (props.editable) {
        emit("click", event);
      }
    };
    var renderContent = () => {
      if (props.type === "add") {
        return props.addText || t7("addText");
      }
      return [createVNode("div", null, [t7("name") + "\uFF1A" + props.name]), createVNode("div", null, [t7("tel") + "\uFF1A" + props.tel])];
    };
    return () => createVNode(Cell, {
      "center": true,
      "icon": props.type === "edit" ? "contact" : "add-square",
      "class": bem46([props.type]),
      "border": false,
      "isLink": props.editable,
      "valueClass": bem46("value"),
      "onClick": onClick
    }, {
      value: renderContent
    });
  }
});

// node_modules/vant/es/contact-card/index.js
var ContactCard = withInstall(ContactCard_default);

// node_modules/vant/es/contact-edit/ContactEdit.js
var [name50, bem47, t8] = createNamespace("contact-edit");
var DEFAULT_CONTACT = {
  tel: "",
  name: ""
};
var contactEditProps = {
  isEdit: Boolean,
  isSaving: Boolean,
  isDeleting: Boolean,
  showSetDefault: Boolean,
  setDefaultLabel: String,
  contactInfo: {
    type: Object,
    default: () => extend({}, DEFAULT_CONTACT)
  },
  telValidator: {
    type: Function,
    default: isMobile
  }
};
var ContactEdit_default = defineComponent({
  name: name50,
  props: contactEditProps,
  emits: ["save", "delete", "change-default"],
  setup(props, _ref) {
    var {
      emit
    } = _ref;
    var contact = reactive(extend({}, DEFAULT_CONTACT, props.contactInfo));
    var onSave = () => {
      if (!props.isSaving) {
        emit("save", contact);
      }
    };
    var onDelete = () => emit("delete", contact);
    var renderButtons = () => createVNode("div", {
      "class": bem47("buttons")
    }, [createVNode(Button, {
      "block": true,
      "round": true,
      "type": "danger",
      "text": t8("save"),
      "class": bem47("button"),
      "loading": props.isSaving,
      "nativeType": "submit"
    }, null), props.isEdit && createVNode(Button, {
      "block": true,
      "round": true,
      "text": t8("delete"),
      "class": bem47("button"),
      "loading": props.isDeleting,
      "onClick": onDelete
    }, null)]);
    var renderSwitch = () => createVNode(Switch, {
      "modelValue": contact.isDefault,
      "onUpdate:modelValue": ($event) => contact.isDefault = $event,
      "size": 24,
      "onChange": (checked) => emit("change-default", checked)
    }, null);
    var renderSetDefault = () => {
      if (props.showSetDefault) {
        return createVNode(Cell, {
          "title": props.setDefaultLabel,
          "class": bem47("switch-cell"),
          "border": false
        }, {
          "right-icon": renderSwitch
        });
      }
    };
    watch(() => props.contactInfo, (value) => extend(contact, DEFAULT_CONTACT, value));
    return () => createVNode(Form, {
      "class": bem47(),
      "onSubmit": onSave
    }, {
      default: () => [createVNode("div", {
        "class": bem47("fields")
      }, [createVNode(Field, {
        "modelValue": contact.name,
        "onUpdate:modelValue": ($event) => contact.name = $event,
        "clearable": true,
        "label": t8("name"),
        "rules": [{
          required: true,
          message: t8("nameEmpty")
        }],
        "maxlength": "30",
        "placeholder": t8("name")
      }, null), createVNode(Field, {
        "modelValue": contact.tel,
        "onUpdate:modelValue": ($event) => contact.tel = $event,
        "clearable": true,
        "type": "tel",
        "label": t8("tel"),
        "rules": [{
          validator: props.telValidator,
          message: t8("telInvalid")
        }],
        "placeholder": t8("tel")
      }, null)]), renderSetDefault(), renderButtons()]
    });
  }
});

// node_modules/vant/es/contact-edit/index.js
var ContactEdit = withInstall(ContactEdit_default);

// node_modules/vant/es/contact-list/ContactList.js
var [name51, bem48, t9] = createNamespace("contact-list");
var contactListProps = {
  list: Array,
  addText: String,
  modelValue: unknownProp,
  defaultTagText: String
};
var ContactList_default = defineComponent({
  name: name51,
  props: contactListProps,
  emits: ["add", "edit", "select", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit
    } = _ref;
    var renderItem = (item, index) => {
      var onClick = () => {
        emit("update:modelValue", item.id);
        emit("select", item, index);
      };
      var renderRightIcon = () => createVNode(Radio, {
        "class": bem48("radio"),
        "name": item.id,
        "iconSize": 16
      }, null);
      var renderEditIcon = () => createVNode(Icon, {
        "name": "edit",
        "class": bem48("edit"),
        "onClick": (event) => {
          event.stopPropagation();
          emit("edit", item, index);
        }
      }, null);
      var renderContent = () => {
        var nodes = [item.name + "\uFF0C" + item.tel];
        if (item.isDefault && props.defaultTagText) {
          nodes.push(createVNode(Tag, {
            "type": "danger",
            "round": true,
            "class": bem48("item-tag")
          }, {
            default: () => [props.defaultTagText]
          }));
        }
        return nodes;
      };
      return createVNode(Cell, {
        "key": item.id,
        "isLink": true,
        "center": true,
        "class": bem48("item"),
        "valueClass": bem48("item-value"),
        "onClick": onClick
      }, {
        icon: renderEditIcon,
        value: renderContent,
        "right-icon": renderRightIcon
      });
    };
    return () => createVNode("div", {
      "class": bem48()
    }, [createVNode(RadioGroup, {
      "modelValue": props.modelValue,
      "class": bem48("group")
    }, {
      default: () => [props.list && props.list.map(renderItem)]
    }), createVNode("div", {
      "class": [bem48("bottom"), "van-safe-area-bottom"]
    }, [createVNode(Button, {
      "round": true,
      "block": true,
      "type": "danger",
      "class": bem48("add"),
      "text": props.addText || t9("addText"),
      "onClick": () => emit("add")
    }, null)])]);
  }
});

// node_modules/vant/es/contact-list/index.js
var ContactList = withInstall(ContactList_default);

// node_modules/vant/es/count-down/utils.js
function parseFormat(format3, currentTime) {
  var {
    days
  } = currentTime;
  var {
    hours,
    minutes,
    seconds,
    milliseconds
  } = currentTime;
  if (format3.includes("DD")) {
    format3 = format3.replace("DD", padZero(days));
  } else {
    hours += days * 24;
  }
  if (format3.includes("HH")) {
    format3 = format3.replace("HH", padZero(hours));
  } else {
    minutes += hours * 60;
  }
  if (format3.includes("mm")) {
    format3 = format3.replace("mm", padZero(minutes));
  } else {
    seconds += minutes * 60;
  }
  if (format3.includes("ss")) {
    format3 = format3.replace("ss", padZero(seconds));
  } else {
    milliseconds += seconds * 1e3;
  }
  if (format3.includes("S")) {
    var ms = padZero(milliseconds, 3);
    if (format3.includes("SSS")) {
      format3 = format3.replace("SSS", ms);
    } else if (format3.includes("SS")) {
      format3 = format3.replace("SS", ms.slice(0, 2));
    } else {
      format3 = format3.replace("S", ms.charAt(0));
    }
  }
  return format3;
}

// node_modules/vant/es/count-down/CountDown.js
var [name52, bem49] = createNamespace("count-down");
var countDownProps = {
  time: makeNumericProp(0),
  format: makeStringProp("HH:mm:ss"),
  autoStart: truthProp,
  millisecond: Boolean
};
var CountDown_default = defineComponent({
  name: name52,
  props: countDownProps,
  emits: ["change", "finish"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var {
      start: start2,
      pause,
      reset,
      current: current2
    } = useCountDown({
      time: +props.time,
      millisecond: props.millisecond,
      onChange: (current3) => emit("change", current3),
      onFinish: () => emit("finish")
    });
    var timeText = computed(() => parseFormat(props.format, current2.value));
    var resetTime = () => {
      reset(+props.time);
      if (props.autoStart) {
        start2();
      }
    };
    watch(() => props.time, resetTime, {
      immediate: true
    });
    useExpose({
      start: start2,
      pause,
      reset: resetTime
    });
    return () => createVNode("div", {
      "role": "timer",
      "class": bem49()
    }, [slots.default ? slots.default(current2.value) : timeText.value]);
  }
});

// node_modules/vant/es/count-down/index.js
var CountDown = withInstall(CountDown_default);

// node_modules/vant/es/coupon/utils.js
function getDate(timeStamp) {
  var date = new Date(timeStamp * 1e3);
  return date.getFullYear() + "." + padZero(date.getMonth() + 1) + "." + padZero(date.getDate());
}
var formatDiscount = (discount) => (discount / 10).toFixed(discount % 10 === 0 ? 0 : 1);
var formatAmount = (amount) => (amount / 100).toFixed(amount % 100 === 0 ? 0 : amount % 10 === 0 ? 1 : 2);

// node_modules/vant/es/coupon/Coupon.js
var [name53, bem50, t10] = createNamespace("coupon");
var Coupon_default = defineComponent({
  name: name53,
  props: {
    chosen: Boolean,
    coupon: makeRequiredProp(Object),
    disabled: Boolean,
    currency: makeStringProp("\xA5")
  },
  setup(props) {
    var validPeriod = computed(() => {
      var {
        startAt,
        endAt
      } = props.coupon;
      return getDate(startAt) + " - " + getDate(endAt);
    });
    var faceAmount = computed(() => {
      var {
        coupon,
        currency
      } = props;
      if (coupon.valueDesc) {
        return [coupon.valueDesc, createVNode("span", null, [coupon.unitDesc || ""])];
      }
      if (coupon.denominations) {
        var denominations = formatAmount(coupon.denominations);
        return [createVNode("span", null, [currency]), " " + denominations];
      }
      if (coupon.discount) {
        return t10("discount", formatDiscount(coupon.discount));
      }
      return "";
    });
    var conditionMessage = computed(() => {
      var condition = formatAmount(props.coupon.originCondition || 0);
      return condition === "0" ? t10("unlimited") : t10("condition", condition);
    });
    return () => {
      var {
        chosen,
        coupon,
        disabled
      } = props;
      var description = disabled && coupon.reason || coupon.description;
      return createVNode("div", {
        "class": bem50({
          disabled
        })
      }, [createVNode("div", {
        "class": bem50("content")
      }, [createVNode("div", {
        "class": bem50("head")
      }, [createVNode("h2", {
        "class": bem50("amount")
      }, [faceAmount.value]), createVNode("p", {
        "class": bem50("condition")
      }, [coupon.condition || conditionMessage.value])]), createVNode("div", {
        "class": bem50("body")
      }, [createVNode("p", {
        "class": bem50("name")
      }, [coupon.name]), createVNode("p", {
        "class": bem50("valid")
      }, [validPeriod.value]), !disabled && createVNode(Checkbox, {
        "class": bem50("corner"),
        "modelValue": chosen
      }, null)])]), description && createVNode("p", {
        "class": bem50("description")
      }, [description])]);
    };
  }
});

// node_modules/vant/es/coupon/index.js
var Coupon = withInstall(Coupon_default);

// node_modules/vant/es/coupon-cell/CouponCell.js
var [name54, bem51, t11] = createNamespace("coupon-cell");
var couponCellProps = {
  title: String,
  border: truthProp,
  editable: truthProp,
  coupons: makeArrayProp(),
  currency: makeStringProp("\xA5"),
  chosenCoupon: makeNumericProp(-1)
};
function formatValue(_ref) {
  var {
    coupons,
    chosenCoupon,
    currency
  } = _ref;
  var coupon = coupons[+chosenCoupon];
  if (coupon) {
    var value = 0;
    if (isDef(coupon.value)) {
      ({
        value
      } = coupon);
    } else if (isDef(coupon.denominations)) {
      value = coupon.denominations;
    }
    return "-" + currency + " " + (value / 100).toFixed(2);
  }
  return coupons.length === 0 ? t11("noCoupon") : t11("count", coupons.length);
}
var CouponCell_default = defineComponent({
  name: name54,
  props: couponCellProps,
  setup(props) {
    return () => {
      var selected = props.coupons[+props.chosenCoupon];
      return createVNode(Cell, {
        "class": bem51(),
        "value": formatValue(props),
        "title": props.title || t11("title"),
        "border": props.border,
        "isLink": props.editable,
        "valueClass": bem51("value", {
          selected
        })
      }, null);
    };
  }
});

// node_modules/vant/es/coupon-cell/index.js
var CouponCell = withInstall(CouponCell_default);

// node_modules/vant/es/coupon-list/CouponList.js
var [name55, bem52, t12] = createNamespace("coupon-list");
var EMPTY_IMAGE = "https://img.yzcdn.cn/vant/coupon-empty.png";
var couponListProps = {
  code: makeStringProp(""),
  coupons: makeArrayProp(),
  currency: makeStringProp("\xA5"),
  showCount: truthProp,
  emptyImage: makeStringProp(EMPTY_IMAGE),
  chosenCoupon: makeNumberProp(-1),
  enabledTitle: String,
  disabledTitle: String,
  disabledCoupons: makeArrayProp(),
  showExchangeBar: truthProp,
  showCloseButton: truthProp,
  closeButtonText: String,
  inputPlaceholder: String,
  exchangeMinLength: makeNumberProp(1),
  exchangeButtonText: String,
  displayedCouponIndex: makeNumberProp(-1),
  exchangeButtonLoading: Boolean,
  exchangeButtonDisabled: Boolean
};
var CouponList_default = defineComponent({
  name: name55,
  props: couponListProps,
  emits: ["change", "exchange", "update:code"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var [couponRefs, setCouponRefs] = useRefs();
    var root = ref();
    var barRef = ref();
    var activeTab = ref(0);
    var listHeight = ref(0);
    var currentCode = ref(props.code);
    var buttonDisabled = computed(() => !props.exchangeButtonLoading && (props.exchangeButtonDisabled || !currentCode.value || currentCode.value.length < props.exchangeMinLength));
    var updateListHeight = () => {
      var TABS_HEIGHT = 44;
      var rootHeight = useRect(root).height;
      var headerHeight = useRect(barRef).height + TABS_HEIGHT;
      listHeight.value = (rootHeight > headerHeight ? rootHeight : windowHeight.value) - headerHeight;
    };
    var onExchange = () => {
      emit("exchange", currentCode.value);
      if (!props.code) {
        currentCode.value = "";
      }
    };
    var scrollToCoupon = (index) => {
      nextTick(() => {
        var _couponRefs$value$ind;
        return (_couponRefs$value$ind = couponRefs.value[index]) == null ? void 0 : _couponRefs$value$ind.scrollIntoView();
      });
    };
    var renderEmpty = () => createVNode("div", {
      "class": bem52("empty")
    }, [createVNode("img", {
      "src": props.emptyImage
    }, null), createVNode("p", null, [t12("noCoupon")])]);
    var renderExchangeBar = () => {
      if (props.showExchangeBar) {
        return createVNode("div", {
          "ref": barRef,
          "class": bem52("exchange-bar")
        }, [createVNode(Field, {
          "modelValue": currentCode.value,
          "onUpdate:modelValue": ($event) => currentCode.value = $event,
          "clearable": true,
          "border": false,
          "class": bem52("field"),
          "placeholder": props.inputPlaceholder || t12("placeholder"),
          "maxlength": "20"
        }, null), createVNode(Button, {
          "plain": true,
          "type": "danger",
          "class": bem52("exchange"),
          "text": props.exchangeButtonText || t12("exchange"),
          "loading": props.exchangeButtonLoading,
          "disabled": buttonDisabled.value,
          "onClick": onExchange
        }, null)]);
      }
    };
    var renderCouponTab = () => {
      var _slots$listFooter;
      var {
        coupons
      } = props;
      var count = props.showCount ? " (" + coupons.length + ")" : "";
      var title = (props.enabledTitle || t12("enable")) + count;
      return createVNode(Tab, {
        "title": title
      }, {
        default: () => [createVNode("div", {
          "class": bem52("list", {
            "with-bottom": props.showCloseButton
          }),
          "style": {
            height: listHeight.value + "px"
          }
        }, [coupons.map((coupon, index) => createVNode(Coupon, {
          "key": coupon.id,
          "ref": setCouponRefs(index),
          "coupon": coupon,
          "chosen": index === props.chosenCoupon,
          "currency": props.currency,
          "onClick": () => emit("change", index)
        }, null)), !coupons.length && renderEmpty(), (_slots$listFooter = slots["list-footer"]) == null ? void 0 : _slots$listFooter.call(slots)])]
      });
    };
    var renderDisabledTab = () => {
      var _slots$disabledList;
      var {
        disabledCoupons
      } = props;
      var count = props.showCount ? " (" + disabledCoupons.length + ")" : "";
      var title = (props.disabledTitle || t12("disabled")) + count;
      return createVNode(Tab, {
        "title": title
      }, {
        default: () => [createVNode("div", {
          "class": bem52("list", {
            "with-bottom": props.showCloseButton
          }),
          "style": {
            height: listHeight.value + "px"
          }
        }, [disabledCoupons.map((coupon) => createVNode(Coupon, {
          "disabled": true,
          "key": coupon.id,
          "coupon": coupon,
          "currency": props.currency
        }, null)), !disabledCoupons.length && renderEmpty(), (_slots$disabledList = slots["disabled-list-footer"]) == null ? void 0 : _slots$disabledList.call(slots)])]
      });
    };
    watch(() => props.code, (value) => {
      currentCode.value = value;
    });
    watch(windowHeight, updateListHeight);
    watch(currentCode, (value) => emit("update:code", value));
    watch(() => props.displayedCouponIndex, scrollToCoupon);
    onMounted(() => {
      updateListHeight();
      scrollToCoupon(props.displayedCouponIndex);
    });
    return () => createVNode("div", {
      "ref": root,
      "class": bem52()
    }, [renderExchangeBar(), createVNode(Tabs, {
      "active": activeTab.value,
      "onUpdate:active": ($event) => activeTab.value = $event,
      "class": bem52("tab")
    }, {
      default: () => [renderCouponTab(), renderDisabledTab()]
    }), createVNode("div", {
      "class": bem52("bottom")
    }, [withDirectives(createVNode(Button, {
      "round": true,
      "block": true,
      "type": "danger",
      "class": bem52("close"),
      "text": props.closeButtonText || t12("close"),
      "onClick": () => emit("change", -1)
    }, null), [[vShow, props.showCloseButton]])])]);
  }
});

// node_modules/vant/es/coupon-list/index.js
var CouponList = withInstall(CouponList_default);

// node_modules/vant/es/datetime-picker/TimePicker.js
var [name56] = createNamespace("time-picker");
var TimePicker_default = defineComponent({
  name: name56,
  props: extend({}, sharedProps, {
    minHour: makeNumericProp(0),
    maxHour: makeNumericProp(23),
    minMinute: makeNumericProp(0),
    maxMinute: makeNumericProp(59),
    modelValue: String
  }),
  emits: ["confirm", "cancel", "change", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var formatValue2 = (value) => {
      var {
        minHour,
        maxHour,
        maxMinute,
        minMinute
      } = props;
      if (!value) {
        value = padZero(minHour) + ":" + padZero(minMinute);
      }
      var [hour, minute] = value.split(":");
      hour = padZero(clamp(+hour, +minHour, +maxHour));
      minute = padZero(clamp(+minute, +minMinute, +maxMinute));
      return hour + ":" + minute;
    };
    var picker = ref();
    var currentDate = ref(formatValue2(props.modelValue));
    var ranges = computed(() => [{
      type: "hour",
      range: [+props.minHour, +props.maxHour]
    }, {
      type: "minute",
      range: [+props.minMinute, +props.maxMinute]
    }]);
    var originColumns = computed(() => ranges.value.map((_ref2) => {
      var {
        type,
        range: rangeArr
      } = _ref2;
      var values = times(rangeArr[1] - rangeArr[0] + 1, (index) => padZero(rangeArr[0] + index));
      if (props.filter) {
        values = props.filter(type, values);
      }
      return {
        type,
        values
      };
    }));
    var columns = computed(() => originColumns.value.map((column) => ({
      values: column.values.map((value) => props.formatter(column.type, value))
    })));
    var updateColumnValue = () => {
      var pair = currentDate.value.split(":");
      var values = [props.formatter("hour", pair[0]), props.formatter("minute", pair[1])];
      nextTick(() => {
        var _picker$value;
        (_picker$value = picker.value) == null ? void 0 : _picker$value.setValues(values);
      });
    };
    var updateInnerValue = () => {
      var [hourIndex, minuteIndex] = picker.value.getIndexes();
      var [hourColumn, minuteColumn] = originColumns.value;
      var hour = hourColumn.values[hourIndex] || hourColumn.values[0];
      var minute = minuteColumn.values[minuteIndex] || minuteColumn.values[0];
      currentDate.value = formatValue2(hour + ":" + minute);
      updateColumnValue();
    };
    var onConfirm = () => emit("confirm", currentDate.value);
    var onCancel = () => emit("cancel");
    var onChange = () => {
      updateInnerValue();
      nextTick(() => {
        nextTick(() => emit("change", currentDate.value));
      });
    };
    onMounted(() => {
      updateColumnValue();
      nextTick(updateInnerValue);
    });
    watch(columns, updateColumnValue);
    watch(() => [props.filter, props.maxHour, props.minMinute, props.maxMinute], updateInnerValue);
    watch(() => props.minHour, () => {
      nextTick(updateInnerValue);
    });
    watch(currentDate, (value) => emit("update:modelValue", value));
    watch(() => props.modelValue, (value) => {
      value = formatValue2(value);
      if (value !== currentDate.value) {
        currentDate.value = value;
        updateColumnValue();
      }
    });
    useExpose({
      getPicker: () => picker.value && proxyPickerMethods(picker.value, updateInnerValue)
    });
    return () => createVNode(Picker, mergeProps({
      "ref": picker,
      "columns": columns.value,
      "onChange": onChange,
      "onCancel": onCancel,
      "onConfirm": onConfirm
    }, pick(props, pickerInheritKeys)), slots);
  }
});

// node_modules/vant/es/datetime-picker/DatePicker.js
var currentYear = new Date().getFullYear();
var [name57] = createNamespace("date-picker");
var DatePicker_default = defineComponent({
  name: name57,
  props: extend({}, sharedProps, {
    type: makeStringProp("datetime"),
    modelValue: Date,
    minDate: {
      type: Date,
      default: () => new Date(currentYear - 10, 0, 1),
      validator: isDate
    },
    maxDate: {
      type: Date,
      default: () => new Date(currentYear + 10, 11, 31),
      validator: isDate
    }
  }),
  emits: ["confirm", "cancel", "change", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var formatValue2 = (value) => {
      if (isDate(value)) {
        var timestamp = clamp(value.getTime(), props.minDate.getTime(), props.maxDate.getTime());
        return new Date(timestamp);
      }
      return void 0;
    };
    var picker = ref();
    var currentDate = ref(formatValue2(props.modelValue));
    var getBoundary = (type, value) => {
      var boundary = props[type + "Date"];
      var year = boundary.getFullYear();
      var month = 1;
      var date = 1;
      var hour = 0;
      var minute = 0;
      if (type === "max") {
        month = 12;
        date = getMonthEndDay(value.getFullYear(), value.getMonth() + 1);
        hour = 23;
        minute = 59;
      }
      if (value.getFullYear() === year) {
        month = boundary.getMonth() + 1;
        if (value.getMonth() + 1 === month) {
          date = boundary.getDate();
          if (value.getDate() === date) {
            hour = boundary.getHours();
            if (value.getHours() === hour) {
              minute = boundary.getMinutes();
            }
          }
        }
      }
      return {
        [type + "Year"]: year,
        [type + "Month"]: month,
        [type + "Date"]: date,
        [type + "Hour"]: hour,
        [type + "Minute"]: minute
      };
    };
    var ranges = computed(() => {
      var {
        maxYear,
        maxDate,
        maxMonth,
        maxHour,
        maxMinute
      } = getBoundary("max", currentDate.value || props.minDate);
      var {
        minYear,
        minDate,
        minMonth,
        minHour,
        minMinute
      } = getBoundary("min", currentDate.value || props.minDate);
      var result = [{
        type: "year",
        range: [minYear, maxYear]
      }, {
        type: "month",
        range: [minMonth, maxMonth]
      }, {
        type: "day",
        range: [minDate, maxDate]
      }, {
        type: "hour",
        range: [minHour, maxHour]
      }, {
        type: "minute",
        range: [minMinute, maxMinute]
      }];
      switch (props.type) {
        case "date":
          result = result.slice(0, 3);
          break;
        case "year-month":
          result = result.slice(0, 2);
          break;
        case "month-day":
          result = result.slice(1, 3);
          break;
        case "datehour":
          result = result.slice(0, 4);
          break;
      }
      if (props.columnsOrder) {
        var columnsOrder = props.columnsOrder.concat(result.map((column) => column.type));
        result.sort((a, b) => columnsOrder.indexOf(a.type) - columnsOrder.indexOf(b.type));
      }
      return result;
    });
    var originColumns = computed(() => ranges.value.map((_ref2) => {
      var {
        type,
        range: rangeArr
      } = _ref2;
      var values = times(rangeArr[1] - rangeArr[0] + 1, (index) => padZero(rangeArr[0] + index));
      if (props.filter) {
        values = props.filter(type, values);
      }
      return {
        type,
        values
      };
    }));
    var columns = computed(() => originColumns.value.map((column) => ({
      values: column.values.map((value) => props.formatter(column.type, value))
    })));
    var updateColumnValue = () => {
      var value = currentDate.value || props.minDate;
      var {
        formatter
      } = props;
      var values = originColumns.value.map((column) => {
        switch (column.type) {
          case "year":
            return formatter("year", "" + value.getFullYear());
          case "month":
            return formatter("month", padZero(value.getMonth() + 1));
          case "day":
            return formatter("day", padZero(value.getDate()));
          case "hour":
            return formatter("hour", padZero(value.getHours()));
          case "minute":
            return formatter("minute", padZero(value.getMinutes()));
          default:
            return "";
        }
      });
      nextTick(() => {
        var _picker$value;
        (_picker$value = picker.value) == null ? void 0 : _picker$value.setValues(values);
      });
    };
    var updateInnerValue = () => {
      var {
        type
      } = props;
      var indexes = picker.value.getIndexes();
      var getValue = (type2) => {
        var index = 0;
        originColumns.value.forEach((column, columnIndex) => {
          if (type2 === column.type) {
            index = columnIndex;
          }
        });
        var {
          values
        } = originColumns.value[index];
        return getTrueValue(values[indexes[index]]);
      };
      var year;
      var month;
      var day;
      if (type === "month-day") {
        year = (currentDate.value || props.minDate).getFullYear();
        month = getValue("month");
        day = getValue("day");
      } else {
        year = getValue("year");
        month = getValue("month");
        day = type === "year-month" ? 1 : getValue("day");
      }
      var maxDay = getMonthEndDay(year, month);
      day = day > maxDay ? maxDay : day;
      var hour = 0;
      var minute = 0;
      if (type === "datehour") {
        hour = getValue("hour");
      }
      if (type === "datetime") {
        hour = getValue("hour");
        minute = getValue("minute");
      }
      var value = new Date(year, month - 1, day, hour, minute);
      currentDate.value = formatValue2(value);
    };
    var onConfirm = () => {
      emit("update:modelValue", currentDate.value);
      emit("confirm", currentDate.value);
    };
    var onCancel = () => emit("cancel");
    var onChange = () => {
      updateInnerValue();
      nextTick(() => {
        nextTick(() => emit("change", currentDate.value));
      });
    };
    onMounted(() => {
      updateColumnValue();
      nextTick(updateInnerValue);
    });
    watch(columns, updateColumnValue);
    watch(currentDate, (value, oldValue) => emit("update:modelValue", oldValue ? value : null));
    watch(() => [props.filter, props.maxDate], updateInnerValue);
    watch(() => props.minDate, () => {
      nextTick(updateInnerValue);
    });
    watch(() => props.modelValue, (value) => {
      var _currentDate$value;
      value = formatValue2(value);
      if (value && value.valueOf() !== ((_currentDate$value = currentDate.value) == null ? void 0 : _currentDate$value.valueOf())) {
        currentDate.value = value;
      }
    });
    useExpose({
      getPicker: () => picker.value && proxyPickerMethods(picker.value, updateInnerValue)
    });
    return () => createVNode(Picker, mergeProps({
      "ref": picker,
      "columns": columns.value,
      "onChange": onChange,
      "onCancel": onCancel,
      "onConfirm": onConfirm
    }, pick(props, pickerInheritKeys)), slots);
  }
});

// node_modules/vant/es/datetime-picker/DatetimePicker.js
var [name58, bem53] = createNamespace("datetime-picker");
var timePickerPropKeys = Object.keys(TimePicker_default.props);
var datePickerPropKeys = Object.keys(DatePicker_default.props);
var datetimePickerProps = extend({}, TimePicker_default.props, DatePicker_default.props, {
  modelValue: [String, Date]
});
var DatetimePicker_default = defineComponent({
  name: name58,
  props: datetimePickerProps,
  setup(props, _ref) {
    var {
      attrs,
      slots
    } = _ref;
    var root = ref();
    useExpose({
      getPicker: () => {
        var _root$value;
        return (_root$value = root.value) == null ? void 0 : _root$value.getPicker();
      }
    });
    return () => {
      var isTimePicker = props.type === "time";
      var Component = isTimePicker ? TimePicker_default : DatePicker_default;
      var inheritProps = pick(props, isTimePicker ? timePickerPropKeys : datePickerPropKeys);
      return createVNode(Component, mergeProps({
        "ref": root,
        "class": bem53()
      }, inheritProps, attrs), slots);
    };
  }
});

// node_modules/vant/es/datetime-picker/index.js
var DatetimePicker = withInstall(DatetimePicker_default);

// node_modules/vant/es/dialog/Dialog.js
var [name59, bem54, t13] = createNamespace("dialog");
var dialogProps = extend({}, popupSharedProps, {
  title: String,
  theme: String,
  width: numericProp,
  message: [String, Function],
  callback: Function,
  allowHtml: Boolean,
  className: unknownProp,
  transition: makeStringProp("van-dialog-bounce"),
  messageAlign: String,
  closeOnPopstate: truthProp,
  showCancelButton: Boolean,
  cancelButtonText: String,
  cancelButtonColor: String,
  confirmButtonText: String,
  confirmButtonColor: String,
  showConfirmButton: truthProp,
  closeOnClickOverlay: Boolean
});
var popupInheritKeys2 = [...popupSharedPropKeys, "transition", "closeOnPopstate"];
var Dialog_default = defineComponent({
  name: name59,
  props: dialogProps,
  emits: ["confirm", "cancel", "update:show"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var loading = reactive({
      confirm: false,
      cancel: false
    });
    var updateShow = (value) => emit("update:show", value);
    var close = (action) => {
      updateShow(false);
      props.callback == null ? void 0 : props.callback(action);
    };
    var getActionHandler = (action) => () => {
      if (!props.show) {
        return;
      }
      emit(action);
      if (props.beforeClose) {
        loading[action] = true;
        callInterceptor(props.beforeClose, {
          args: [action],
          done() {
            close(action);
            loading[action] = false;
          },
          canceled() {
            loading[action] = false;
          }
        });
      } else {
        close(action);
      }
    };
    var onCancel = getActionHandler("cancel");
    var onConfirm = getActionHandler("confirm");
    var renderTitle = () => {
      var title = slots.title ? slots.title() : props.title;
      if (title) {
        return createVNode("div", {
          "class": bem54("header", {
            isolated: !props.message && !slots.default
          })
        }, [title]);
      }
    };
    var renderMessage = (hasTitle) => {
      var {
        message,
        allowHtml,
        messageAlign
      } = props;
      var classNames = bem54("message", {
        "has-title": hasTitle,
        [messageAlign]: messageAlign
      });
      var content = isFunction(message) ? message() : message;
      if (allowHtml && typeof content === "string") {
        return createVNode("div", {
          "class": classNames,
          "innerHTML": content
        }, null);
      }
      return createVNode("div", {
        "class": classNames
      }, [content]);
    };
    var renderContent = () => {
      if (slots.default) {
        return createVNode("div", {
          "class": bem54("content")
        }, [slots.default()]);
      }
      var {
        title,
        message,
        allowHtml
      } = props;
      if (message) {
        var hasTitle = !!(title || slots.title);
        return createVNode("div", {
          "key": allowHtml ? 1 : 0,
          "class": bem54("content", {
            isolated: !hasTitle
          })
        }, [renderMessage(hasTitle)]);
      }
    };
    var renderButtons = () => createVNode("div", {
      "class": [BORDER_TOP, bem54("footer")]
    }, [props.showCancelButton && createVNode(Button, {
      "size": "large",
      "text": props.cancelButtonText || t13("cancel"),
      "class": bem54("cancel"),
      "style": {
        color: props.cancelButtonColor
      },
      "loading": loading.cancel,
      "onClick": onCancel
    }, null), props.showConfirmButton && createVNode(Button, {
      "size": "large",
      "text": props.confirmButtonText || t13("confirm"),
      "class": [bem54("confirm"), {
        [BORDER_LEFT]: props.showCancelButton
      }],
      "style": {
        color: props.confirmButtonColor
      },
      "loading": loading.confirm,
      "onClick": onConfirm
    }, null)]);
    var renderRoundButtons = () => createVNode(ActionBar, {
      "class": bem54("footer")
    }, {
      default: () => [props.showCancelButton && createVNode(ActionBarButton, {
        "type": "warning",
        "text": props.cancelButtonText || t13("cancel"),
        "class": bem54("cancel"),
        "color": props.cancelButtonColor,
        "loading": loading.cancel,
        "onClick": onCancel
      }, null), props.showConfirmButton && createVNode(ActionBarButton, {
        "type": "danger",
        "text": props.confirmButtonText || t13("confirm"),
        "class": bem54("confirm"),
        "color": props.confirmButtonColor,
        "loading": loading.confirm,
        "onClick": onConfirm
      }, null)]
    });
    var renderFooter = () => {
      if (slots.footer) {
        return slots.footer();
      }
      return props.theme === "round-button" ? renderRoundButtons() : renderButtons();
    };
    return () => {
      var {
        width: width2,
        title,
        theme,
        message,
        className
      } = props;
      return createVNode(Popup, mergeProps({
        "role": "dialog",
        "class": [bem54([theme]), className],
        "style": {
          width: addUnit(width2)
        },
        "aria-labelledby": title || message,
        "onUpdate:show": updateShow
      }, pick(props, popupInheritKeys2)), {
        default: () => [renderTitle(), renderContent(), renderFooter()]
      });
    };
  }
});

// node_modules/vant/es/dialog/function-call.js
var instance;
function initInstance() {
  var Wrapper = {
    setup() {
      var {
        state,
        toggle
      } = usePopupState();
      return () => createVNode(Dialog_default, mergeProps(state, {
        "onUpdate:show": toggle
      }), null);
    }
  };
  ({
    instance
  } = mountComponent(Wrapper));
}
function Dialog(options) {
  if (!inBrowser) {
    return Promise.resolve();
  }
  return new Promise((resolve, reject) => {
    if (!instance) {
      initInstance();
    }
    instance.open(extend({}, Dialog.currentOptions, options, {
      callback: (action) => {
        (action === "confirm" ? resolve : reject)(action);
      }
    }));
  });
}
Dialog.defaultOptions = {
  title: "",
  width: "",
  theme: null,
  message: "",
  overlay: true,
  callback: null,
  teleport: "body",
  className: "",
  allowHtml: false,
  lockScroll: true,
  transition: void 0,
  beforeClose: null,
  overlayClass: "",
  overlayStyle: void 0,
  messageAlign: "",
  cancelButtonText: "",
  cancelButtonColor: null,
  confirmButtonText: "",
  confirmButtonColor: null,
  showConfirmButton: true,
  showCancelButton: false,
  closeOnPopstate: true,
  closeOnClickOverlay: false
};
Dialog.currentOptions = extend({}, Dialog.defaultOptions);
Dialog.alert = Dialog;
Dialog.confirm = (options) => Dialog(extend({
  showCancelButton: true
}, options));
Dialog.close = () => {
  if (instance) {
    instance.toggle(false);
  }
};
Dialog.setDefaultOptions = (options) => {
  extend(Dialog.currentOptions, options);
};
Dialog.resetDefaultOptions = () => {
  Dialog.currentOptions = extend({}, Dialog.defaultOptions);
};
Dialog.Component = withInstall(Dialog_default);
Dialog.install = (app) => {
  app.use(Dialog.Component);
  app.config.globalProperties.$dialog = Dialog;
};

// node_modules/vant/es/divider/Divider.js
var [name60, bem55] = createNamespace("divider");
var dividerProps = {
  dashed: Boolean,
  hairline: truthProp,
  contentPosition: makeStringProp("center")
};
var Divider_default = defineComponent({
  name: name60,
  props: dividerProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    return () => createVNode("div", {
      "role": "separator",
      "class": bem55({
        dashed: props.dashed,
        hairline: props.hairline,
        ["content-" + props.contentPosition]: !!slots.default
      })
    }, [slots.default == null ? void 0 : slots.default()]);
  }
});

// node_modules/vant/es/divider/index.js
var Divider = withInstall(Divider_default);

// node_modules/vant/es/dropdown-menu/DropdownMenu.js
var [name61, bem56] = createNamespace("dropdown-menu");
var dropdownMenuProps = {
  overlay: truthProp,
  zIndex: numericProp,
  duration: makeNumericProp(0.2),
  direction: makeStringProp("down"),
  activeColor: String,
  closeOnClickOutside: truthProp,
  closeOnClickOverlay: truthProp
};
var DROPDOWN_KEY = Symbol(name61);
var DropdownMenu_default = defineComponent({
  name: name61,
  props: dropdownMenuProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var id = useId();
    var root = ref();
    var barRef = ref();
    var offset2 = ref(0);
    var {
      children,
      linkChildren
    } = useChildren(DROPDOWN_KEY);
    var scrollParent = useScrollParent(root);
    var opened = computed(() => children.some((item) => item.state.showWrapper));
    var barStyle = computed(() => {
      if (opened.value && isDef(props.zIndex)) {
        return {
          zIndex: +props.zIndex + 1
        };
      }
    });
    var onClickAway = () => {
      if (props.closeOnClickOutside) {
        children.forEach((item) => {
          item.toggle(false);
        });
      }
    };
    var updateOffset = () => {
      if (barRef.value) {
        var rect = useRect(barRef);
        if (props.direction === "down") {
          offset2.value = rect.bottom;
        } else {
          offset2.value = windowHeight.value - rect.top;
        }
      }
    };
    var onScroll = () => {
      if (opened.value) {
        updateOffset();
      }
    };
    var toggleItem = (active) => {
      children.forEach((item, index) => {
        if (index === active) {
          updateOffset();
          item.toggle();
        } else if (item.state.showPopup) {
          item.toggle(false, {
            immediate: true
          });
        }
      });
    };
    var renderTitle = (item, index) => {
      var {
        showPopup
      } = item.state;
      var {
        disabled,
        titleClass
      } = item;
      return createVNode("div", {
        "id": id + "-" + index,
        "role": "button",
        "tabindex": disabled ? void 0 : 0,
        "class": [bem56("item", {
          disabled
        }), {
          [HAPTICS_FEEDBACK]: !disabled
        }],
        "onClick": () => {
          if (!disabled) {
            toggleItem(index);
          }
        }
      }, [createVNode("span", {
        "class": [bem56("title", {
          down: showPopup === (props.direction === "down"),
          active: showPopup
        }), titleClass],
        "style": {
          color: showPopup ? props.activeColor : ""
        }
      }, [createVNode("div", {
        "class": "van-ellipsis"
      }, [item.renderTitle()])])]);
    };
    linkChildren({
      id,
      props,
      offset: offset2
    });
    useClickAway(root, onClickAway);
    useEventListener("scroll", onScroll, {
      target: scrollParent
    });
    return () => createVNode("div", {
      "ref": root,
      "class": bem56()
    }, [createVNode("div", {
      "ref": barRef,
      "style": barStyle.value,
      "class": bem56("bar", {
        opened: opened.value
      })
    }, [children.map(renderTitle)]), slots.default == null ? void 0 : slots.default()]);
  }
});

// node_modules/vant/es/dropdown-item/DropdownItem.js
var [name62, bem57] = createNamespace("dropdown-item");
var dropdownItemProps = {
  title: String,
  options: makeArrayProp(),
  disabled: Boolean,
  teleport: [String, Object],
  lazyRender: truthProp,
  modelValue: unknownProp,
  titleClass: unknownProp
};
var DropdownItem_default = defineComponent({
  name: name62,
  props: dropdownItemProps,
  emits: ["open", "opened", "close", "closed", "change", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var state = reactive({
      showPopup: false,
      transition: true,
      showWrapper: false
    });
    var {
      parent,
      index
    } = useParent(DROPDOWN_KEY);
    if (!parent) {
      if (true) {
        console.error("[Vant] <DropdownItem> must be a child component of <DropdownMenu>.");
      }
      return;
    }
    var getEmitter = (name96) => () => emit(name96);
    var onOpen = getEmitter("open");
    var onClose = getEmitter("close");
    var onOpened = getEmitter("opened");
    var onClosed = () => {
      state.showWrapper = false;
      emit("closed");
    };
    var onClickWrapper = (event) => {
      if (props.teleport) {
        event.stopPropagation();
      }
    };
    var toggle = function(show, options) {
      if (show === void 0) {
        show = !state.showPopup;
      }
      if (options === void 0) {
        options = {};
      }
      if (show === state.showPopup) {
        return;
      }
      state.showPopup = show;
      state.transition = !options.immediate;
      if (show) {
        state.showWrapper = true;
      }
    };
    var renderTitle = () => {
      if (slots.title) {
        return slots.title();
      }
      if (props.title) {
        return props.title;
      }
      var match = props.options.find((option) => option.value === props.modelValue);
      return match ? match.text : "";
    };
    var renderOption = (option) => {
      var {
        activeColor
      } = parent.props;
      var active = option.value === props.modelValue;
      var onClick = () => {
        state.showPopup = false;
        if (option.value !== props.modelValue) {
          emit("update:modelValue", option.value);
          emit("change", option.value);
        }
      };
      var renderIcon = () => {
        if (active) {
          return createVNode(Icon, {
            "class": bem57("icon"),
            "color": activeColor,
            "name": "success"
          }, null);
        }
      };
      return createVNode(Cell, {
        "role": "menuitem",
        "key": option.value,
        "icon": option.icon,
        "title": option.text,
        "class": bem57("option", {
          active
        }),
        "style": {
          color: active ? activeColor : ""
        },
        "tabindex": active ? 0 : -1,
        "clickable": true,
        "onClick": onClick
      }, {
        value: renderIcon
      });
    };
    var renderContent = () => {
      var {
        offset: offset2
      } = parent;
      var {
        zIndex,
        overlay,
        duration,
        direction,
        closeOnClickOverlay
      } = parent.props;
      var style = getZIndexStyle(zIndex);
      if (direction === "down") {
        style.top = offset2.value + "px";
      } else {
        style.bottom = offset2.value + "px";
      }
      return withDirectives(createVNode("div", {
        "style": style,
        "class": bem57([direction]),
        "onClick": onClickWrapper
      }, [createVNode(Popup, {
        "show": state.showPopup,
        "onUpdate:show": ($event) => state.showPopup = $event,
        "role": "menu",
        "class": bem57("content"),
        "overlay": overlay,
        "position": direction === "down" ? "top" : "bottom",
        "duration": state.transition ? duration : 0,
        "lazyRender": props.lazyRender,
        "overlayStyle": {
          position: "absolute"
        },
        "aria-labelledby": parent.id + "-" + index.value,
        "closeOnClickOverlay": closeOnClickOverlay,
        "onOpen": onOpen,
        "onClose": onClose,
        "onOpened": onOpened,
        "onClosed": onClosed
      }, {
        default: () => [props.options.map(renderOption), slots.default == null ? void 0 : slots.default()]
      })]), [[vShow, state.showWrapper]]);
    };
    useExpose({
      state,
      toggle,
      renderTitle
    });
    return () => {
      if (props.teleport) {
        return createVNode(Teleport, {
          "to": props.teleport
        }, {
          default: () => [renderContent()]
        });
      }
      return renderContent();
    };
  }
});

// node_modules/vant/es/dropdown-item/index.js
var DropdownItem = withInstall(DropdownItem_default);

// node_modules/vant/es/dropdown-menu/index.js
var DropdownMenu = withInstall(DropdownMenu_default);

// node_modules/vant/es/empty/Network.js
var prefix = "van-empty-network-";
var renderStop = (color, offset2, opacity) => createVNode("stop", {
  "stop-color": color,
  "offset": offset2 + "%",
  "stop-opacity": opacity
}, null);
var Network = createVNode("svg", {
  "viewBox": "0 0 160 160"
}, [createVNode("defs", null, [createVNode("linearGradient", {
  "id": prefix + "1",
  "x1": "64%",
  "y1": "100%",
  "x2": "64%"
}, [renderStop("#FFF", 0, 0.5), renderStop("#F2F3F5", 100)]), createVNode("linearGradient", {
  "id": prefix + "2",
  "x1": "50%",
  "x2": "50%",
  "y2": "84%"
}, [renderStop("#EBEDF0", 0), renderStop("#DCDEE0", 100, 0)]), createVNode("linearGradient", {
  "id": prefix + "3",
  "x1": "100%",
  "x2": "100%",
  "y2": "100%"
}, [renderStop("#EAEDF0", 0), renderStop("#DCDEE0", 100)]), createVNode("radialGradient", {
  "id": prefix + "4",
  "cx": "50%",
  "cy": "0%",
  "fx": "50%",
  "fy": "0%",
  "r": "100%",
  "gradientTransform": "matrix(0 1 -.54 0 .5 -.5)"
}, [renderStop("#EBEDF0", 0), renderStop("#FFF", 100, 0)])]), createVNode("g", {
  "fill": "none"
}, [createVNode("g", {
  "opacity": ".8"
}, [createVNode("path", {
  "d": "M36 131V53H16v20H2v58h34z",
  "fill": "url(#" + prefix + "1)"
}, null), createVNode("path", {
  "d": "M123 15h22v14h9v77h-31V15z",
  "fill": "url(#" + prefix + "1)"
}, null)]), createVNode("path", {
  "fill": "url(#" + prefix + "4)",
  "d": "M0 139h160v21H0z"
}, null), createVNode("path", {
  "d": "M80 54a7 7 0 0 1 3 13v27l-2 2h-2a2 2 0 0 1-2-2V67a7 7 0 0 1 3-13z",
  "fill": "url(#" + prefix + "2)"
}, null), createVNode("g", {
  "opacity": ".6",
  "stroke-linecap": "round",
  "stroke-width": "7"
}, [createVNode("path", {
  "d": "M64 47a19 19 0 0 0-5 13c0 5 2 10 5 13",
  "stroke": "url(#" + prefix + "3)"
}, null), createVNode("path", {
  "d": "M53 36a34 34 0 0 0 0 48",
  "stroke": "url(#" + prefix + "3)"
}, null), createVNode("path", {
  "d": "M95 73a19 19 0 0 0 6-13c0-5-2-9-6-13",
  "stroke": "url(#" + prefix + "3)"
}, null), createVNode("path", {
  "d": "M106 84a34 34 0 0 0 0-48",
  "stroke": "url(#" + prefix + "3)"
}, null)]), createVNode("g", {
  "transform": "translate(31 105)"
}, [createVNode("rect", {
  "fill": "#EBEDF0",
  "width": "98",
  "height": "34",
  "rx": "2"
}, null), createVNode("rect", {
  "fill": "#FFF",
  "x": "9",
  "y": "8",
  "width": "80",
  "height": "18",
  "rx": "1.1"
}, null), createVNode("rect", {
  "fill": "#EBEDF0",
  "x": "15",
  "y": "12",
  "width": "18",
  "height": "6",
  "rx": "1.1"
}, null)])])]);

// node_modules/vant/es/empty/Empty.js
var [name63, bem58] = createNamespace("empty");
var PRESET_IMAGES = ["error", "search", "default"];
var emptyProps = {
  image: makeStringProp("default"),
  imageSize: numericProp,
  description: String
};
var Empty_default = defineComponent({
  name: name63,
  props: emptyProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var renderImage = () => {
      if (slots.image) {
        return slots.image();
      }
      var {
        image
      } = props;
      if (image === "network") {
        return Network;
      }
      if (PRESET_IMAGES.includes(image)) {
        image = "https://img.yzcdn.cn/vant/empty-image-" + image + ".png";
      }
      return createVNode("img", {
        "src": image
      }, null);
    };
    var renderDescription = () => {
      var description = slots.description ? slots.description() : props.description;
      if (description) {
        return createVNode("p", {
          "class": bem58("description")
        }, [description]);
      }
    };
    var renderBottom = () => {
      if (slots.default) {
        return createVNode("div", {
          "class": bem58("bottom")
        }, [slots.default()]);
      }
    };
    return () => createVNode("div", {
      "class": bem58()
    }, [createVNode("div", {
      "class": bem58("image"),
      "style": getSizeStyle(props.imageSize)
    }, [renderImage()]), renderDescription(), renderBottom()]);
  }
});

// node_modules/vant/es/empty/index.js
var Empty = withInstall(Empty_default);

// node_modules/vant/es/grid/Grid.js
var [name64, bem59] = createNamespace("grid");
var gridProps = {
  square: Boolean,
  center: truthProp,
  border: truthProp,
  gutter: numericProp,
  reverse: Boolean,
  iconSize: numericProp,
  direction: String,
  clickable: Boolean,
  columnNum: makeNumericProp(4)
};
var GRID_KEY = Symbol(name64);
var Grid_default = defineComponent({
  name: name64,
  props: gridProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var {
      linkChildren
    } = useChildren(GRID_KEY);
    linkChildren({
      props
    });
    return () => createVNode("div", {
      "style": {
        paddingLeft: addUnit(props.gutter)
      },
      "class": [bem59(), {
        [BORDER_TOP]: props.border && !props.gutter
      }]
    }, [slots.default == null ? void 0 : slots.default()]);
  }
});

// node_modules/vant/es/grid/index.js
var Grid = withInstall(Grid_default);

// node_modules/vant/es/grid-item/GridItem.js
var [name65, bem60] = createNamespace("grid-item");
var gridItemProps = extend({}, routeProps, {
  dot: Boolean,
  text: String,
  icon: String,
  badge: numericProp,
  iconColor: String,
  iconPrefix: String
});
var GridItem_default = defineComponent({
  name: name65,
  props: gridItemProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var {
      parent,
      index
    } = useParent(GRID_KEY);
    var route2 = useRoute();
    if (!parent) {
      if (true) {
        console.error("[Vant] <GridItem> must be a child component of <Grid>.");
      }
      return;
    }
    var rootStyle = computed(() => {
      var {
        square,
        gutter,
        columnNum
      } = parent.props;
      var percent = 100 / +columnNum + "%";
      var style = {
        flexBasis: percent
      };
      if (square) {
        style.paddingTop = percent;
      } else if (gutter) {
        var gutterValue = addUnit(gutter);
        style.paddingRight = gutterValue;
        if (index.value >= columnNum) {
          style.marginTop = gutterValue;
        }
      }
      return style;
    });
    var contentStyle = computed(() => {
      var {
        square,
        gutter
      } = parent.props;
      if (square && gutter) {
        var gutterValue = addUnit(gutter);
        return {
          right: gutterValue,
          bottom: gutterValue,
          height: "auto"
        };
      }
    });
    var renderIcon = () => {
      if (slots.icon) {
        return createVNode(Badge, {
          "dot": props.dot,
          "content": props.badge
        }, {
          default: slots.icon
        });
      }
      if (props.icon) {
        return createVNode(Icon, {
          "dot": props.dot,
          "name": props.icon,
          "size": parent.props.iconSize,
          "badge": props.badge,
          "class": bem60("icon"),
          "classPrefix": props.iconPrefix,
          "color": props.iconColor
        }, null);
      }
    };
    var renderText = () => {
      if (slots.text) {
        return slots.text();
      }
      if (props.text) {
        return createVNode("span", {
          "class": bem60("text")
        }, [props.text]);
      }
    };
    var renderContent = () => {
      if (slots.default) {
        return slots.default();
      }
      return [renderIcon(), renderText()];
    };
    return () => {
      var {
        center,
        border,
        square,
        gutter,
        reverse,
        direction,
        clickable
      } = parent.props;
      var classes = [bem60("content", [direction, {
        center,
        square,
        reverse,
        clickable,
        surround: border && gutter
      }]), {
        [BORDER]: border
      }];
      return createVNode("div", {
        "class": [bem60({
          square
        })],
        "style": rootStyle.value
      }, [createVNode("div", {
        "role": clickable ? "button" : void 0,
        "class": classes,
        "style": contentStyle.value,
        "tabindex": clickable ? 0 : void 0,
        "onClick": route2
      }, [renderContent()])]);
    };
  }
});

// node_modules/vant/es/grid-item/index.js
var GridItem = withInstall(GridItem_default);

// node_modules/vant/es/image-preview/ImagePreviewItem.js
var getDistance = (touches) => Math.sqrt(Math.pow(touches[0].clientX - touches[1].clientX, 2) + Math.pow(touches[0].clientY - touches[1].clientY, 2));
var bem61 = createNamespace("image-preview")[1];
var ImagePreviewItem_default = defineComponent({
  props: {
    src: String,
    show: Boolean,
    active: Number,
    minZoom: makeRequiredProp(numericProp),
    maxZoom: makeRequiredProp(numericProp),
    rootWidth: makeRequiredProp(Number),
    rootHeight: makeRequiredProp(Number)
  },
  emits: ["scale", "close"],
  setup(props, _ref) {
    var {
      emit
    } = _ref;
    var state = reactive({
      scale: 1,
      moveX: 0,
      moveY: 0,
      moving: false,
      zooming: false,
      imageRatio: 0,
      displayWidth: 0,
      displayHeight: 0
    });
    var touch = useTouch();
    var vertical = computed(() => {
      var {
        rootWidth,
        rootHeight
      } = props;
      var rootRatio = rootHeight / rootWidth;
      return state.imageRatio > rootRatio;
    });
    var imageStyle = computed(() => {
      var {
        scale,
        moveX,
        moveY,
        moving,
        zooming
      } = state;
      var style = {
        transitionDuration: zooming || moving ? "0s" : ".3s"
      };
      if (scale !== 1) {
        var offsetX = moveX / scale;
        var offsetY = moveY / scale;
        style.transform = "scale(" + scale + ", " + scale + ") translate(" + offsetX + "px, " + offsetY + "px)";
      }
      return style;
    });
    var maxMoveX = computed(() => {
      if (state.imageRatio) {
        var {
          rootWidth,
          rootHeight
        } = props;
        var displayWidth = vertical.value ? rootHeight / state.imageRatio : rootWidth;
        return Math.max(0, (state.scale * displayWidth - rootWidth) / 2);
      }
      return 0;
    });
    var maxMoveY = computed(() => {
      if (state.imageRatio) {
        var {
          rootWidth,
          rootHeight
        } = props;
        var displayHeight = vertical.value ? rootHeight : rootWidth * state.imageRatio;
        return Math.max(0, (state.scale * displayHeight - rootHeight) / 2);
      }
      return 0;
    });
    var setScale = (scale) => {
      scale = clamp(scale, +props.minZoom, +props.maxZoom);
      if (scale !== state.scale) {
        state.scale = scale;
        emit("scale", {
          scale,
          index: props.active
        });
      }
    };
    var resetScale = () => {
      setScale(1);
      state.moveX = 0;
      state.moveY = 0;
    };
    var toggleScale = () => {
      var scale = state.scale > 1 ? 1 : 2;
      setScale(scale);
      state.moveX = 0;
      state.moveY = 0;
    };
    var startMoveX;
    var startMoveY;
    var startScale;
    var startDistance;
    var doubleTapTimer;
    var touchStartTime;
    var onTouchStart = (event) => {
      var {
        touches
      } = event;
      var {
        offsetX
      } = touch;
      touch.start(event);
      startMoveX = state.moveX;
      startMoveY = state.moveY;
      touchStartTime = Date.now();
      state.moving = touches.length === 1 && state.scale !== 1;
      state.zooming = touches.length === 2 && !offsetX.value;
      if (state.zooming) {
        startScale = state.scale;
        startDistance = getDistance(event.touches);
      }
    };
    var onTouchMove = (event) => {
      var {
        touches
      } = event;
      touch.move(event);
      if (state.moving || state.zooming) {
        preventDefault(event, true);
      }
      if (state.moving) {
        var {
          deltaX,
          deltaY
        } = touch;
        var moveX = deltaX.value + startMoveX;
        var moveY = deltaY.value + startMoveY;
        state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);
        state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);
      }
      if (state.zooming && touches.length === 2) {
        var distance = getDistance(touches);
        var scale = startScale * distance / startDistance;
        setScale(scale);
      }
    };
    var checkTap = () => {
      var {
        offsetX,
        offsetY
      } = touch;
      var deltaTime = Date.now() - touchStartTime;
      var TAP_TIME = 250;
      var TAP_OFFSET = 10;
      if (offsetX.value < TAP_OFFSET && offsetY.value < TAP_OFFSET && deltaTime < TAP_TIME) {
        if (doubleTapTimer) {
          clearTimeout(doubleTapTimer);
          doubleTapTimer = null;
          toggleScale();
        } else {
          doubleTapTimer = setTimeout(() => {
            emit("close");
            doubleTapTimer = null;
          }, TAP_TIME);
        }
      }
    };
    var onTouchEnd = (event) => {
      var stopPropagation2 = false;
      if (state.moving || state.zooming) {
        stopPropagation2 = true;
        if (state.moving && startMoveX === state.moveX && startMoveY === state.moveY) {
          stopPropagation2 = false;
        }
        if (!event.touches.length) {
          if (state.zooming) {
            state.moveX = clamp(state.moveX, -maxMoveX.value, maxMoveX.value);
            state.moveY = clamp(state.moveY, -maxMoveY.value, maxMoveY.value);
            state.zooming = false;
          }
          state.moving = false;
          startMoveX = 0;
          startMoveY = 0;
          startScale = 1;
          if (state.scale < 1) {
            resetScale();
          }
        }
      }
      preventDefault(event, stopPropagation2);
      checkTap();
      touch.reset();
    };
    var onLoad = (event) => {
      var {
        naturalWidth,
        naturalHeight
      } = event.target;
      state.imageRatio = naturalHeight / naturalWidth;
    };
    watch(() => props.active, resetScale);
    watch(() => props.show, (value) => {
      if (!value) {
        resetScale();
      }
    });
    return () => {
      var imageSlots = {
        loading: () => createVNode(Loading, {
          "type": "spinner"
        }, null)
      };
      return createVNode(SwipeItem, {
        "class": bem61("swipe-item"),
        "onTouchstart": onTouchStart,
        "onTouchmove": onTouchMove,
        "onTouchend": onTouchEnd,
        "onTouchcancel": onTouchEnd
      }, {
        default: () => [createVNode(Image2, {
          "src": props.src,
          "fit": "contain",
          "class": bem61("image", {
            vertical: vertical.value
          }),
          "style": imageStyle.value,
          "onLoad": onLoad
        }, imageSlots)]
      });
    };
  }
});

// node_modules/vant/es/image-preview/ImagePreview.js
var [name66, bem62] = createNamespace("image-preview");
var popupProps2 = ["show", "transition", "overlayStyle", "closeOnPopstate"];
var imagePreviewProps = {
  show: Boolean,
  loop: truthProp,
  images: makeArrayProp(),
  minZoom: makeNumericProp(1 / 3),
  maxZoom: makeNumericProp(3),
  overlay: truthProp,
  closeable: Boolean,
  showIndex: truthProp,
  className: unknownProp,
  closeIcon: makeStringProp("clear"),
  transition: String,
  beforeClose: Function,
  overlayStyle: Object,
  swipeDuration: makeNumericProp(300),
  startPosition: makeNumericProp(0),
  showIndicators: Boolean,
  closeOnPopstate: truthProp,
  closeIconPosition: makeStringProp("top-right")
};
var ImagePreview_default = defineComponent({
  name: name66,
  props: imagePreviewProps,
  emits: ["scale", "close", "closed", "change", "update:show"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var swipeRef = ref();
    var state = reactive({
      active: 0,
      rootWidth: 0,
      rootHeight: 0
    });
    var resize = () => {
      if (swipeRef.value) {
        var rect = useRect(swipeRef.value.$el);
        state.rootWidth = rect.width;
        state.rootHeight = rect.height;
        swipeRef.value.resize();
      }
    };
    var emitScale = (args) => emit("scale", args);
    var updateShow = (show) => emit("update:show", show);
    var emitClose = () => {
      callInterceptor(props.beforeClose, {
        args: [state.active],
        done: () => updateShow(false)
      });
    };
    var setActive = (active) => {
      if (active !== state.active) {
        state.active = active;
        emit("change", active);
      }
    };
    var renderIndex = () => {
      if (props.showIndex) {
        return createVNode("div", {
          "class": bem62("index")
        }, [slots.index ? slots.index({
          index: state.active
        }) : state.active + 1 + " / " + props.images.length]);
      }
    };
    var renderCover = () => {
      if (slots.cover) {
        return createVNode("div", {
          "class": bem62("cover")
        }, [slots.cover()]);
      }
    };
    var renderImages = () => createVNode(Swipe, {
      "ref": swipeRef,
      "lazyRender": true,
      "loop": props.loop,
      "class": bem62("swipe"),
      "duration": props.swipeDuration,
      "initialSwipe": props.startPosition,
      "showIndicators": props.showIndicators,
      "indicatorColor": "white",
      "onChange": setActive
    }, {
      default: () => [props.images.map((image) => createVNode(ImagePreviewItem_default, {
        "src": image,
        "show": props.show,
        "active": state.active,
        "maxZoom": props.maxZoom,
        "minZoom": props.minZoom,
        "rootWidth": state.rootWidth,
        "rootHeight": state.rootHeight,
        "onScale": emitScale,
        "onClose": emitClose
      }, null))]
    });
    var renderClose = () => {
      if (props.closeable) {
        return createVNode(Icon, {
          "role": "button",
          "name": props.closeIcon,
          "class": [bem62("close-icon", props.closeIconPosition), HAPTICS_FEEDBACK],
          "onClick": emitClose
        }, null);
      }
    };
    var onClosed = () => emit("closed");
    var swipeTo = (index, options) => {
      var _swipeRef$value;
      return (_swipeRef$value = swipeRef.value) == null ? void 0 : _swipeRef$value.swipeTo(index, options);
    };
    useExpose({
      swipeTo
    });
    onMounted(resize);
    watch([windowWidth, windowHeight], resize);
    watch(() => props.startPosition, (value) => setActive(+value));
    watch(() => props.show, (value) => {
      var {
        images,
        startPosition
      } = props;
      if (value) {
        setActive(+startPosition);
        nextTick(() => {
          resize();
          swipeTo(+startPosition, {
            immediate: true
          });
        });
      } else {
        emit("close", {
          index: state.active,
          url: images[state.active]
        });
      }
    });
    return () => createVNode(Popup, mergeProps({
      "class": [bem62(), props.className],
      "overlayClass": bem62("overlay"),
      "onClosed": onClosed,
      "onUpdate:show": updateShow
    }, pick(props, popupProps2)), {
      default: () => [renderClose(), renderImages(), renderIndex(), renderCover()]
    });
  }
});

// node_modules/vant/es/image-preview/function-call.js
var instance2;
var defaultConfig = {
  loop: true,
  images: [],
  maxZoom: 3,
  minZoom: 1 / 3,
  onScale: void 0,
  onClose: void 0,
  onChange: void 0,
  teleport: "body",
  className: "",
  showIndex: true,
  closeable: false,
  closeIcon: "clear",
  transition: void 0,
  beforeClose: void 0,
  overlayStyle: void 0,
  startPosition: 0,
  swipeDuration: 300,
  showIndicators: false,
  closeOnPopstate: true,
  closeIconPosition: "top-right"
};
function initInstance2() {
  ({
    instance: instance2
  } = mountComponent({
    setup() {
      var {
        state,
        toggle
      } = usePopupState();
      var onClosed = () => {
        state.images = [];
      };
      return () => createVNode(ImagePreview_default, mergeProps(state, {
        "onClosed": onClosed,
        "onUpdate:show": toggle
      }), null);
    }
  }));
}
var ImagePreview = function(options, startPosition) {
  if (startPosition === void 0) {
    startPosition = 0;
  }
  if (!inBrowser) {
    return;
  }
  if (!instance2) {
    initInstance2();
  }
  options = Array.isArray(options) ? {
    images: options,
    startPosition
  } : options;
  instance2.open(extend({}, defaultConfig, options));
  return instance2;
};
ImagePreview.Component = withInstall(ImagePreview_default);
ImagePreview.install = (app) => {
  app.use(ImagePreview.Component);
};

// node_modules/vant/es/index-bar/IndexBar.js
function genAlphabet() {
  var charCodeOfA = "A".charCodeAt(0);
  var indexList = Array(26).fill("").map((_, i) => String.fromCharCode(charCodeOfA + i));
  return indexList;
}
var [name67, bem63] = createNamespace("index-bar");
var indexBarProps = {
  sticky: truthProp,
  zIndex: numericProp,
  teleport: [String, Object],
  highlightColor: String,
  stickyOffsetTop: makeNumberProp(0),
  indexList: {
    type: Array,
    default: genAlphabet
  }
};
var INDEX_BAR_KEY = Symbol(name67);
var IndexBar_default = defineComponent({
  name: name67,
  props: indexBarProps,
  emits: ["select", "change"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var root = ref();
    var activeAnchor = ref("");
    var touch = useTouch();
    var scrollParent = useScrollParent(root);
    var {
      children,
      linkChildren
    } = useChildren(INDEX_BAR_KEY);
    linkChildren({
      props
    });
    var sidebarStyle = computed(() => {
      if (isDef(props.zIndex)) {
        return {
          zIndex: +props.zIndex + 1
        };
      }
    });
    var highlightStyle = computed(() => {
      if (props.highlightColor) {
        return {
          color: props.highlightColor
        };
      }
    });
    var getActiveAnchor = (scrollTop, rects) => {
      for (var i = children.length - 1; i >= 0; i--) {
        var prevHeight = i > 0 ? rects[i - 1].height : 0;
        var reachTop = props.sticky ? prevHeight + props.stickyOffsetTop : 0;
        if (scrollTop + reachTop >= rects[i].top) {
          return i;
        }
      }
      return -1;
    };
    var onScroll = () => {
      if (isHidden(root)) {
        return;
      }
      var {
        sticky,
        indexList
      } = props;
      var scrollTop = getScrollTop(scrollParent.value);
      var scrollParentRect = useRect(scrollParent);
      var rects = children.map((item) => item.getRect(scrollParent.value, scrollParentRect));
      var active = getActiveAnchor(scrollTop, rects);
      activeAnchor.value = indexList[active];
      if (sticky) {
        children.forEach((item, index) => {
          var {
            state,
            $el
          } = item;
          if (index === active || index === active - 1) {
            var rect = $el.getBoundingClientRect();
            state.left = rect.left;
            state.width = rect.width;
          } else {
            state.left = null;
            state.width = null;
          }
          if (index === active) {
            state.active = true;
            state.top = Math.max(props.stickyOffsetTop, rects[index].top - scrollTop) + scrollParentRect.top;
          } else if (index === active - 1) {
            var activeItemTop = rects[active].top - scrollTop;
            state.active = activeItemTop > 0;
            state.top = activeItemTop + scrollParentRect.top - rects[index].height;
          } else {
            state.active = false;
          }
        });
      }
    };
    var init = () => nextTick(onScroll);
    useEventListener("scroll", onScroll, {
      target: scrollParent
    });
    onMounted(init);
    watch(() => props.indexList, init);
    watch(activeAnchor, (value) => {
      if (value) {
        emit("change", value);
      }
    });
    var renderIndexes = () => props.indexList.map((index) => {
      var active = index === activeAnchor.value;
      return createVNode("span", {
        "class": bem63("index", {
          active
        }),
        "style": active ? highlightStyle.value : void 0,
        "data-index": index
      }, [index]);
    });
    var scrollTo = (index) => {
      index = String(index);
      var match = children.find((item) => String(item.index) === index);
      if (match) {
        match.$el.scrollIntoView();
        if (props.sticky && props.stickyOffsetTop) {
          setRootScrollTop(getRootScrollTop() - props.stickyOffsetTop);
        }
        emit("select", match.index);
      }
    };
    var scrollToElement = (element) => {
      var {
        index
      } = element.dataset;
      if (index) {
        scrollTo(index);
      }
    };
    var onClickSidebar = (event) => {
      scrollToElement(event.target);
    };
    var touchActiveIndex;
    var onTouchMove = (event) => {
      touch.move(event);
      if (touch.isVertical()) {
        preventDefault(event);
        var {
          clientX,
          clientY
        } = event.touches[0];
        var target = document.elementFromPoint(clientX, clientY);
        if (target) {
          var {
            index
          } = target.dataset;
          if (index && touchActiveIndex !== index) {
            touchActiveIndex = index;
            scrollToElement(target);
          }
        }
      }
    };
    var renderSidebar = () => createVNode("div", {
      "class": bem63("sidebar"),
      "style": sidebarStyle.value,
      "onClick": onClickSidebar,
      "onTouchstart": touch.start,
      "onTouchmove": onTouchMove
    }, [renderIndexes()]);
    useExpose({
      scrollTo
    });
    return () => createVNode("div", {
      "ref": root,
      "class": bem63()
    }, [props.teleport ? createVNode(Teleport, {
      "to": props.teleport
    }, {
      default: () => [renderSidebar()]
    }) : renderSidebar(), slots.default == null ? void 0 : slots.default()]);
  }
});

// node_modules/vant/es/index-anchor/IndexAnchor.js
var [name68, bem64] = createNamespace("index-anchor");
var indexAnchorProps = {
  index: numericProp
};
var IndexAnchor_default = defineComponent({
  name: name68,
  props: indexAnchorProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var state = reactive({
      top: 0,
      left: null,
      rect: {
        top: 0,
        height: 0
      },
      width: null,
      active: false
    });
    var root = ref();
    var {
      parent
    } = useParent(INDEX_BAR_KEY);
    if (!parent) {
      if (true) {
        console.error("[Vant] <IndexAnchor> must be a child component of <IndexBar>.");
      }
      return;
    }
    var isSticky = () => state.active && parent.props.sticky;
    var anchorStyle = computed(() => {
      var {
        zIndex,
        highlightColor
      } = parent.props;
      if (isSticky()) {
        return extend(getZIndexStyle(zIndex), {
          left: state.left ? state.left + "px" : void 0,
          width: state.width ? state.width + "px" : void 0,
          transform: state.top ? "translate3d(0, " + state.top + "px, 0)" : void 0,
          color: highlightColor
        });
      }
    });
    var getRect = (scrollParent, scrollParentRect) => {
      var rootRect = useRect(root);
      state.rect.height = rootRect.height;
      if (scrollParent === window || scrollParent === document.body) {
        state.rect.top = rootRect.top + getRootScrollTop();
      } else {
        state.rect.top = rootRect.top + getScrollTop(scrollParent) - scrollParentRect.top;
      }
      return state.rect;
    };
    useExpose({
      state,
      getRect
    });
    return () => {
      var sticky = isSticky();
      return createVNode("div", {
        "ref": root,
        "style": {
          height: sticky ? state.rect.height + "px" : void 0
        }
      }, [createVNode("div", {
        "style": anchorStyle.value,
        "class": [bem64({
          sticky
        }), {
          [BORDER_BOTTOM]: sticky
        }]
      }, [slots.default ? slots.default() : props.index])]);
    };
  }
});

// node_modules/vant/es/index-anchor/index.js
var IndexAnchor = withInstall(IndexAnchor_default);

// node_modules/vant/es/index-bar/index.js
var IndexBar = withInstall(IndexBar_default);

// node_modules/vant/es/lazyload/vue-lazyload/util.js
var hasIntersectionObserver = inBrowser2 && "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype;
var modeType = {
  event: "event",
  observer: "observer"
};
function remove(arr, item) {
  if (!arr.length)
    return;
  var index = arr.indexOf(item);
  if (index > -1)
    return arr.splice(index, 1);
}
function getBestSelectionFromSrcset(el, scale) {
  if (el.tagName !== "IMG" || !el.getAttribute("data-srcset"))
    return;
  var options = el.getAttribute("data-srcset");
  var container = el.parentNode;
  var containerWidth = container.offsetWidth * scale;
  var spaceIndex;
  var tmpSrc;
  var tmpWidth;
  options = options.trim().split(",");
  var result = options.map((item) => {
    item = item.trim();
    spaceIndex = item.lastIndexOf(" ");
    if (spaceIndex === -1) {
      tmpSrc = item;
      tmpWidth = 999998;
    } else {
      tmpSrc = item.substr(0, spaceIndex);
      tmpWidth = parseInt(item.substr(spaceIndex + 1, item.length - spaceIndex - 2), 10);
    }
    return [tmpWidth, tmpSrc];
  });
  result.sort((a, b) => {
    if (a[0] < b[0]) {
      return 1;
    }
    if (a[0] > b[0]) {
      return -1;
    }
    if (a[0] === b[0]) {
      if (b[1].indexOf(".webp", b[1].length - 5) !== -1) {
        return 1;
      }
      if (a[1].indexOf(".webp", a[1].length - 5) !== -1) {
        return -1;
      }
    }
    return 0;
  });
  var bestSelectedSrc = "";
  var tmpOption;
  for (var i = 0; i < result.length; i++) {
    tmpOption = result[i];
    bestSelectedSrc = tmpOption[1];
    var next = result[i + 1];
    if (next && next[0] < containerWidth) {
      bestSelectedSrc = tmpOption[1];
      break;
    } else if (!next) {
      bestSelectedSrc = tmpOption[1];
      break;
    }
  }
  return bestSelectedSrc;
}
var getDPR = function(scale) {
  if (scale === void 0) {
    scale = 1;
  }
  return inBrowser2 ? window.devicePixelRatio || scale : scale;
};
function supportWebp() {
  if (!inBrowser2)
    return false;
  var support = true;
  try {
    var elem = document.createElement("canvas");
    if (elem.getContext && elem.getContext("2d")) {
      support = elem.toDataURL("image/webp").indexOf("data:image/webp") === 0;
    }
  } catch (err) {
    support = false;
  }
  return support;
}
function throttle(action, delay) {
  var timeout = null;
  var lastRun = 0;
  return function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (timeout) {
      return;
    }
    var elapsed = Date.now() - lastRun;
    var runCallback = () => {
      lastRun = Date.now();
      timeout = false;
      action.apply(this, args);
    };
    if (elapsed >= delay) {
      runCallback();
    } else {
      timeout = setTimeout(runCallback, delay);
    }
  };
}
function on(el, type, func) {
  el.addEventListener(type, func, {
    capture: false,
    passive: true
  });
}
function off(el, type, func) {
  el.removeEventListener(type, func, false);
}
var loadImageAsync = (item, resolve, reject) => {
  var image = new Image();
  if (!item || !item.src) {
    return reject(new Error("image src is required"));
  }
  image.src = item.src;
  if (item.cors) {
    image.crossOrigin = item.cors;
  }
  image.onload = () => resolve({
    naturalHeight: image.naturalHeight,
    naturalWidth: image.naturalWidth,
    src: image.src
  });
  image.onerror = (e) => reject(e);
};
var ImageCache = class {
  constructor(_ref) {
    var {
      max
    } = _ref;
    this.options = {
      max: max || 100
    };
    this.caches = [];
  }
  has(key) {
    return this.caches.indexOf(key) > -1;
  }
  add(key) {
    if (this.has(key))
      return;
    this.caches.push(key);
    if (this.caches.length > this.options.max) {
      this.free();
    }
  }
  free() {
    this.caches.shift();
  }
};

// node_modules/vant/es/lazyload/vue-lazyload/listener.js
var ReactiveListener = class {
  constructor(_ref) {
    var {
      el,
      src,
      error,
      loading,
      bindType,
      $parent,
      options,
      cors,
      elRenderer,
      imageCache
    } = _ref;
    this.el = el;
    this.src = src;
    this.error = error;
    this.loading = loading;
    this.bindType = bindType;
    this.attempt = 0;
    this.cors = cors;
    this.naturalHeight = 0;
    this.naturalWidth = 0;
    this.options = options;
    this.$parent = $parent;
    this.elRenderer = elRenderer;
    this.imageCache = imageCache;
    this.performanceData = {
      loadStart: 0,
      loadEnd: 0
    };
    this.filter();
    this.initState();
    this.render("loading", false);
  }
  initState() {
    if ("dataset" in this.el) {
      this.el.dataset.src = this.src;
    } else {
      this.el.setAttribute("data-src", this.src);
    }
    this.state = {
      loading: false,
      error: false,
      loaded: false,
      rendered: false
    };
  }
  record(event) {
    this.performanceData[event] = Date.now();
  }
  update(_ref2) {
    var {
      src,
      loading,
      error
    } = _ref2;
    var oldSrc = this.src;
    this.src = src;
    this.loading = loading;
    this.error = error;
    this.filter();
    if (oldSrc !== this.src) {
      this.attempt = 0;
      this.initState();
    }
  }
  checkInView() {
    var rect = useRect(this.el);
    return rect.top < window.innerHeight * this.options.preLoad && rect.bottom > this.options.preLoadTop && rect.left < window.innerWidth * this.options.preLoad && rect.right > 0;
  }
  filter() {
    Object.keys(this.options.filter).forEach((key) => {
      this.options.filter[key](this, this.options);
    });
  }
  renderLoading(cb) {
    this.state.loading = true;
    loadImageAsync({
      src: this.loading,
      cors: this.cors
    }, () => {
      this.render("loading", false);
      this.state.loading = false;
      cb();
    }, () => {
      cb();
      this.state.loading = false;
      if (!this.options.silent)
        console.warn("[@vant/lazyload] load failed with loading image(" + this.loading + ")");
    });
  }
  load(onFinish) {
    if (onFinish === void 0) {
      onFinish = noop;
    }
    if (this.attempt > this.options.attempt - 1 && this.state.error) {
      if (!this.options.silent) {
        console.log("[@vant/lazyload] " + this.src + " tried too more than " + this.options.attempt + " times");
      }
      onFinish();
      return;
    }
    if (this.state.rendered && this.state.loaded)
      return;
    if (this.imageCache.has(this.src)) {
      this.state.loaded = true;
      this.render("loaded", true);
      this.state.rendered = true;
      return onFinish();
    }
    this.renderLoading(() => {
      var _this$options$adapter, _this$options$adapter2;
      this.attempt++;
      (_this$options$adapter = (_this$options$adapter2 = this.options.adapter).beforeLoad) == null ? void 0 : _this$options$adapter.call(_this$options$adapter2, this, this.options);
      this.record("loadStart");
      loadImageAsync({
        src: this.src,
        cors: this.cors
      }, (data) => {
        this.naturalHeight = data.naturalHeight;
        this.naturalWidth = data.naturalWidth;
        this.state.loaded = true;
        this.state.error = false;
        this.record("loadEnd");
        this.render("loaded", false);
        this.state.rendered = true;
        this.imageCache.add(this.src);
        onFinish();
      }, (err) => {
        !this.options.silent && console.error(err);
        this.state.error = true;
        this.state.loaded = false;
        this.render("error", false);
      });
    });
  }
  render(state, cache) {
    this.elRenderer(this, state, cache);
  }
  performance() {
    var state = "loading";
    var time = 0;
    if (this.state.loaded) {
      state = "loaded";
      time = (this.performanceData.loadEnd - this.performanceData.loadStart) / 1e3;
    }
    if (this.state.error)
      state = "error";
    return {
      src: this.src,
      state,
      time
    };
  }
  $destroy() {
    this.el = null;
    this.src = null;
    this.error = null;
    this.loading = null;
    this.bindType = null;
    this.attempt = 0;
  }
};

// node_modules/vant/es/lazyload/vue-lazyload/lazy.js
var DEFAULT_URL = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
var DEFAULT_EVENTS = ["scroll", "wheel", "mousewheel", "resize", "animationend", "transitionend", "touchmove"];
var DEFAULT_OBSERVER_OPTIONS = {
  rootMargin: "0px",
  threshold: 0
};
function lazy_default() {
  return class Lazy {
    constructor(_ref) {
      var {
        preLoad,
        error,
        throttleWait,
        preLoadTop,
        dispatchEvent,
        loading,
        attempt,
        silent = true,
        scale,
        listenEvents,
        filter,
        adapter,
        observer,
        observerOptions
      } = _ref;
      this.mode = modeType.event;
      this.listeners = [];
      this.targetIndex = 0;
      this.targets = [];
      this.options = {
        silent,
        dispatchEvent: !!dispatchEvent,
        throttleWait: throttleWait || 200,
        preLoad: preLoad || 1.3,
        preLoadTop: preLoadTop || 0,
        error: error || DEFAULT_URL,
        loading: loading || DEFAULT_URL,
        attempt: attempt || 3,
        scale: scale || getDPR(scale),
        ListenEvents: listenEvents || DEFAULT_EVENTS,
        supportWebp: supportWebp(),
        filter: filter || {},
        adapter: adapter || {},
        observer: !!observer,
        observerOptions: observerOptions || DEFAULT_OBSERVER_OPTIONS
      };
      this.initEvent();
      this.imageCache = new ImageCache({
        max: 200
      });
      this.lazyLoadHandler = throttle(this.lazyLoadHandler.bind(this), this.options.throttleWait);
      this.setMode(this.options.observer ? modeType.observer : modeType.event);
    }
    config(options) {
      if (options === void 0) {
        options = {};
      }
      Object.assign(this.options, options);
    }
    performance() {
      return this.listeners.map((item) => item.performance());
    }
    addLazyBox(vm) {
      this.listeners.push(vm);
      if (inBrowser2) {
        this.addListenerTarget(window);
        this.observer && this.observer.observe(vm.el);
        if (vm.$el && vm.$el.parentNode) {
          this.addListenerTarget(vm.$el.parentNode);
        }
      }
    }
    add(el, binding, vnode) {
      if (this.listeners.some((item) => item.el === el)) {
        this.update(el, binding);
        return nextTick(this.lazyLoadHandler);
      }
      var value = this.valueFormatter(binding.value);
      var {
        src
      } = value;
      nextTick(() => {
        src = getBestSelectionFromSrcset(el, this.options.scale) || src;
        this.observer && this.observer.observe(el);
        var container = Object.keys(binding.modifiers)[0];
        var $parent;
        if (container) {
          $parent = vnode.context.$refs[container];
          $parent = $parent ? $parent.$el || $parent : document.getElementById(container);
        }
        if (!$parent) {
          $parent = getScrollParent(el);
        }
        var newListener = new ReactiveListener({
          bindType: binding.arg,
          $parent,
          el,
          src,
          loading: value.loading,
          error: value.error,
          cors: value.cors,
          elRenderer: this.elRenderer.bind(this),
          options: this.options,
          imageCache: this.imageCache
        });
        this.listeners.push(newListener);
        if (inBrowser2) {
          this.addListenerTarget(window);
          this.addListenerTarget($parent);
        }
        this.lazyLoadHandler();
        nextTick(() => this.lazyLoadHandler());
      });
    }
    update(el, binding, vnode) {
      var value = this.valueFormatter(binding.value);
      var {
        src
      } = value;
      src = getBestSelectionFromSrcset(el, this.options.scale) || src;
      var exist = this.listeners.find((item) => item.el === el);
      if (!exist) {
        this.add(el, binding, vnode);
      } else {
        exist.update({
          src,
          error: value.error,
          loading: value.loading
        });
      }
      if (this.observer) {
        this.observer.unobserve(el);
        this.observer.observe(el);
      }
      this.lazyLoadHandler();
      nextTick(() => this.lazyLoadHandler());
    }
    remove(el) {
      if (!el)
        return;
      this.observer && this.observer.unobserve(el);
      var existItem = this.listeners.find((item) => item.el === el);
      if (existItem) {
        this.removeListenerTarget(existItem.$parent);
        this.removeListenerTarget(window);
        remove(this.listeners, existItem);
        existItem.$destroy();
      }
    }
    removeComponent(vm) {
      if (!vm)
        return;
      remove(this.listeners, vm);
      this.observer && this.observer.unobserve(vm.el);
      if (vm.$parent && vm.$el.parentNode) {
        this.removeListenerTarget(vm.$el.parentNode);
      }
      this.removeListenerTarget(window);
    }
    setMode(mode) {
      if (!hasIntersectionObserver && mode === modeType.observer) {
        mode = modeType.event;
      }
      this.mode = mode;
      if (mode === modeType.event) {
        if (this.observer) {
          this.listeners.forEach((listener) => {
            this.observer.unobserve(listener.el);
          });
          this.observer = null;
        }
        this.targets.forEach((target) => {
          this.initListen(target.el, true);
        });
      } else {
        this.targets.forEach((target) => {
          this.initListen(target.el, false);
        });
        this.initIntersectionObserver();
      }
    }
    addListenerTarget(el) {
      if (!el)
        return;
      var target = this.targets.find((target2) => target2.el === el);
      if (!target) {
        target = {
          el,
          id: ++this.targetIndex,
          childrenCount: 1,
          listened: true
        };
        this.mode === modeType.event && this.initListen(target.el, true);
        this.targets.push(target);
      } else {
        target.childrenCount++;
      }
      return this.targetIndex;
    }
    removeListenerTarget(el) {
      this.targets.forEach((target, index) => {
        if (target.el === el) {
          target.childrenCount--;
          if (!target.childrenCount) {
            this.initListen(target.el, false);
            this.targets.splice(index, 1);
            target = null;
          }
        }
      });
    }
    initListen(el, start2) {
      this.options.ListenEvents.forEach((evt) => (start2 ? on : off)(el, evt, this.lazyLoadHandler));
    }
    initEvent() {
      var _this = this;
      this.Event = {
        listeners: {
          loading: [],
          loaded: [],
          error: []
        }
      };
      this.$on = (event, func) => {
        if (!this.Event.listeners[event])
          this.Event.listeners[event] = [];
        this.Event.listeners[event].push(func);
      };
      this.$once = (event, func) => {
        var on2 = function() {
          _this.$off(event, on2);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          func.apply(_this, args);
        };
        this.$on(event, on2);
      };
      this.$off = (event, func) => {
        if (!func) {
          if (!this.Event.listeners[event])
            return;
          this.Event.listeners[event].length = 0;
          return;
        }
        remove(this.Event.listeners[event], func);
      };
      this.$emit = (event, context, inCache) => {
        if (!this.Event.listeners[event])
          return;
        this.Event.listeners[event].forEach((func) => func(context, inCache));
      };
    }
    lazyLoadHandler() {
      var freeList = [];
      this.listeners.forEach((listener) => {
        if (!listener.el || !listener.el.parentNode) {
          freeList.push(listener);
        }
        var catIn = listener.checkInView();
        if (!catIn)
          return;
        listener.load();
      });
      freeList.forEach((item) => {
        remove(this.listeners, item);
        item.$destroy();
      });
    }
    initIntersectionObserver() {
      if (!hasIntersectionObserver) {
        return;
      }
      this.observer = new IntersectionObserver(this.observerHandler.bind(this), this.options.observerOptions);
      if (this.listeners.length) {
        this.listeners.forEach((listener) => {
          this.observer.observe(listener.el);
        });
      }
    }
    observerHandler(entries) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.listeners.forEach((listener) => {
            if (listener.el === entry.target) {
              if (listener.state.loaded)
                return this.observer.unobserve(listener.el);
              listener.load();
            }
          });
        }
      });
    }
    elRenderer(listener, state, cache) {
      if (!listener.el)
        return;
      var {
        el,
        bindType
      } = listener;
      var src;
      switch (state) {
        case "loading":
          src = listener.loading;
          break;
        case "error":
          src = listener.error;
          break;
        default:
          ({
            src
          } = listener);
          break;
      }
      if (bindType) {
        el.style[bindType] = 'url("' + src + '")';
      } else if (el.getAttribute("src") !== src) {
        el.setAttribute("src", src);
      }
      el.setAttribute("lazy", state);
      this.$emit(state, listener, cache);
      this.options.adapter[state] && this.options.adapter[state](listener, this.options);
      if (this.options.dispatchEvent) {
        var event = new CustomEvent(state, {
          detail: listener
        });
        el.dispatchEvent(event);
      }
    }
    valueFormatter(value) {
      var src = value;
      var {
        loading,
        error
      } = this.options;
      if (isObject(value)) {
        if (!value.src && !this.options.silent) {
          console.error("[@vant/lazyload] miss src with " + value);
        }
        ({
          src
        } = value);
        loading = value.loading || this.options.loading;
        error = value.error || this.options.error;
      }
      return {
        src,
        loading,
        error
      };
    }
  };
}

// node_modules/vant/es/lazyload/vue-lazyload/lazy-component.js
var lazy_component_default = (lazy) => ({
  props: {
    tag: {
      type: String,
      default: "div"
    }
  },
  emits: ["show"],
  render() {
    return h(this.tag, this.show && this.$slots.default ? this.$slots.default() : null);
  },
  data() {
    return {
      el: null,
      state: {
        loaded: false
      },
      show: false
    };
  },
  mounted() {
    this.el = this.$el;
    lazy.addLazyBox(this);
    lazy.lazyLoadHandler();
  },
  beforeUnmount() {
    lazy.removeComponent(this);
  },
  methods: {
    checkInView() {
      var rect = useRect(this.$el);
      return inBrowser2 && rect.top < window.innerHeight * lazy.options.preLoad && rect.bottom > 0 && rect.left < window.innerWidth * lazy.options.preLoad && rect.right > 0;
    },
    load() {
      this.show = true;
      this.state.loaded = true;
      this.$emit("show", this);
    },
    destroy() {
      return this.$destroy;
    }
  }
});

// node_modules/vant/es/lazyload/vue-lazyload/lazy-container.js
var defaultOptions2 = {
  selector: "img"
};
var LazyContainer = class {
  constructor(_ref) {
    var {
      el,
      binding,
      vnode,
      lazy
    } = _ref;
    this.el = null;
    this.vnode = vnode;
    this.binding = binding;
    this.options = {};
    this.lazy = lazy;
    this.queue = [];
    this.update({
      el,
      binding
    });
  }
  update(_ref2) {
    var {
      el,
      binding
    } = _ref2;
    this.el = el;
    this.options = Object.assign({}, defaultOptions2, binding.value);
    var imgs = this.getImgs();
    imgs.forEach((el2) => {
      this.lazy.add(el2, Object.assign({}, this.binding, {
        value: {
          src: "dataset" in el2 ? el2.dataset.src : el2.getAttribute("data-src"),
          error: ("dataset" in el2 ? el2.dataset.error : el2.getAttribute("data-error")) || this.options.error,
          loading: ("dataset" in el2 ? el2.dataset.loading : el2.getAttribute("data-loading")) || this.options.loading
        }
      }), this.vnode);
    });
  }
  getImgs() {
    return Array.from(this.el.querySelectorAll(this.options.selector));
  }
  clear() {
    var imgs = this.getImgs();
    imgs.forEach((el) => this.lazy.remove(el));
    this.vnode = null;
    this.binding = null;
    this.lazy = null;
  }
};
var LazyContainerManager = class {
  constructor(_ref3) {
    var {
      lazy
    } = _ref3;
    this.lazy = lazy;
    this.queue = [];
  }
  bind(el, binding, vnode) {
    var container = new LazyContainer({
      el,
      binding,
      vnode,
      lazy: this.lazy
    });
    this.queue.push(container);
  }
  update(el, binding, vnode) {
    var container = this.queue.find((item) => item.el === el);
    if (!container)
      return;
    container.update({
      el,
      binding,
      vnode
    });
  }
  unbind(el) {
    var container = this.queue.find((item) => item.el === el);
    if (!container)
      return;
    container.clear();
    remove(this.queue, container);
  }
};

// node_modules/vant/es/lazyload/vue-lazyload/lazy-image.js
var lazy_image_default = (lazyManager) => ({
  props: {
    src: [String, Object],
    tag: {
      type: String,
      default: "img"
    }
  },
  render(h2) {
    return h2(this.tag, {
      attrs: {
        src: this.renderSrc
      }
    }, this.$slots.default);
  },
  data() {
    return {
      el: null,
      options: {
        src: "",
        error: "",
        loading: "",
        attempt: lazyManager.options.attempt
      },
      state: {
        loaded: false,
        error: false,
        attempt: 0
      },
      renderSrc: ""
    };
  },
  watch: {
    src() {
      this.init();
      lazyManager.addLazyBox(this);
      lazyManager.lazyLoadHandler();
    }
  },
  created() {
    this.init();
    this.renderSrc = this.options.loading;
  },
  mounted() {
    this.el = this.$el;
    lazyManager.addLazyBox(this);
    lazyManager.lazyLoadHandler();
  },
  beforeUnmount() {
    lazyManager.removeComponent(this);
  },
  methods: {
    init() {
      var {
        src,
        loading,
        error
      } = lazyManager.valueFormatter(this.src);
      this.state.loaded = false;
      this.options.src = src;
      this.options.error = error;
      this.options.loading = loading;
      this.renderSrc = this.options.loading;
    },
    checkInView() {
      var rect = useRect(this.$el);
      return rect.top < window.innerHeight * lazyManager.options.preLoad && rect.bottom > 0 && rect.left < window.innerWidth * lazyManager.options.preLoad && rect.right > 0;
    },
    load(onFinish) {
      if (onFinish === void 0) {
        onFinish = noop;
      }
      if (this.state.attempt > this.options.attempt - 1 && this.state.error) {
        if (!lazyManager.options.silent) {
          console.log("[@vant/lazyload] " + this.options.src + " tried too more than " + this.options.attempt + " times");
        }
        onFinish();
        return;
      }
      var {
        src
      } = this.options;
      loadImageAsync({
        src
      }, (_ref) => {
        var {
          src: src2
        } = _ref;
        this.renderSrc = src2;
        this.state.loaded = true;
      }, () => {
        this.state.attempt++;
        this.renderSrc = this.options.error;
        this.state.error = true;
      });
    }
  }
});

// node_modules/vant/es/lazyload/vue-lazyload/index.js
var Lazyload = {
  install(app, options) {
    if (options === void 0) {
      options = {};
    }
    var LazyClass = lazy_default();
    var lazy = new LazyClass(options);
    var lazyContainer = new LazyContainerManager({
      lazy
    });
    app.config.globalProperties.$Lazyload = lazy;
    if (options.lazyComponent) {
      app.component("LazyComponent", lazy_component_default(lazy));
    }
    if (options.lazyImage) {
      app.component("LazyImage", lazy_image_default(lazy));
    }
    app.directive("lazy", {
      beforeMount: lazy.add.bind(lazy),
      updated: lazy.update.bind(lazy),
      unmounted: lazy.remove.bind(lazy)
    });
    app.directive("lazy-container", {
      beforeMount: lazyContainer.bind.bind(lazyContainer),
      updated: lazyContainer.update.bind(lazyContainer),
      unmounted: lazyContainer.unbind.bind(lazyContainer)
    });
  }
};

// node_modules/vant/es/list/List.js
var [name69, bem65, t14] = createNamespace("list");
var listProps = {
  error: Boolean,
  offset: makeNumericProp(300),
  loading: Boolean,
  finished: Boolean,
  errorText: String,
  direction: makeStringProp("down"),
  loadingText: String,
  finishedText: String,
  immediateCheck: truthProp
};
var List_default = defineComponent({
  name: name69,
  props: listProps,
  emits: ["load", "update:error", "update:loading"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var loading = ref(false);
    var root = ref();
    var placeholder = ref();
    var tabStatus = useTabStatus();
    var scrollParent = useScrollParent(root);
    var check = () => {
      nextTick(() => {
        if (loading.value || props.finished || props.error || (tabStatus == null ? void 0 : tabStatus.value) === false) {
          return;
        }
        var {
          offset: offset2,
          direction
        } = props;
        var scrollParentRect = useRect(scrollParent);
        if (!scrollParentRect.height || isHidden(root)) {
          return;
        }
        var isReachEdge = false;
        var placeholderRect = useRect(placeholder);
        if (direction === "up") {
          isReachEdge = scrollParentRect.top - placeholderRect.top <= offset2;
        } else {
          isReachEdge = placeholderRect.bottom - scrollParentRect.bottom <= offset2;
        }
        if (isReachEdge) {
          loading.value = true;
          emit("update:loading", true);
          emit("load");
        }
      });
    };
    var renderFinishedText = () => {
      if (props.finished) {
        var text = slots.finished ? slots.finished() : props.finishedText;
        if (text) {
          return createVNode("div", {
            "class": bem65("finished-text")
          }, [text]);
        }
      }
    };
    var clickErrorText = () => {
      emit("update:error", false);
      check();
    };
    var renderErrorText = () => {
      if (props.error) {
        var text = slots.error ? slots.error() : props.errorText;
        if (text) {
          return createVNode("div", {
            "role": "button",
            "class": bem65("error-text"),
            "tabindex": 0,
            "onClick": clickErrorText
          }, [text]);
        }
      }
    };
    var renderLoading = () => {
      if (loading.value && !props.finished) {
        return createVNode("div", {
          "class": bem65("loading")
        }, [slots.loading ? slots.loading() : createVNode(Loading, {
          "class": bem65("loading-icon")
        }, {
          default: () => [props.loadingText || t14("loading")]
        })]);
      }
    };
    watch(() => [props.loading, props.finished, props.error], check);
    if (tabStatus) {
      watch(tabStatus, (tabActive) => {
        if (tabActive) {
          check();
        }
      });
    }
    onUpdated(() => {
      loading.value = props.loading;
    });
    onMounted(() => {
      if (props.immediateCheck) {
        check();
      }
    });
    useExpose({
      check
    });
    useEventListener("scroll", check, {
      target: scrollParent
    });
    return () => {
      var Content = slots.default == null ? void 0 : slots.default();
      var Placeholder = createVNode("div", {
        "ref": placeholder,
        "class": bem65("placeholder")
      }, null);
      return createVNode("div", {
        "ref": root,
        "role": "feed",
        "class": bem65(),
        "aria-busy": loading.value
      }, [props.direction === "down" ? Content : Placeholder, renderLoading(), renderFinishedText(), renderErrorText(), props.direction === "up" ? Content : Placeholder]);
    };
  }
});

// node_modules/vant/es/list/index.js
var List = withInstall(List_default);

// node_modules/vant/es/composables/use-placeholder.js
function usePlaceholder(contentRef, bem92) {
  var height2 = useHeight(contentRef);
  return (renderContent) => createVNode("div", {
    "class": bem92("placeholder"),
    "style": {
      height: height2.value ? height2.value + "px" : void 0
    }
  }, [renderContent()]);
}

// node_modules/vant/es/nav-bar/NavBar.js
var [name70, bem66] = createNamespace("nav-bar");
var navBarProps = {
  title: String,
  fixed: Boolean,
  zIndex: numericProp,
  border: truthProp,
  leftText: String,
  rightText: String,
  leftArrow: Boolean,
  placeholder: Boolean,
  safeAreaInsetTop: Boolean
};
var NavBar_default = defineComponent({
  name: name70,
  props: navBarProps,
  emits: ["click-left", "click-right"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var navBarRef = ref();
    var renderPlaceholder = usePlaceholder(navBarRef, bem66);
    var onClickLeft = (event) => emit("click-left", event);
    var onClickRight = (event) => emit("click-right", event);
    var renderLeft = () => {
      if (slots.left) {
        return slots.left();
      }
      return [props.leftArrow && createVNode(Icon, {
        "class": bem66("arrow"),
        "name": "arrow-left"
      }, null), props.leftText && createVNode("span", {
        "class": bem66("text")
      }, [props.leftText])];
    };
    var renderRight = () => {
      if (slots.right) {
        return slots.right();
      }
      return createVNode("span", {
        "class": bem66("text")
      }, [props.rightText]);
    };
    var renderNavBar = () => {
      var {
        title,
        fixed,
        border,
        zIndex
      } = props;
      var style = getZIndexStyle(zIndex);
      var hasLeft = props.leftArrow || props.leftText || slots.left;
      var hasRight = props.rightText || slots.right;
      return createVNode("div", {
        "ref": navBarRef,
        "style": style,
        "class": [bem66({
          fixed,
          "safe-area-inset-top": props.safeAreaInsetTop
        }), {
          [BORDER_BOTTOM]: border
        }]
      }, [createVNode("div", {
        "class": bem66("content")
      }, [hasLeft && createVNode("div", {
        "class": [bem66("left"), HAPTICS_FEEDBACK],
        "onClick": onClickLeft
      }, [renderLeft()]), createVNode("div", {
        "class": [bem66("title"), "van-ellipsis"]
      }, [slots.title ? slots.title() : title]), hasRight && createVNode("div", {
        "class": [bem66("right"), HAPTICS_FEEDBACK],
        "onClick": onClickRight
      }, [renderRight()])])]);
    };
    return () => {
      if (props.fixed && props.placeholder) {
        return renderPlaceholder(renderNavBar);
      }
      return renderNavBar();
    };
  }
});

// node_modules/vant/es/nav-bar/index.js
var NavBar = withInstall(NavBar_default);

// node_modules/vant/es/notice-bar/NoticeBar.js
var [name71, bem67] = createNamespace("notice-bar");
var noticeBarProps = {
  text: String,
  mode: String,
  color: String,
  delay: makeNumericProp(1),
  speed: makeNumericProp(60),
  leftIcon: String,
  wrapable: Boolean,
  background: String,
  scrollable: {
    type: Boolean,
    default: null
  }
};
var NoticeBar_default = defineComponent({
  name: name71,
  props: noticeBarProps,
  emits: ["close", "replay"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var wrapWidth = 0;
    var contentWidth = 0;
    var startTimer;
    var wrapRef = ref();
    var contentRef = ref();
    var state = reactive({
      show: true,
      offset: 0,
      duration: 0
    });
    var renderLeftIcon = () => {
      if (slots["left-icon"]) {
        return slots["left-icon"]();
      }
      if (props.leftIcon) {
        return createVNode(Icon, {
          "class": bem67("left-icon"),
          "name": props.leftIcon
        }, null);
      }
    };
    var getRightIconName = () => {
      if (props.mode === "closeable") {
        return "cross";
      }
      if (props.mode === "link") {
        return "arrow";
      }
    };
    var onClickRightIcon = (event) => {
      if (props.mode === "closeable") {
        state.show = false;
        emit("close", event);
      }
    };
    var renderRightIcon = () => {
      if (slots["right-icon"]) {
        return slots["right-icon"]();
      }
      var name96 = getRightIconName();
      if (name96) {
        return createVNode(Icon, {
          "name": name96,
          "class": bem67("right-icon"),
          "onClick": onClickRightIcon
        }, null);
      }
    };
    var onTransitionEnd = () => {
      state.offset = wrapWidth;
      state.duration = 0;
      raf(() => {
        doubleRaf(() => {
          state.offset = -contentWidth;
          state.duration = (contentWidth + wrapWidth) / +props.speed;
          emit("replay");
        });
      });
    };
    var renderMarquee = () => {
      var ellipsis = props.scrollable === false && !props.wrapable;
      var style = {
        transform: state.offset ? "translateX(" + state.offset + "px)" : "",
        transitionDuration: state.duration + "s"
      };
      return createVNode("div", {
        "ref": wrapRef,
        "role": "marquee",
        "class": bem67("wrap")
      }, [createVNode("div", {
        "ref": contentRef,
        "style": style,
        "class": [bem67("content"), {
          "van-ellipsis": ellipsis
        }],
        "onTransitionend": onTransitionEnd
      }, [slots.default ? slots.default() : props.text])]);
    };
    var reset = () => {
      var {
        delay,
        speed,
        scrollable
      } = props;
      var ms = isDef(delay) ? +delay * 1e3 : 0;
      wrapWidth = 0;
      contentWidth = 0;
      state.offset = 0;
      state.duration = 0;
      clearTimeout(startTimer);
      startTimer = setTimeout(() => {
        if (!wrapRef.value || !contentRef.value || scrollable === false) {
          return;
        }
        var wrapRefWidth = useRect(wrapRef).width;
        var contentRefWidth = useRect(contentRef).width;
        if (scrollable || contentRefWidth > wrapRefWidth) {
          doubleRaf(() => {
            wrapWidth = wrapRefWidth;
            contentWidth = contentRefWidth;
            state.offset = -contentWidth;
            state.duration = contentWidth / +speed;
          });
        }
      }, ms);
    };
    onPopupReopen(reset);
    onMountedOrActivated(reset);
    useEventListener("pageshow", reset);
    useExpose({
      reset
    });
    watch(() => [props.text, props.scrollable], reset);
    return () => {
      var {
        color,
        wrapable,
        background
      } = props;
      return withDirectives(createVNode("div", {
        "role": "alert",
        "class": bem67({
          wrapable
        }),
        "style": {
          color,
          background
        }
      }, [renderLeftIcon(), renderMarquee(), renderRightIcon()]), [[vShow, state.show]]);
    };
  }
});

// node_modules/vant/es/notice-bar/index.js
var NoticeBar = withInstall(NoticeBar_default);

// node_modules/vant/es/notify/Notify.js
var [name72, bem68] = createNamespace("notify");
var notifyProps = extend({}, popupSharedProps, {
  type: makeStringProp("danger"),
  color: String,
  message: numericProp,
  className: unknownProp,
  background: String,
  lockScroll: Boolean
});
var Notify_default = defineComponent({
  name: name72,
  props: notifyProps,
  emits: ["update:show"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var updateShow = (show) => emit("update:show", show);
    return () => createVNode(Popup, {
      "show": props.show,
      "class": [bem68([props.type]), props.className],
      "style": {
        color: props.color,
        background: props.background
      },
      "overlay": false,
      "position": "top",
      "duration": 0.2,
      "lockScroll": props.lockScroll,
      "onUpdate:show": updateShow
    }, {
      default: () => [slots.default ? slots.default() : props.message]
    });
  }
});

// node_modules/vant/es/notify/function-call.js
var timer;
var instance3;
var parseOptions2 = (message) => isObject(message) ? message : {
  message
};
function initInstance3() {
  ({
    instance: instance3
  } = mountComponent({
    setup() {
      var {
        state,
        toggle
      } = usePopupState();
      return () => createVNode(Notify_default, mergeProps(state, {
        "onUpdate:show": toggle
      }), null);
    }
  }));
}
function Notify(options) {
  if (!inBrowser) {
    return;
  }
  if (!instance3) {
    initInstance3();
  }
  options = extend({}, Notify.currentOptions, parseOptions2(options));
  instance3.open(options);
  clearTimeout(timer);
  if (options.duration > 0) {
    timer = window.setTimeout(Notify.clear, options.duration);
  }
  return instance3;
}
var getDefaultOptions = () => ({
  type: "danger",
  color: void 0,
  message: "",
  onClose: void 0,
  onClick: void 0,
  onOpened: void 0,
  duration: 3e3,
  className: "",
  lockScroll: false,
  background: void 0
});
Notify.clear = () => {
  if (instance3) {
    instance3.toggle(false);
  }
};
Notify.currentOptions = getDefaultOptions();
Notify.setDefaultOptions = (options) => {
  extend(Notify.currentOptions, options);
};
Notify.resetDefaultOptions = () => {
  Notify.currentOptions = getDefaultOptions();
};
Notify.Component = withInstall(Notify_default);
Notify.install = (app) => {
  app.use(Notify.Component);
  app.config.globalProperties.$notify = Notify;
};

// node_modules/vant/es/number-keyboard/NumberKeyboardKey.js
var [name73, bem69] = createNamespace("key");
var CollapseIcon = createVNode("svg", {
  "class": bem69("collapse-icon"),
  "viewBox": "0 0 30 24"
}, [createVNode("path", {
  "d": "M26 13h-2v2h2v-2zm-8-3h2V8h-2v2zm2-4h2V4h-2v2zm2 4h4V4h-2v4h-2v2zm-7 14 3-3h-6l3 3zM6 13H4v2h2v-2zm16 0H8v2h14v-2zm-12-3h2V8h-2v2zM28 0l1 1 1 1v15l-1 2H1l-1-2V2l1-1 1-1zm0 2H2v15h26V2zM6 4v2H4V4zm10 2h2V4h-2v2zM8 9v1H4V8zm8 0v1h-2V8zm-6-5v2H8V4zm4 0v2h-2V4z",
  "fill": "currentColor"
}, null)]);
var DeleteIcon = createVNode("svg", {
  "class": bem69("delete-icon"),
  "viewBox": "0 0 32 22"
}, [createVNode("path", {
  "d": "M28 0a4 4 0 0 1 4 4v14a4 4 0 0 1-4 4H10.4a2 2 0 0 1-1.4-.6L1 13.1c-.6-.5-.9-1.3-.9-2 0-1 .3-1.7.9-2.2L9 .6a2 2 0 0 1 1.4-.6zm0 2H10.4l-8.2 8.3a1 1 0 0 0-.3.7c0 .3.1.5.3.7l8.2 8.4H28a2 2 0 0 0 2-2V4c0-1.1-.9-2-2-2zm-5 4a1 1 0 0 1 .7.3 1 1 0 0 1 0 1.4L20.4 11l3.3 3.3c.2.2.3.5.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3L19 12.4l-3.4 3.3a1 1 0 0 1-.6.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.2.1-.5.3-.7l3.3-3.3-3.3-3.3A1 1 0 0 1 14 7c0-.3.1-.5.3-.7A1 1 0 0 1 15 6a1 1 0 0 1 .6.3L19 9.6l3.3-3.3A1 1 0 0 1 23 6z",
  "fill": "currentColor"
}, null)]);
var NumberKeyboardKey_default = defineComponent({
  name: name73,
  props: {
    type: String,
    text: numericProp,
    color: String,
    wider: Boolean,
    large: Boolean,
    loading: Boolean
  },
  emits: ["press"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var active = ref(false);
    var touch = useTouch();
    var onTouchStart = (event) => {
      touch.start(event);
      active.value = true;
    };
    var onTouchMove = (event) => {
      touch.move(event);
      if (touch.direction.value) {
        active.value = false;
      }
    };
    var onTouchEnd = (event) => {
      if (active.value) {
        if (!slots.default) {
          preventDefault(event);
        }
        active.value = false;
        emit("press", props.text, props.type);
      }
    };
    var renderContent = () => {
      if (props.loading) {
        return createVNode(Loading, {
          "class": bem69("loading-icon")
        }, null);
      }
      var text = slots.default ? slots.default() : props.text;
      switch (props.type) {
        case "delete":
          return text || DeleteIcon;
        case "extra":
          return text || CollapseIcon;
        default:
          return text;
      }
    };
    return () => createVNode("div", {
      "class": bem69("wrapper", {
        wider: props.wider
      }),
      "onTouchstart": onTouchStart,
      "onTouchmove": onTouchMove,
      "onTouchend": onTouchEnd,
      "onTouchcancel": onTouchEnd
    }, [createVNode("div", {
      "role": "button",
      "tabindex": 0,
      "class": bem69([props.color, {
        large: props.large,
        active: active.value,
        delete: props.type === "delete"
      }])
    }, [renderContent()])]);
  }
});

// node_modules/vant/es/number-keyboard/NumberKeyboard.js
var [name74, bem70] = createNamespace("number-keyboard");
var numberKeyboardProps = {
  show: Boolean,
  title: String,
  theme: makeStringProp("default"),
  zIndex: numericProp,
  teleport: [String, Object],
  maxlength: makeNumericProp(Infinity),
  modelValue: makeStringProp(""),
  transition: truthProp,
  blurOnClose: truthProp,
  showDeleteKey: truthProp,
  randomKeyOrder: Boolean,
  closeButtonText: String,
  deleteButtonText: String,
  closeButtonLoading: Boolean,
  hideOnClickOutside: truthProp,
  safeAreaInsetBottom: truthProp,
  extraKey: {
    type: [String, Array],
    default: ""
  }
};
var NumberKeyboard_default = defineComponent({
  name: name74,
  props: numberKeyboardProps,
  emits: ["show", "hide", "blur", "input", "close", "delete", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var root = ref();
    var genBasicKeys = () => {
      var keys2 = Array(9).fill("").map((_, i) => ({
        text: i + 1
      }));
      if (props.randomKeyOrder) {
        keys2.sort(() => Math.random() > 0.5 ? 1 : -1);
      }
      return keys2;
    };
    var genDefaultKeys = () => [...genBasicKeys(), {
      text: props.extraKey,
      type: "extra"
    }, {
      text: 0
    }, {
      text: props.showDeleteKey ? props.deleteButtonText : "",
      type: props.showDeleteKey ? "delete" : ""
    }];
    var genCustomKeys = () => {
      var keys2 = genBasicKeys();
      var {
        extraKey
      } = props;
      var extraKeys = Array.isArray(extraKey) ? extraKey : [extraKey];
      if (extraKeys.length === 1) {
        keys2.push({
          text: 0,
          wider: true
        }, {
          text: extraKeys[0],
          type: "extra"
        });
      } else if (extraKeys.length === 2) {
        keys2.push({
          text: extraKeys[0],
          type: "extra"
        }, {
          text: 0
        }, {
          text: extraKeys[1],
          type: "extra"
        });
      }
      return keys2;
    };
    var keys = computed(() => props.theme === "custom" ? genCustomKeys() : genDefaultKeys());
    var onBlur = () => {
      if (props.show) {
        emit("blur");
      }
    };
    var onClose = () => {
      emit("close");
      if (props.blurOnClose) {
        onBlur();
      }
    };
    var onAnimationEnd = () => emit(props.show ? "show" : "hide");
    var onPress = (text, type) => {
      if (text === "") {
        if (type === "extra") {
          onBlur();
        }
        return;
      }
      var value = props.modelValue;
      if (type === "delete") {
        emit("delete");
        emit("update:modelValue", value.slice(0, value.length - 1));
      } else if (type === "close") {
        onClose();
      } else if (value.length < props.maxlength) {
        emit("input", text);
        emit("update:modelValue", value + text);
      }
    };
    var renderTitle = () => {
      var {
        title,
        theme,
        closeButtonText
      } = props;
      var leftSlot = slots["title-left"];
      var showClose = closeButtonText && theme === "default";
      var showTitle = title || showClose || leftSlot;
      if (!showTitle) {
        return;
      }
      return createVNode("div", {
        "class": bem70("header")
      }, [leftSlot && createVNode("span", {
        "class": bem70("title-left")
      }, [leftSlot()]), title && createVNode("h2", {
        "class": bem70("title")
      }, [title]), showClose && createVNode("button", {
        "type": "button",
        "class": [bem70("close"), HAPTICS_FEEDBACK],
        "onClick": onClose
      }, [closeButtonText])]);
    };
    var renderKeys = () => keys.value.map((key) => {
      var keySlots = {};
      if (key.type === "delete") {
        keySlots.default = slots.delete;
      }
      if (key.type === "extra") {
        keySlots.default = slots["extra-key"];
      }
      return createVNode(NumberKeyboardKey_default, {
        "key": key.text,
        "text": key.text,
        "type": key.type,
        "wider": key.wider,
        "color": key.color,
        "onPress": onPress
      }, keySlots);
    });
    var renderSidebar = () => {
      if (props.theme === "custom") {
        return createVNode("div", {
          "class": bem70("sidebar")
        }, [props.showDeleteKey && createVNode(NumberKeyboardKey_default, {
          "large": true,
          "text": props.deleteButtonText,
          "type": "delete",
          "onPress": onPress
        }, {
          delete: slots.delete
        }), createVNode(NumberKeyboardKey_default, {
          "large": true,
          "text": props.closeButtonText,
          "type": "close",
          "color": "blue",
          "loading": props.closeButtonLoading,
          "onPress": onPress
        }, null)]);
      }
    };
    watch(() => props.show, (value) => {
      if (!props.transition) {
        emit(value ? "show" : "hide");
      }
    });
    if (props.hideOnClickOutside) {
      useClickAway(root, onBlur, {
        eventName: "touchstart"
      });
    }
    return () => {
      var Title = renderTitle();
      var Content = createVNode(Transition, {
        "name": props.transition ? "van-slide-up" : ""
      }, {
        default: () => [withDirectives(createVNode("div", {
          "ref": root,
          "style": getZIndexStyle(props.zIndex),
          "class": bem70({
            unfit: !props.safeAreaInsetBottom,
            "with-title": !!Title
          }),
          "onTouchstart": stopPropagation,
          "onAnimationend": onAnimationEnd,
          "onWebkitAnimationEnd": onAnimationEnd
        }, [Title, createVNode("div", {
          "class": bem70("body")
        }, [createVNode("div", {
          "class": bem70("keys")
        }, [renderKeys()]), renderSidebar()])]), [[vShow, props.show]])]
      });
      if (props.teleport) {
        return createVNode(Teleport, {
          "to": props.teleport
        }, {
          default: () => [Content]
        });
      }
      return Content;
    };
  }
});

// node_modules/vant/es/number-keyboard/index.js
var NumberKeyboard = withInstall(NumberKeyboard_default);

// node_modules/vant/es/pagination/Pagination.js
var [name75, bem71, t15] = createNamespace("pagination");
var makePage = (number, text, active) => ({
  number,
  text,
  active
});
var paginationProps = {
  mode: makeStringProp("multi"),
  prevText: String,
  nextText: String,
  pageCount: makeNumericProp(0),
  modelValue: makeNumberProp(0),
  totalItems: makeNumericProp(0),
  showPageSize: makeNumericProp(5),
  itemsPerPage: makeNumericProp(10),
  forceEllipses: Boolean
};
var Pagination_default = defineComponent({
  name: name75,
  props: paginationProps,
  emits: ["change", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var count = computed(() => {
      var {
        pageCount,
        totalItems,
        itemsPerPage
      } = props;
      var count2 = +pageCount || Math.ceil(+totalItems / +itemsPerPage);
      return Math.max(1, count2);
    });
    var pages = computed(() => {
      var items = [];
      var pageCount = count.value;
      var showPageSize = +props.showPageSize;
      var {
        modelValue,
        forceEllipses
      } = props;
      var startPage = 1;
      var endPage = pageCount;
      var isMaxSized = showPageSize < pageCount;
      if (isMaxSized) {
        startPage = Math.max(modelValue - Math.floor(showPageSize / 2), 1);
        endPage = startPage + showPageSize - 1;
        if (endPage > pageCount) {
          endPage = pageCount;
          startPage = endPage - showPageSize + 1;
        }
      }
      for (var number = startPage; number <= endPage; number++) {
        var page = makePage(number, number, number === modelValue);
        items.push(page);
      }
      if (isMaxSized && showPageSize > 0 && forceEllipses) {
        if (startPage > 1) {
          var prevPages = makePage(startPage - 1, "...");
          items.unshift(prevPages);
        }
        if (endPage < pageCount) {
          var nextPages = makePage(endPage + 1, "...");
          items.push(nextPages);
        }
      }
      return items;
    });
    var updateModelValue = (value, emitChange) => {
      value = clamp(value, 1, count.value);
      if (props.modelValue !== value) {
        emit("update:modelValue", value);
        if (emitChange) {
          emit("change", value);
        }
      }
    };
    watchEffect(() => updateModelValue(props.modelValue));
    var renderDesc = () => createVNode("li", {
      "class": bem71("page-desc")
    }, [slots.pageDesc ? slots.pageDesc() : props.modelValue + "/" + count.value]);
    var renderPrevButton = () => {
      var {
        mode,
        modelValue
      } = props;
      var slot = slots["prev-text"];
      var disabled = modelValue === 1;
      return createVNode("li", {
        "class": [bem71("item", {
          disabled,
          border: mode === "simple",
          prev: true
        }), BORDER_SURROUND]
      }, [createVNode("button", {
        "type": "button",
        "disabled": disabled,
        "onClick": () => updateModelValue(modelValue - 1, true)
      }, [slot ? slot() : props.prevText || t15("prev")])]);
    };
    var renderNextButton = () => {
      var {
        mode,
        modelValue
      } = props;
      var slot = slots["next-text"];
      var disabled = modelValue === count.value;
      return createVNode("li", {
        "class": [bem71("item", {
          disabled,
          border: mode === "simple",
          next: true
        }), BORDER_SURROUND]
      }, [createVNode("button", {
        "type": "button",
        "disabled": disabled,
        "onClick": () => updateModelValue(modelValue + 1, true)
      }, [slot ? slot() : props.nextText || t15("next")])]);
    };
    var renderPages = () => pages.value.map((page) => createVNode("li", {
      "class": [bem71("item", {
        active: page.active,
        page: true
      }), BORDER_SURROUND]
    }, [createVNode("button", {
      "type": "button",
      "aria-current": page.active || void 0,
      "onClick": () => updateModelValue(page.number, true)
    }, [slots.page ? slots.page(page) : page.text])]));
    return () => createVNode("nav", {
      "role": "navigation",
      "class": bem71()
    }, [createVNode("ul", {
      "class": bem71("items")
    }, [renderPrevButton(), props.mode === "simple" ? renderDesc() : renderPages(), renderNextButton()])]);
  }
});

// node_modules/vant/es/pagination/index.js
var Pagination = withInstall(Pagination_default);

// node_modules/vant/es/password-input/PasswordInput.js
var [name76, bem72] = createNamespace("password-input");
var passwordInputProps = {
  info: String,
  mask: truthProp,
  value: makeStringProp(""),
  gutter: numericProp,
  length: makeNumericProp(6),
  focused: Boolean,
  errorInfo: String
};
var PasswordInput_default = defineComponent({
  name: name76,
  props: passwordInputProps,
  emits: ["focus"],
  setup(props, _ref) {
    var {
      emit
    } = _ref;
    var onTouchStart = (event) => {
      event.stopPropagation();
      emit("focus", event);
    };
    var renderPoints = () => {
      var Points = [];
      var {
        mask,
        value,
        length,
        gutter,
        focused
      } = props;
      for (var i = 0; i < length; i++) {
        var char = value[i];
        var showBorder = i !== 0 && !gutter;
        var showCursor = focused && i === value.length;
        var style = void 0;
        if (i !== 0 && gutter) {
          style = {
            marginLeft: addUnit(gutter)
          };
        }
        Points.push(createVNode("li", {
          "class": [{
            [BORDER_LEFT]: showBorder
          }, bem72("item", {
            focus: showCursor
          })],
          "style": style
        }, [mask ? createVNode("i", {
          "style": {
            visibility: char ? "visible" : "hidden"
          }
        }, null) : char, showCursor && createVNode("div", {
          "class": bem72("cursor")
        }, null)]));
      }
      return Points;
    };
    return () => {
      var info = props.errorInfo || props.info;
      return createVNode("div", {
        "class": bem72()
      }, [createVNode("ul", {
        "class": [bem72("security"), {
          [BORDER_SURROUND]: !props.gutter
        }],
        "onTouchstart": onTouchStart
      }, [renderPoints()]), info && createVNode("div", {
        "class": bem72(props.errorInfo ? "error-info" : "info")
      }, [info])]);
    };
  }
});

// node_modules/vant/es/password-input/index.js
var PasswordInput = withInstall(PasswordInput_default);

// node_modules/@vant/popperjs/dist/esm/index.js
function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function isElement2(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getDocumentElement(element) {
  return ((isElement2(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement);
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getScrollParent2(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent2(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent2(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var placements = [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function format2(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    Object.keys(modifier).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format2(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (typeof modifier.effect !== "function") {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (!Array.isArray(modifier.requires)) {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format2(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}
function uniqueBy(arr, fn2) {
  var identifiers = new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current2) {
    var existing = merged2[current2.name];
    merged2[current2.name] = existing ? Object.assign({}, existing, current2, {
      options: Object.assign({}, existing.options, current2.options),
      data: Object.assign({}, existing.data, current2.data)
    }) : current2;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var round = Math.round;
function getVariation(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function computeOffsets(_ref) {
  var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions3 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions3;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions3),
      modifiersData: {},
      elements: {
        reference,
        popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance4 = {
      state,
      setOptions: function setOptions(options2) {
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions3, state.options, options2);
        state.scrollParents = {
          reference: isElement2(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name96 = _ref.name;
            return name96;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name96 = _ref2.name;
              return name96 === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle(popper), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance4.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference2 = _state$elements.reference, popper2 = _state$elements.popper;
        if (!areValidElements(reference2, popper2)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference2, getOffsetParent(popper2), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper2)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name96 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name: name96,
              instance: instance4
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance4.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference, popper)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance4;
    }
    instance4.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name96 = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name: name96,
            instance: instance4,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance4;
  };
}
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance4 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance4.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance4.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance4.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance4.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
function popperOffsets(_ref) {
  var state = _ref.state, name96 = _ref.name;
  state.modifiersData[name96] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(round(x * dpr) / dpr) || 0,
    y: round(round(y * dpr) / dpr) || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets;
  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y = _ref3$y === void 0 ? 0 : _ref3$y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);
      if (getComputedStyle(offsetParent).position !== "static") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top) {
      sideY = bottom;
      y -= offsetParent[heightProp] - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left) {
      sideX = right;
      x -= offsetParent[widthProp] - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref4) {
  var state = _ref4.state, options = _ref4.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name96) {
    var style = state.styles[name96] || {};
    var attributes = state.attributes[name96] || {};
    var element = state.elements[name96];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name97) {
      var value = attributes[name97];
      if (value === false) {
        element.removeAttribute(name97);
      } else {
        element.setAttribute(name97, value === true ? "" : value);
      }
    });
  });
}
function effect$1(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name96) {
      var element = state.elements[name96];
      var attributes = state.attributes[name96] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name96) ? state.styles[name96] : initialStyles[name96]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$1,
  requires: ["computeStyles"]
};
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper = popperGenerator({
  defaultModifiers
});
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name96 = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name96] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/vant/es/popover/Popover.js
var [name77, bem73] = createNamespace("popover");
var popupProps3 = ["show", "overlay", "duration", "teleport", "overlayStyle", "overlayClass", "closeOnClickOverlay"];
var popoverProps = {
  show: Boolean,
  theme: makeStringProp("light"),
  overlay: Boolean,
  actions: makeArrayProp(),
  trigger: makeStringProp("click"),
  duration: numericProp,
  showArrow: truthProp,
  placement: makeStringProp("bottom"),
  iconPrefix: String,
  overlayClass: unknownProp,
  overlayStyle: Object,
  closeOnClickAction: truthProp,
  closeOnClickOverlay: truthProp,
  closeOnClickOutside: truthProp,
  offset: {
    type: Array,
    default: () => [0, 8]
  },
  teleport: {
    type: [String, Object],
    default: "body"
  }
};
var Popover_default = defineComponent({
  name: name77,
  props: popoverProps,
  emits: ["select", "touchstart", "update:show"],
  setup(props, _ref) {
    var {
      emit,
      slots,
      attrs
    } = _ref;
    var popper;
    var wrapperRef = ref();
    var popoverRef = ref();
    var createPopperInstance = () => {
      if (wrapperRef.value && popoverRef.value) {
        return createPopper(wrapperRef.value, popoverRef.value.popupRef.value, {
          placement: props.placement,
          modifiers: [{
            name: "computeStyles",
            options: {
              adaptive: false,
              gpuAcceleration: false
            }
          }, extend({}, offset$1, {
            options: {
              offset: props.offset
            }
          })]
        });
      }
      return null;
    };
    var updateLocation = () => {
      nextTick(() => {
        if (!props.show) {
          return;
        }
        if (!popper) {
          popper = createPopperInstance();
        } else {
          popper.setOptions({
            placement: props.placement
          });
        }
      });
    };
    var updateShow = (value) => emit("update:show", value);
    var onClickWrapper = () => {
      if (props.trigger === "click") {
        updateShow(!props.show);
      }
    };
    var onTouchstart = (event) => {
      event.stopPropagation();
      emit("touchstart", event);
    };
    var onClickAction = (action, index) => {
      if (action.disabled) {
        return;
      }
      emit("select", action, index);
      if (props.closeOnClickAction) {
        updateShow(false);
      }
    };
    var onClickAway = () => {
      if (props.closeOnClickOutside && (!props.overlay || props.closeOnClickOverlay)) {
        updateShow(false);
      }
    };
    var renderAction = (action, index) => {
      var {
        icon,
        text,
        color,
        disabled,
        className
      } = action;
      return createVNode("div", {
        "role": "menuitem",
        "class": [bem73("action", {
          disabled,
          "with-icon": icon
        }), className],
        "style": {
          color
        },
        "tabindex": disabled ? void 0 : 0,
        "aria-disabled": disabled || void 0,
        "onClick": () => onClickAction(action, index)
      }, [icon && createVNode(Icon, {
        "name": icon,
        "classPrefix": props.iconPrefix,
        "class": bem73("action-icon")
      }, null), createVNode("div", {
        "class": [bem73("action-text"), BORDER_BOTTOM]
      }, [text])]);
    };
    onMounted(updateLocation);
    onBeforeUnmount(() => {
      if (popper) {
        popper.destroy();
        popper = null;
      }
    });
    watch(() => [props.show, props.placement], updateLocation);
    useClickAway(wrapperRef, onClickAway, {
      eventName: "touchstart"
    });
    return () => createVNode(Fragment, null, [createVNode("span", {
      "ref": wrapperRef,
      "class": bem73("wrapper"),
      "onClick": onClickWrapper
    }, [slots.reference == null ? void 0 : slots.reference()]), createVNode(Popup, mergeProps({
      "ref": popoverRef,
      "class": bem73([props.theme]),
      "position": "",
      "transition": "van-popover-zoom",
      "lockScroll": false,
      "onTouchstart": onTouchstart,
      "onUpdate:show": updateShow
    }, attrs, pick(props, popupProps3)), {
      default: () => [props.showArrow && createVNode("div", {
        "class": bem73("arrow")
      }, null), createVNode("div", {
        "role": "menu",
        "class": bem73("content")
      }, [slots.default ? slots.default() : props.actions.map(renderAction)])]
    })]);
  }
});

// node_modules/vant/es/popover/index.js
var Popover = withInstall(Popover_default);

// node_modules/vant/es/progress/Progress.js
var [name78, bem74] = createNamespace("progress");
var progressProps = {
  color: String,
  inactive: Boolean,
  pivotText: String,
  textColor: String,
  showPivot: truthProp,
  pivotColor: String,
  trackColor: String,
  strokeWidth: numericProp,
  percentage: {
    type: numericProp,
    default: 0,
    validator: (value) => value >= 0 && value <= 100
  }
};
var Progress_default = defineComponent({
  name: name78,
  props: progressProps,
  setup(props) {
    var background = computed(() => props.inactive ? void 0 : props.color);
    var renderPivot = () => {
      var {
        textColor,
        pivotText,
        pivotColor,
        percentage
      } = props;
      var text = pivotText != null ? pivotText : percentage + "%";
      if (props.showPivot && text) {
        var style = {
          color: textColor,
          left: +percentage + "%",
          transform: "translate(-" + +percentage + "%,-50%)",
          background: pivotColor || background.value
        };
        return createVNode("span", {
          "style": style,
          "class": bem74("pivot", {
            inactive: props.inactive
          })
        }, [text]);
      }
    };
    return () => {
      var {
        trackColor,
        percentage,
        strokeWidth
      } = props;
      var rootStyle = {
        background: trackColor,
        height: addUnit(strokeWidth)
      };
      var portionStyle = {
        width: percentage + "%",
        background: background.value
      };
      return createVNode("div", {
        "class": bem74(),
        "style": rootStyle
      }, [createVNode("span", {
        "class": bem74("portion", {
          inactive: props.inactive
        }),
        "style": portionStyle
      }, null), renderPivot()]);
    };
  }
});

// node_modules/vant/es/progress/index.js
var Progress = withInstall(Progress_default);

// node_modules/vant/es/pull-refresh/PullRefresh.js
var [name79, bem75, t16] = createNamespace("pull-refresh");
var DEFAULT_HEAD_HEIGHT = 50;
var TEXT_STATUS = ["pulling", "loosing", "success"];
var pullRefreshProps = {
  disabled: Boolean,
  modelValue: Boolean,
  headHeight: makeNumericProp(DEFAULT_HEAD_HEIGHT),
  successText: String,
  pullingText: String,
  loosingText: String,
  loadingText: String,
  pullDistance: numericProp,
  successDuration: makeNumericProp(500),
  animationDuration: makeNumericProp(300)
};
var PullRefresh_default = defineComponent({
  name: name79,
  props: pullRefreshProps,
  emits: ["refresh", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var reachTop;
    var root = ref();
    var scrollParent = useScrollParent(root);
    var state = reactive({
      status: "normal",
      distance: 0,
      duration: 0
    });
    var touch = useTouch();
    var getHeadStyle = () => {
      if (props.headHeight !== DEFAULT_HEAD_HEIGHT) {
        return {
          height: props.headHeight + "px"
        };
      }
    };
    var isTouchable = () => state.status !== "loading" && state.status !== "success" && !props.disabled;
    var ease = (distance) => {
      var pullDistance = +(props.pullDistance || props.headHeight);
      if (distance > pullDistance) {
        if (distance < pullDistance * 2) {
          distance = pullDistance + (distance - pullDistance) / 2;
        } else {
          distance = pullDistance * 1.5 + (distance - pullDistance * 2) / 4;
        }
      }
      return Math.round(distance);
    };
    var setStatus = (distance, isLoading) => {
      var pullDistance = +(props.pullDistance || props.headHeight);
      state.distance = distance;
      if (isLoading) {
        state.status = "loading";
      } else if (distance === 0) {
        state.status = "normal";
      } else if (distance < pullDistance) {
        state.status = "pulling";
      } else {
        state.status = "loosing";
      }
    };
    var getStatusText = () => {
      var {
        status
      } = state;
      if (status === "normal") {
        return "";
      }
      return props[status + "Text"] || t16(status);
    };
    var renderStatus = () => {
      var {
        status,
        distance
      } = state;
      if (slots[status]) {
        return slots[status]({
          distance
        });
      }
      var nodes = [];
      if (TEXT_STATUS.includes(status)) {
        nodes.push(createVNode("div", {
          "class": bem75("text")
        }, [getStatusText()]));
      }
      if (status === "loading") {
        nodes.push(createVNode(Loading, {
          "class": bem75("loading")
        }, {
          default: getStatusText
        }));
      }
      return nodes;
    };
    var showSuccessTip = () => {
      state.status = "success";
      setTimeout(() => {
        setStatus(0);
      }, +props.successDuration);
    };
    var checkPosition = (event) => {
      reachTop = getScrollTop(scrollParent.value) === 0;
      if (reachTop) {
        state.duration = 0;
        touch.start(event);
      }
    };
    var onTouchStart = (event) => {
      if (isTouchable()) {
        checkPosition(event);
      }
    };
    var onTouchMove = (event) => {
      if (isTouchable()) {
        if (!reachTop) {
          checkPosition(event);
        }
        var {
          deltaY
        } = touch;
        touch.move(event);
        if (reachTop && deltaY.value >= 0 && touch.isVertical()) {
          preventDefault(event);
          setStatus(ease(deltaY.value));
        }
      }
    };
    var onTouchEnd = () => {
      if (reachTop && touch.deltaY.value && isTouchable()) {
        state.duration = +props.animationDuration;
        if (state.status === "loosing") {
          setStatus(+props.headHeight, true);
          emit("update:modelValue", true);
          nextTick(() => emit("refresh"));
        } else {
          setStatus(0);
        }
      }
    };
    watch(() => props.modelValue, (value) => {
      state.duration = +props.animationDuration;
      if (value) {
        setStatus(+props.headHeight, true);
      } else if (slots.success || props.successText) {
        showSuccessTip();
      } else {
        setStatus(0, false);
      }
    });
    return () => {
      var trackStyle = {
        transitionDuration: state.duration + "ms",
        transform: state.distance ? "translate3d(0," + state.distance + "px, 0)" : ""
      };
      return createVNode("div", {
        "ref": root,
        "class": bem75()
      }, [createVNode("div", {
        "class": bem75("track"),
        "style": trackStyle,
        "onTouchstart": onTouchStart,
        "onTouchmove": onTouchMove,
        "onTouchend": onTouchEnd,
        "onTouchcancel": onTouchEnd
      }, [createVNode("div", {
        "class": bem75("head"),
        "style": getHeadStyle()
      }, [renderStatus()]), slots.default == null ? void 0 : slots.default()])]);
    };
  }
});

// node_modules/vant/es/pull-refresh/index.js
var PullRefresh = withInstall(PullRefresh_default);

// node_modules/vant/es/rate/Rate.js
var [name80, bem76] = createNamespace("rate");
function getRateStatus(value, index, allowHalf, readonly) {
  if (value >= index) {
    return {
      status: "full",
      value: 1
    };
  }
  if (value + 0.5 >= index && allowHalf && !readonly) {
    return {
      status: "half",
      value: 0.5
    };
  }
  if (value + 1 >= index && allowHalf && readonly) {
    var cardinal = Math.pow(10, 10);
    return {
      status: "half",
      value: Math.round((value - index + 1) * cardinal) / cardinal
    };
  }
  return {
    status: "void",
    value: 0
  };
}
var rateProps = {
  size: numericProp,
  icon: makeStringProp("star"),
  color: String,
  count: makeNumericProp(5),
  gutter: numericProp,
  readonly: Boolean,
  disabled: Boolean,
  voidIcon: makeStringProp("star-o"),
  allowHalf: Boolean,
  voidColor: String,
  touchable: truthProp,
  iconPrefix: String,
  modelValue: makeNumberProp(0),
  disabledColor: String
};
var Rate_default = defineComponent({
  name: name80,
  props: rateProps,
  emits: ["change", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit
    } = _ref;
    var touch = useTouch();
    var [itemRefs, setItemRefs] = useRefs();
    var untouchable = () => props.readonly || props.disabled || !props.touchable;
    var list = computed(() => Array(+props.count).fill("").map((_, i) => getRateStatus(props.modelValue, i + 1, props.allowHalf, props.readonly)));
    var ranges;
    var updateRanges = () => {
      var rects = itemRefs.value.map(useRect);
      ranges = [];
      rects.forEach((rect, index) => {
        if (props.allowHalf) {
          ranges.push({
            score: index + 0.5,
            left: rect.left
          }, {
            score: index + 1,
            left: rect.left + rect.width / 2
          });
        } else {
          ranges.push({
            score: index + 1,
            left: rect.left
          });
        }
      });
    };
    var getScoreByPosition = (x) => {
      for (var i = ranges.length - 1; i > 0; i--) {
        if (x > ranges[i].left) {
          return ranges[i].score;
        }
      }
      return props.allowHalf ? 0.5 : 1;
    };
    var select = (index) => {
      if (!props.disabled && !props.readonly && index !== props.modelValue) {
        emit("update:modelValue", index);
        emit("change", index);
      }
    };
    var onTouchStart = (event) => {
      if (untouchable()) {
        return;
      }
      touch.start(event);
      updateRanges();
    };
    var onTouchMove = (event) => {
      if (untouchable()) {
        return;
      }
      touch.move(event);
      if (touch.isHorizontal()) {
        var {
          clientX
        } = event.touches[0];
        preventDefault(event);
        select(getScoreByPosition(clientX));
      }
    };
    var renderStar = (item, index) => {
      var {
        icon,
        size,
        color,
        count,
        gutter,
        voidIcon,
        disabled,
        voidColor,
        allowHalf,
        iconPrefix,
        disabledColor
      } = props;
      var score = index + 1;
      var isFull = item.status === "full";
      var isVoid = item.status === "void";
      var renderHalf = allowHalf && item.value > 0 && item.value < 1;
      var style;
      if (gutter && score !== +count) {
        style = {
          paddingRight: addUnit(gutter)
        };
      }
      var onClickItem = (event) => {
        updateRanges();
        select(allowHalf ? getScoreByPosition(event.clientX) : score);
      };
      return createVNode("div", {
        "key": index,
        "ref": setItemRefs(index),
        "role": "radio",
        "style": style,
        "class": bem76("item"),
        "tabindex": disabled ? void 0 : 0,
        "aria-setsize": count,
        "aria-posinset": score,
        "aria-checked": !isVoid,
        "onClick": onClickItem
      }, [createVNode(Icon, {
        "size": size,
        "name": isFull ? icon : voidIcon,
        "class": bem76("icon", {
          disabled,
          full: isFull
        }),
        "color": disabled ? disabledColor : isFull ? color : voidColor,
        "classPrefix": iconPrefix
      }, null), renderHalf && createVNode(Icon, {
        "size": size,
        "style": {
          width: item.value + "em"
        },
        "name": isVoid ? voidIcon : icon,
        "class": bem76("icon", ["half", {
          disabled,
          full: !isVoid
        }]),
        "color": disabled ? disabledColor : isVoid ? voidColor : color,
        "classPrefix": iconPrefix
      }, null)]);
    };
    useCustomFieldValue(() => props.modelValue);
    return () => createVNode("div", {
      "role": "radiogroup",
      "class": bem76({
        readonly: props.readonly,
        disabled: props.disabled
      }),
      "tabindex": props.disabled ? void 0 : 0,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      "onTouchstart": onTouchStart,
      "onTouchmove": onTouchMove
    }, [list.value.map(renderStar)]);
  }
});

// node_modules/vant/es/rate/index.js
var Rate = withInstall(Rate_default);

// node_modules/vant/es/row/index.js
var Row = withInstall(Row_default);

// node_modules/vant/es/search/Search.js
var [name81, bem77, t17] = createNamespace("search");
var searchProps = extend({}, fieldSharedProps, {
  label: String,
  shape: makeStringProp("square"),
  leftIcon: makeStringProp("search"),
  clearable: truthProp,
  actionText: String,
  background: String,
  showAction: Boolean
});
var Search_default = defineComponent({
  name: name81,
  props: searchProps,
  emits: ["search", "cancel", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots,
      attrs
    } = _ref;
    var id = useId();
    var filedRef = ref();
    var onCancel = () => {
      if (!slots.action) {
        emit("update:modelValue", "");
        emit("cancel");
      }
    };
    var onKeypress = (event) => {
      var ENTER_CODE = 13;
      if (event.keyCode === ENTER_CODE) {
        preventDefault(event);
        emit("search", props.modelValue);
      }
    };
    var getInputId = () => props.id || id + "-input";
    var renderLabel = () => {
      if (slots.label || props.label) {
        return createVNode("label", {
          "class": bem77("label"),
          "for": getInputId()
        }, [slots.label ? slots.label() : props.label]);
      }
    };
    var renderAction = () => {
      if (props.showAction) {
        var text = props.actionText || t17("cancel");
        return createVNode("div", {
          "class": bem77("action"),
          "role": "button",
          "tabindex": 0,
          "onClick": onCancel
        }, [slots.action ? slots.action() : text]);
      }
    };
    var blur = () => {
      var _filedRef$value;
      return (_filedRef$value = filedRef.value) == null ? void 0 : _filedRef$value.blur();
    };
    var focus = () => {
      var _filedRef$value2;
      return (_filedRef$value2 = filedRef.value) == null ? void 0 : _filedRef$value2.focus();
    };
    var fieldPropNames = Object.keys(fieldSharedProps);
    var renderField = () => {
      var fieldAttrs = extend({}, attrs, pick(props, fieldPropNames), {
        id: getInputId()
      });
      var onInput = (value) => emit("update:modelValue", value);
      return createVNode(Field, mergeProps({
        "ref": filedRef,
        "type": "search",
        "class": bem77("field"),
        "border": false,
        "onKeypress": onKeypress,
        "onUpdate:modelValue": onInput
      }, fieldAttrs), pick(slots, ["left-icon", "right-icon"]));
    };
    useExpose({
      focus,
      blur
    });
    return () => createVNode("div", {
      "class": bem77({
        "show-action": props.showAction
      }),
      "style": {
        background: props.background
      }
    }, [slots.left == null ? void 0 : slots.left(), createVNode("div", {
      "class": bem77("content", props.shape)
    }, [renderLabel(), renderField()]), renderAction()]);
  }
});

// node_modules/vant/es/search/index.js
var Search = withInstall(Search_default);

// node_modules/vant/es/share-sheet/ShareSheet.js
var PRESET_ICONS = ["qq", "link", "weibo", "wechat", "poster", "qrcode", "weapp-qrcode", "wechat-moments"];
var popupInheritKeys3 = [...popupSharedPropKeys, "round", "closeOnPopstate", "safeAreaInsetBottom"];
function getIconURL(icon) {
  if (PRESET_ICONS.includes(icon)) {
    return "https://img.yzcdn.cn/vant/share-sheet-" + icon + ".png";
  }
  return icon;
}
var [name82, bem78, t18] = createNamespace("share-sheet");
var shareSheetProps = extend({}, popupSharedProps, {
  title: String,
  round: truthProp,
  options: makeArrayProp(),
  cancelText: String,
  description: String,
  closeOnPopstate: truthProp,
  safeAreaInsetBottom: truthProp
});
var ShareSheet_default = defineComponent({
  name: name82,
  props: shareSheetProps,
  emits: ["cancel", "select", "update:show"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var updateShow = (value) => emit("update:show", value);
    var onCancel = () => {
      updateShow(false);
      emit("cancel");
    };
    var onSelect = (option, index) => emit("select", option, index);
    var renderHeader = () => {
      var title = slots.title ? slots.title() : props.title;
      var description = slots.description ? slots.description() : props.description;
      if (title || description) {
        return createVNode("div", {
          "class": bem78("header")
        }, [title && createVNode("h2", {
          "class": bem78("title")
        }, [title]), description && createVNode("span", {
          "class": bem78("description")
        }, [description])]);
      }
    };
    var renderOption = (option, index) => {
      var {
        name: name96,
        icon,
        className,
        description
      } = option;
      return createVNode("div", {
        "role": "button",
        "tabindex": 0,
        "class": [bem78("option"), className, HAPTICS_FEEDBACK],
        "onClick": () => onSelect(option, index)
      }, [createVNode("img", {
        "src": getIconURL(icon),
        "class": bem78("icon")
      }, null), name96 && createVNode("span", {
        "class": bem78("name")
      }, [name96]), description && createVNode("span", {
        "class": bem78("option-description")
      }, [description])]);
    };
    var renderOptions = (options, border) => createVNode("div", {
      "class": bem78("options", {
        border
      })
    }, [options.map(renderOption)]);
    var renderRows = () => {
      var {
        options
      } = props;
      if (Array.isArray(options[0])) {
        return options.map((item, index) => renderOptions(item, index !== 0));
      }
      return renderOptions(options);
    };
    var renderCancelButton = () => {
      var _props$cancelText;
      var cancelText = (_props$cancelText = props.cancelText) != null ? _props$cancelText : t18("cancel");
      if (slots.cancel || cancelText) {
        return createVNode("button", {
          "type": "button",
          "class": bem78("cancel"),
          "onClick": onCancel
        }, [slots.cancel ? slots.cancel() : cancelText]);
      }
    };
    return () => createVNode(Popup, mergeProps({
      "class": bem78(),
      "position": "bottom",
      "onUpdate:show": updateShow
    }, pick(props, popupInheritKeys3)), {
      default: () => [renderHeader(), renderRows(), renderCancelButton()]
    });
  }
});

// node_modules/vant/es/share-sheet/index.js
var ShareSheet = withInstall(ShareSheet_default);

// node_modules/vant/es/sidebar/Sidebar.js
var [name83, bem79] = createNamespace("sidebar");
var SIDEBAR_KEY = Symbol(name83);
var sidebarProps = {
  modelValue: makeNumericProp(0)
};
var Sidebar_default = defineComponent({
  name: name83,
  props: sidebarProps,
  emits: ["change", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var {
      linkChildren
    } = useChildren(SIDEBAR_KEY);
    var getActive = () => +props.modelValue;
    var setActive = (value) => {
      if (value !== getActive()) {
        emit("update:modelValue", value);
        emit("change", value);
      }
    };
    linkChildren({
      getActive,
      setActive
    });
    return () => createVNode("div", {
      "role": "tablist",
      "class": bem79()
    }, [slots.default == null ? void 0 : slots.default()]);
  }
});

// node_modules/vant/es/sidebar/index.js
var Sidebar = withInstall(Sidebar_default);

// node_modules/vant/es/sidebar-item/SidebarItem.js
var [name84, bem80] = createNamespace("sidebar-item");
var sidebarItemProps = extend({}, routeProps, {
  dot: Boolean,
  title: String,
  badge: numericProp,
  disabled: Boolean
});
var SidebarItem_default = defineComponent({
  name: name84,
  props: sidebarItemProps,
  emits: ["click"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var route2 = useRoute();
    var {
      parent,
      index
    } = useParent(SIDEBAR_KEY);
    if (!parent) {
      if (true) {
        console.error("[Vant] <SidebarItem> must be a child component of <Sidebar>.");
      }
      return;
    }
    var onClick = () => {
      if (props.disabled) {
        return;
      }
      emit("click", index.value);
      parent.setActive(index.value);
      route2();
    };
    return () => {
      var {
        dot,
        badge,
        title,
        disabled
      } = props;
      var selected = index.value === parent.getActive();
      return createVNode("div", {
        "role": "tab",
        "class": bem80({
          select: selected,
          disabled
        }),
        "tabindex": disabled ? void 0 : 0,
        "aria-selected": selected,
        "onClick": onClick
      }, [createVNode(Badge, {
        "dot": dot,
        "content": badge,
        "class": bem80("text")
      }, {
        default: () => [slots.title ? slots.title() : title]
      })]);
    };
  }
});

// node_modules/vant/es/sidebar-item/index.js
var SidebarItem = withInstall(SidebarItem_default);

// node_modules/vant/es/skeleton/Skeleton.js
var [name85, bem81] = createNamespace("skeleton");
var DEFAULT_ROW_WIDTH = "100%";
var DEFAULT_LAST_ROW_WIDTH = "60%";
var skeletonProps = {
  row: makeNumericProp(0),
  title: Boolean,
  round: Boolean,
  avatar: Boolean,
  loading: truthProp,
  animate: truthProp,
  avatarSize: numericProp,
  titleWidth: numericProp,
  avatarShape: makeStringProp("round"),
  rowWidth: {
    type: [Number, String, Array],
    default: DEFAULT_ROW_WIDTH
  }
};
var Skeleton_default = defineComponent({
  name: name85,
  props: skeletonProps,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var renderAvatar = () => {
      if (props.avatar) {
        return createVNode("div", {
          "class": bem81("avatar", props.avatarShape),
          "style": getSizeStyle(props.avatarSize)
        }, null);
      }
    };
    var renderTitle = () => {
      if (props.title) {
        return createVNode("h3", {
          "class": bem81("title"),
          "style": {
            width: addUnit(props.titleWidth)
          }
        }, null);
      }
    };
    var getRowWidth = (index) => {
      var {
        rowWidth
      } = props;
      if (rowWidth === DEFAULT_ROW_WIDTH && index === +props.row - 1) {
        return DEFAULT_LAST_ROW_WIDTH;
      }
      if (Array.isArray(rowWidth)) {
        return rowWidth[index];
      }
      return rowWidth;
    };
    var renderRows = () => Array(props.row).fill("").map((_, i) => createVNode("div", {
      "class": bem81("row"),
      "style": {
        width: addUnit(getRowWidth(i))
      }
    }, null));
    return () => {
      if (!props.loading) {
        return slots.default == null ? void 0 : slots.default();
      }
      return createVNode("div", {
        "class": bem81({
          animate: props.animate,
          round: props.round
        })
      }, [renderAvatar(), createVNode("div", {
        "class": bem81("content")
      }, [renderTitle(), renderRows()])]);
    };
  }
});

// node_modules/vant/es/skeleton/index.js
var Skeleton = withInstall(Skeleton_default);

// node_modules/vant/es/slider/Slider.js
var [name86, bem82] = createNamespace("slider");
var sliderProps = {
  min: makeNumericProp(0),
  max: makeNumericProp(100),
  step: makeNumericProp(1),
  range: Boolean,
  reverse: Boolean,
  disabled: Boolean,
  readonly: Boolean,
  vertical: Boolean,
  barHeight: numericProp,
  buttonSize: numericProp,
  activeColor: String,
  inactiveColor: String,
  modelValue: {
    type: [Number, Array],
    default: 0
  }
};
var Slider_default = defineComponent({
  name: name86,
  props: sliderProps,
  emits: ["change", "drag-end", "drag-start", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var buttonIndex;
    var current2;
    var startValue;
    var root = ref();
    var dragStatus = ref();
    var touch = useTouch();
    var scope = computed(() => Number(props.max) - Number(props.min));
    var wrapperStyle = computed(() => {
      var crossAxis = props.vertical ? "width" : "height";
      return {
        background: props.inactiveColor,
        [crossAxis]: addUnit(props.barHeight)
      };
    });
    var isRange = (val) => props.range && Array.isArray(val);
    var calcMainAxis = () => {
      var {
        modelValue,
        min
      } = props;
      if (isRange(modelValue)) {
        return (modelValue[1] - modelValue[0]) * 100 / scope.value + "%";
      }
      return (modelValue - Number(min)) * 100 / scope.value + "%";
    };
    var calcOffset = () => {
      var {
        modelValue,
        min
      } = props;
      if (isRange(modelValue)) {
        return (modelValue[0] - Number(min)) * 100 / scope.value + "%";
      }
      return "0%";
    };
    var barStyle = computed(() => {
      var mainAxis = props.vertical ? "height" : "width";
      var style = {
        [mainAxis]: calcMainAxis(),
        background: props.activeColor
      };
      if (dragStatus.value) {
        style.transition = "none";
      }
      var getPositionKey = () => {
        if (props.vertical) {
          return props.reverse ? "bottom" : "top";
        }
        return props.reverse ? "right" : "left";
      };
      style[getPositionKey()] = calcOffset();
      return style;
    });
    var format3 = (value) => {
      var min = +props.min;
      var max = +props.max;
      var step = +props.step;
      value = clamp(value, min, max);
      var diff = Math.round((value - min) / step) * step;
      return addNumber(min, diff);
    };
    var isSameValue = (newValue, oldValue) => JSON.stringify(newValue) === JSON.stringify(oldValue);
    var handleRangeValue = (value) => {
      var _value$, _value$2;
      var left2 = (_value$ = value[0]) != null ? _value$ : Number(props.min);
      var right2 = (_value$2 = value[1]) != null ? _value$2 : Number(props.max);
      return left2 > right2 ? [right2, left2] : [left2, right2];
    };
    var updateValue = (value, end2) => {
      if (isRange(value)) {
        value = handleRangeValue(value).map(format3);
      } else {
        value = format3(value);
      }
      if (!isSameValue(value, props.modelValue)) {
        emit("update:modelValue", value);
      }
      if (end2 && !isSameValue(value, startValue)) {
        emit("change", value);
      }
    };
    var onClick = (event) => {
      event.stopPropagation();
      if (props.disabled || props.readonly) {
        return;
      }
      var {
        min,
        reverse,
        vertical,
        modelValue
      } = props;
      var rect = useRect(root);
      var getDelta = () => {
        if (vertical) {
          if (reverse) {
            return rect.bottom - event.clientY;
          }
          return event.clientY - rect.top;
        }
        if (reverse) {
          return rect.right - event.clientX;
        }
        return event.clientX - rect.left;
      };
      var total = vertical ? rect.height : rect.width;
      var value = Number(min) + getDelta() / total * scope.value;
      if (isRange(modelValue)) {
        var [left2, right2] = modelValue;
        var middle = (left2 + right2) / 2;
        if (value <= middle) {
          updateValue([value, right2], true);
        } else {
          updateValue([left2, value], true);
        }
      } else {
        updateValue(value, true);
      }
    };
    var onTouchStart = (event) => {
      if (props.disabled || props.readonly) {
        return;
      }
      touch.start(event);
      current2 = props.modelValue;
      if (isRange(current2)) {
        startValue = current2.map(format3);
      } else {
        startValue = format3(current2);
      }
      dragStatus.value = "start";
    };
    var onTouchMove = (event) => {
      if (props.disabled || props.readonly) {
        return;
      }
      if (dragStatus.value === "start") {
        emit("drag-start", event);
      }
      preventDefault(event, true);
      touch.move(event);
      dragStatus.value = "dragging";
      var rect = useRect(root);
      var delta = props.vertical ? touch.deltaY.value : touch.deltaX.value;
      var total = props.vertical ? rect.height : rect.width;
      var diff = delta / total * scope.value;
      if (props.reverse) {
        diff = -diff;
      }
      if (isRange(startValue)) {
        var index = props.reverse ? 1 - buttonIndex : buttonIndex;
        current2[index] = startValue[index] + diff;
      } else {
        current2 = startValue + diff;
      }
      updateValue(current2);
    };
    var onTouchEnd = (event) => {
      if (props.disabled || props.readonly) {
        return;
      }
      if (dragStatus.value === "dragging") {
        updateValue(current2, true);
        emit("drag-end", event);
      }
      dragStatus.value = "";
    };
    var getButtonClassName = (index) => {
      if (typeof index === "number") {
        var position = ["left", "right"];
        return bem82("button-wrapper", position[index]);
      }
      return bem82("button-wrapper", props.reverse ? "left" : "right");
    };
    var renderButtonContent = (value, index) => {
      if (typeof index === "number") {
        var slot = slots[index === 0 ? "left-button" : "right-button"];
        if (slot) {
          return slot({
            value
          });
        }
      }
      if (slots.button) {
        return slots.button({
          value
        });
      }
      return createVNode("div", {
        "class": bem82("button"),
        "style": getSizeStyle(props.buttonSize)
      }, null);
    };
    var renderButton = (index) => {
      var current3 = typeof index === "number" ? props.modelValue[index] : props.modelValue;
      return createVNode("div", {
        "role": "slider",
        "class": getButtonClassName(index),
        "tabindex": props.disabled ? void 0 : 0,
        "aria-valuemin": props.min,
        "aria-valuenow": current3,
        "aria-valuemax": props.max,
        "aria-disabled": props.disabled || void 0,
        "aria-readonly": props.readonly || void 0,
        "aria-orientation": props.vertical ? "vertical" : "horizontal",
        "onTouchstart": (event) => {
          if (typeof index === "number") {
            buttonIndex = index;
          }
          onTouchStart(event);
        },
        "onTouchmove": onTouchMove,
        "onTouchend": onTouchEnd,
        "onTouchcancel": onTouchEnd,
        "onClick": stopPropagation
      }, [renderButtonContent(current3, index)]);
    };
    updateValue(props.modelValue);
    useCustomFieldValue(() => props.modelValue);
    return () => createVNode("div", {
      "ref": root,
      "style": wrapperStyle.value,
      "class": bem82({
        vertical: props.vertical,
        disabled: props.disabled
      }),
      "onClick": onClick
    }, [createVNode("div", {
      "class": bem82("bar"),
      "style": barStyle.value
    }, [props.range ? [renderButton(0), renderButton(1)] : renderButton()])]);
  }
});

// node_modules/vant/es/slider/index.js
var Slider = withInstall(Slider_default);

// node_modules/vant/es/steps/Steps.js
var [name87, bem83] = createNamespace("steps");
var stepsProps = {
  active: makeNumericProp(0),
  direction: makeStringProp("horizontal"),
  activeIcon: makeStringProp("checked"),
  iconPrefix: String,
  finishIcon: String,
  activeColor: String,
  inactiveIcon: String,
  inactiveColor: String
};
var STEPS_KEY = Symbol(name87);
var Steps_default = defineComponent({
  name: name87,
  props: stepsProps,
  emits: ["click-step"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var {
      linkChildren
    } = useChildren(STEPS_KEY);
    var onClickStep = (index) => emit("click-step", index);
    linkChildren({
      props,
      onClickStep
    });
    return () => createVNode("div", {
      "class": bem83([props.direction])
    }, [createVNode("div", {
      "class": bem83("items")
    }, [slots.default == null ? void 0 : slots.default()])]);
  }
});

// node_modules/vant/es/step/Step.js
var [name88, bem84] = createNamespace("step");
var Step_default = defineComponent({
  name: name88,
  setup(props, _ref) {
    var {
      slots
    } = _ref;
    var {
      parent,
      index
    } = useParent(STEPS_KEY);
    if (!parent) {
      if (true) {
        console.error("[Vant] <Step> must be a child component of <Steps>.");
      }
      return;
    }
    var parentProps = parent.props;
    var getStatus = () => {
      var active = +parentProps.active;
      if (index.value < active) {
        return "finish";
      }
      return index.value === active ? "process" : "waiting";
    };
    var isActive = () => getStatus() === "process";
    var lineStyle = computed(() => ({
      background: getStatus() === "finish" ? parentProps.activeColor : parentProps.inactiveColor
    }));
    var titleStyle = computed(() => {
      if (isActive()) {
        return {
          color: parentProps.activeColor
        };
      }
      if (!getStatus()) {
        return {
          color: parentProps.inactiveColor
        };
      }
    });
    var onClickStep = () => parent.onClickStep(index.value);
    var renderCircle = () => {
      var {
        iconPrefix,
        finishIcon,
        activeIcon,
        activeColor,
        inactiveIcon
      } = parentProps;
      if (isActive()) {
        if (slots["active-icon"]) {
          return slots["active-icon"]();
        }
        return createVNode(Icon, {
          "class": bem84("icon", "active"),
          "name": activeIcon,
          "color": activeColor,
          "classPrefix": iconPrefix
        }, null);
      }
      if (getStatus() === "finish" && (finishIcon || slots["finish-icon"])) {
        if (slots["finish-icon"]) {
          return slots["finish-icon"]();
        }
        return createVNode(Icon, {
          "class": bem84("icon", "finish"),
          "name": finishIcon,
          "color": activeColor,
          "classPrefix": iconPrefix
        }, null);
      }
      if (slots["inactive-icon"]) {
        return slots["inactive-icon"]();
      }
      if (inactiveIcon) {
        return createVNode(Icon, {
          "class": bem84("icon"),
          "name": inactiveIcon,
          "classPrefix": iconPrefix
        }, null);
      }
      return createVNode("i", {
        "class": bem84("circle"),
        "style": lineStyle.value
      }, null);
    };
    return () => {
      var status = getStatus();
      return createVNode("div", {
        "class": [BORDER, bem84([parentProps.direction, {
          [status]: status
        }])]
      }, [createVNode("div", {
        "class": bem84("title", {
          active: isActive()
        }),
        "style": titleStyle.value,
        "onClick": onClickStep
      }, [slots.default == null ? void 0 : slots.default()]), createVNode("div", {
        "class": bem84("circle-container"),
        "onClick": onClickStep
      }, [renderCircle()]), createVNode("div", {
        "class": bem84("line"),
        "style": lineStyle.value
      }, null)]);
    };
  }
});

// node_modules/vant/es/step/index.js
var Step = withInstall(Step_default);

// node_modules/vant/es/stepper/Stepper.js
var [name89, bem85] = createNamespace("stepper");
var LONG_PRESS_INTERVAL = 200;
var LONG_PRESS_START_TIME = 600;
var isEqual = (value1, value2) => String(value1) === String(value2);
var stepperProps = {
  min: makeNumericProp(1),
  max: makeNumericProp(Infinity),
  name: makeNumericProp(""),
  step: makeNumericProp(1),
  theme: String,
  integer: Boolean,
  disabled: Boolean,
  showPlus: truthProp,
  showMinus: truthProp,
  showInput: truthProp,
  longPress: truthProp,
  allowEmpty: Boolean,
  modelValue: numericProp,
  inputWidth: numericProp,
  buttonSize: numericProp,
  placeholder: String,
  disablePlus: Boolean,
  disableMinus: Boolean,
  disableInput: Boolean,
  beforeChange: Function,
  defaultValue: makeNumericProp(1),
  decimalLength: numericProp
};
var Stepper_default = defineComponent({
  name: name89,
  props: stepperProps,
  emits: ["plus", "blur", "minus", "focus", "change", "overlimit", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit
    } = _ref;
    var format3 = (value) => {
      var {
        min,
        max,
        allowEmpty,
        decimalLength
      } = props;
      if (allowEmpty && value === "") {
        return value;
      }
      value = formatNumber(String(value), !props.integer);
      value = value === "" ? 0 : +value;
      value = Number.isNaN(value) ? +min : value;
      value = Math.max(Math.min(+max, value), +min);
      if (isDef(decimalLength)) {
        value = value.toFixed(+decimalLength);
      }
      return value;
    };
    var getInitialValue = () => {
      var _props$modelValue;
      var defaultValue = (_props$modelValue = props.modelValue) != null ? _props$modelValue : props.defaultValue;
      var value = format3(defaultValue);
      if (!isEqual(value, props.modelValue)) {
        emit("update:modelValue", value);
      }
      return value;
    };
    var actionType;
    var inputRef = ref();
    var current2 = ref(getInitialValue());
    var minusDisabled = computed(() => props.disabled || props.disableMinus || current2.value <= +props.min);
    var plusDisabled = computed(() => props.disabled || props.disablePlus || current2.value >= +props.max);
    var inputStyle = computed(() => ({
      width: addUnit(props.inputWidth),
      height: addUnit(props.buttonSize)
    }));
    var buttonStyle = computed(() => getSizeStyle(props.buttonSize));
    var check = () => {
      var value = format3(current2.value);
      if (!isEqual(value, current2.value)) {
        current2.value = value;
      }
    };
    var setValue = (value) => {
      if (props.beforeChange) {
        callInterceptor(props.beforeChange, {
          args: [value],
          done() {
            current2.value = value;
          }
        });
      } else {
        current2.value = value;
      }
    };
    var onChange = () => {
      if (actionType === "plus" && plusDisabled.value || actionType === "minus" && minusDisabled.value) {
        emit("overlimit", actionType);
        return;
      }
      var diff = actionType === "minus" ? -props.step : +props.step;
      var value = format3(addNumber(+current2.value, diff));
      setValue(value);
      emit(actionType);
    };
    var onInput = (event) => {
      var input = event.target;
      var {
        value
      } = input;
      var {
        decimalLength
      } = props;
      var formatted = formatNumber(String(value), !props.integer);
      if (isDef(decimalLength) && formatted.includes(".")) {
        var pair = formatted.split(".");
        formatted = pair[0] + "." + pair[1].slice(0, +decimalLength);
      }
      if (props.beforeChange) {
        input.value = String(current2.value);
      } else if (!isEqual(value, formatted)) {
        input.value = formatted;
      }
      var isNumeric2 = formatted === String(+formatted);
      setValue(isNumeric2 ? +formatted : formatted);
    };
    var onFocus = (event) => {
      if (props.disableInput) {
        var _inputRef$value;
        (_inputRef$value = inputRef.value) == null ? void 0 : _inputRef$value.blur();
      } else {
        emit("focus", event);
      }
    };
    var onBlur = (event) => {
      var input = event.target;
      var value = format3(input.value);
      input.value = String(value);
      current2.value = value;
      nextTick(() => {
        emit("blur", event);
        resetScroll();
      });
    };
    var isLongPress;
    var longPressTimer;
    var longPressStep = () => {
      longPressTimer = setTimeout(() => {
        onChange();
        longPressStep();
      }, LONG_PRESS_INTERVAL);
    };
    var onTouchStart = () => {
      if (props.longPress) {
        isLongPress = false;
        clearTimeout(longPressTimer);
        longPressTimer = setTimeout(() => {
          isLongPress = true;
          onChange();
          longPressStep();
        }, LONG_PRESS_START_TIME);
      }
    };
    var onTouchEnd = (event) => {
      if (props.longPress) {
        clearTimeout(longPressTimer);
        if (isLongPress) {
          preventDefault(event);
        }
      }
    };
    var onMousedown = (event) => {
      if (props.disableInput) {
        preventDefault(event);
      }
    };
    var createListeners = (type) => ({
      onClick: (event) => {
        preventDefault(event);
        actionType = type;
        onChange();
      },
      onTouchstart: () => {
        actionType = type;
        onTouchStart();
      },
      onTouchend: onTouchEnd,
      onTouchcancel: onTouchEnd
    });
    watch(() => [props.max, props.min, props.integer, props.decimalLength], check);
    watch(() => props.modelValue, (value) => {
      if (!isEqual(value, current2.value)) {
        current2.value = format3(value);
      }
    });
    watch(current2, (value) => {
      emit("update:modelValue", value);
      emit("change", value, {
        name: props.name
      });
    });
    useCustomFieldValue(() => props.modelValue);
    return () => createVNode("div", {
      "role": "group",
      "class": bem85([props.theme])
    }, [withDirectives(createVNode("button", mergeProps({
      "type": "button",
      "style": buttonStyle.value,
      "class": [bem85("minus", {
        disabled: minusDisabled.value
      }), {
        [HAPTICS_FEEDBACK]: !minusDisabled.value
      }],
      "aria-disabled": minusDisabled.value || void 0
    }, createListeners("minus")), null), [[vShow, props.showMinus]]), withDirectives(createVNode("input", {
      "ref": inputRef,
      "type": props.integer ? "tel" : "text",
      "role": "spinbutton",
      "class": bem85("input"),
      "value": current2.value,
      "style": inputStyle.value,
      "disabled": props.disabled,
      "readonly": props.disableInput,
      "inputmode": props.integer ? "numeric" : "decimal",
      "placeholder": props.placeholder,
      "aria-valuemax": props.max,
      "aria-valuemin": props.min,
      "aria-valuenow": current2.value,
      "onBlur": onBlur,
      "onInput": onInput,
      "onFocus": onFocus,
      "onMousedown": onMousedown
    }, null), [[vShow, props.showInput]]), withDirectives(createVNode("button", mergeProps({
      "type": "button",
      "style": buttonStyle.value,
      "class": [bem85("plus", {
        disabled: plusDisabled.value
      }), {
        [HAPTICS_FEEDBACK]: !plusDisabled.value
      }],
      "aria-disabled": plusDisabled.value || void 0
    }, createListeners("plus")), null), [[vShow, props.showPlus]])]);
  }
});

// node_modules/vant/es/stepper/index.js
var Stepper = withInstall(Stepper_default);

// node_modules/vant/es/steps/index.js
var Steps = withInstall(Steps_default);

// node_modules/vant/es/submit-bar/SubmitBar.js
var [name90, bem86, t19] = createNamespace("submit-bar");
var submitBarProps = {
  tip: String,
  label: String,
  price: Number,
  tipIcon: String,
  loading: Boolean,
  currency: makeStringProp("\xA5"),
  disabled: Boolean,
  textAlign: String,
  buttonText: String,
  buttonType: makeStringProp("danger"),
  buttonColor: String,
  suffixLabel: String,
  decimalLength: makeNumericProp(2),
  safeAreaInsetBottom: truthProp
};
var SubmitBar_default = defineComponent({
  name: name90,
  props: submitBarProps,
  emits: ["submit"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var renderText = () => {
      var {
        price,
        label,
        currency,
        textAlign,
        suffixLabel,
        decimalLength
      } = props;
      if (typeof price === "number") {
        var pricePair = (price / 100).toFixed(+decimalLength).split(".");
        var decimal = decimalLength ? "." + pricePair[1] : "";
        return createVNode("div", {
          "class": bem86("text"),
          "style": {
            textAlign
          }
        }, [createVNode("span", null, [label || t19("label")]), createVNode("span", {
          "class": bem86("price")
        }, [currency, createVNode("span", {
          "class": bem86("price-integer")
        }, [pricePair[0]]), decimal]), suffixLabel && createVNode("span", {
          "class": bem86("suffix-label")
        }, [suffixLabel])]);
      }
    };
    var renderTip = () => {
      var {
        tip,
        tipIcon
      } = props;
      if (slots.tip || tip) {
        return createVNode("div", {
          "class": bem86("tip")
        }, [tipIcon && createVNode(Icon, {
          "class": bem86("tip-icon"),
          "name": tipIcon
        }, null), tip && createVNode("span", {
          "class": bem86("tip-text")
        }, [tip]), slots.tip == null ? void 0 : slots.tip()]);
      }
    };
    var onClickButton = () => emit("submit");
    var renderButton = () => {
      if (slots.button) {
        return slots.button();
      }
      return createVNode(Button, {
        "round": true,
        "type": props.buttonType,
        "text": props.buttonText,
        "class": bem86("button", props.buttonType),
        "color": props.buttonColor,
        "loading": props.loading,
        "disabled": props.disabled,
        "onClick": onClickButton
      }, null);
    };
    return () => createVNode("div", {
      "class": [bem86(), {
        "van-safe-area-bottom": props.safeAreaInsetBottom
      }]
    }, [slots.top == null ? void 0 : slots.top(), renderTip(), createVNode("div", {
      "class": bem86("bar")
    }, [slots.default == null ? void 0 : slots.default(), renderText(), renderButton()])]);
  }
});

// node_modules/vant/es/submit-bar/index.js
var SubmitBar = withInstall(SubmitBar_default);

// node_modules/vant/es/swipe-cell/SwipeCell.js
var [name91, bem87] = createNamespace("swipe-cell");
var swipeCellProps = {
  name: makeNumericProp(""),
  disabled: Boolean,
  leftWidth: numericProp,
  rightWidth: numericProp,
  beforeClose: Function,
  stopPropagation: Boolean
};
var SwipeCell_default = defineComponent({
  name: name91,
  props: swipeCellProps,
  emits: ["open", "close", "click"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var opened;
    var lockClick2;
    var startOffset;
    var root = ref();
    var leftRef = ref();
    var rightRef = ref();
    var state = reactive({
      offset: 0,
      dragging: false
    });
    var touch = useTouch();
    var getWidthByRef = (ref2) => ref2.value ? useRect(ref2).width : 0;
    var leftWidth = computed(() => isDef(props.leftWidth) ? +props.leftWidth : getWidthByRef(leftRef));
    var rightWidth = computed(() => isDef(props.rightWidth) ? +props.rightWidth : getWidthByRef(rightRef));
    var open = (side) => {
      opened = true;
      state.offset = side === "left" ? leftWidth.value : -rightWidth.value;
      emit("open", {
        name: props.name,
        position: side
      });
    };
    var close = (position) => {
      state.offset = 0;
      if (opened) {
        opened = false;
        emit("close", {
          name: props.name,
          position
        });
      }
    };
    var toggle = (side) => {
      var offset2 = Math.abs(state.offset);
      var THRESHOLD = 0.15;
      var threshold = opened ? 1 - THRESHOLD : THRESHOLD;
      var width2 = side === "left" ? leftWidth.value : rightWidth.value;
      if (width2 && offset2 > width2 * threshold) {
        open(side);
      } else {
        close(side);
      }
    };
    var onTouchStart = (event) => {
      if (!props.disabled) {
        startOffset = state.offset;
        touch.start(event);
      }
    };
    var onTouchMove = (event) => {
      if (props.disabled) {
        return;
      }
      var {
        deltaX
      } = touch;
      touch.move(event);
      if (touch.isHorizontal()) {
        lockClick2 = true;
        state.dragging = true;
        var isEdge = !opened || deltaX.value * startOffset < 0;
        if (isEdge) {
          preventDefault(event, props.stopPropagation);
        }
        state.offset = clamp(deltaX.value + startOffset, -rightWidth.value, leftWidth.value);
      }
    };
    var onTouchEnd = () => {
      if (state.dragging) {
        state.dragging = false;
        toggle(state.offset > 0 ? "left" : "right");
        setTimeout(() => {
          lockClick2 = false;
        }, 0);
      }
    };
    var onClick = function(position) {
      if (position === void 0) {
        position = "outside";
      }
      emit("click", position);
      if (opened && !lockClick2) {
        callInterceptor(props.beforeClose, {
          args: [{
            name: props.name,
            position
          }],
          done: () => close(position)
        });
      }
    };
    var getClickHandler = (position, stop) => (event) => {
      if (stop) {
        event.stopPropagation();
      }
      onClick(position);
    };
    var renderSideContent = (side, ref2) => {
      var contentSlot = slots[side];
      if (contentSlot) {
        return createVNode("div", {
          "ref": ref2,
          "class": bem87(side),
          "onClick": getClickHandler(side, true)
        }, [contentSlot()]);
      }
    };
    useExpose({
      open,
      close
    });
    useClickAway(root, () => onClick("outside"), {
      eventName: "touchstart"
    });
    return () => {
      var wrapperStyle = {
        transform: "translate3d(" + state.offset + "px, 0, 0)",
        transitionDuration: state.dragging ? "0s" : ".6s"
      };
      return createVNode("div", {
        "ref": root,
        "class": bem87(),
        "onClick": getClickHandler("cell"),
        "onTouchstart": onTouchStart,
        "onTouchmove": onTouchMove,
        "onTouchend": onTouchEnd,
        "onTouchcancel": onTouchEnd
      }, [createVNode("div", {
        "class": bem87("wrapper"),
        "style": wrapperStyle
      }, [renderSideContent("left", leftRef), slots.default == null ? void 0 : slots.default(), renderSideContent("right", rightRef)])]);
    };
  }
});

// node_modules/vant/es/swipe-cell/index.js
var SwipeCell = withInstall(SwipeCell_default);

// node_modules/vant/es/tabbar/Tabbar.js
var [name92, bem88] = createNamespace("tabbar");
var tabbarProps = {
  route: Boolean,
  fixed: truthProp,
  border: truthProp,
  zIndex: numericProp,
  placeholder: Boolean,
  activeColor: String,
  beforeChange: Function,
  inactiveColor: String,
  modelValue: makeNumericProp(0),
  safeAreaInsetBottom: {
    type: Boolean,
    default: null
  }
};
var TABBAR_KEY = Symbol(name92);
var Tabbar_default = defineComponent({
  name: name92,
  props: tabbarProps,
  emits: ["change", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var root = ref();
    var {
      linkChildren
    } = useChildren(TABBAR_KEY);
    var renderPlaceholder = usePlaceholder(root, bem88);
    var enableSafeArea = () => {
      var _props$safeAreaInsetB;
      return (_props$safeAreaInsetB = props.safeAreaInsetBottom) != null ? _props$safeAreaInsetB : props.fixed;
    };
    var renderTabbar = () => {
      var {
        fixed,
        zIndex,
        border
      } = props;
      return createVNode("div", {
        "ref": root,
        "role": "tablist",
        "style": getZIndexStyle(zIndex),
        "class": [bem88({
          fixed
        }), {
          [BORDER_TOP_BOTTOM]: border,
          "van-safe-area-bottom": enableSafeArea()
        }]
      }, [slots.default == null ? void 0 : slots.default()]);
    };
    var setActive = (active, afterChange) => {
      callInterceptor(props.beforeChange, {
        args: [active],
        done() {
          emit("update:modelValue", active);
          emit("change", active);
          afterChange();
        }
      });
    };
    linkChildren({
      props,
      setActive
    });
    return () => {
      if (props.fixed && props.placeholder) {
        return renderPlaceholder(renderTabbar);
      }
      return renderTabbar();
    };
  }
});

// node_modules/vant/es/tabbar/index.js
var Tabbar = withInstall(Tabbar_default);

// node_modules/vant/es/tabbar-item/TabbarItem.js
var [name93, bem89] = createNamespace("tabbar-item");
var tabbarItemProps = extend({}, routeProps, {
  dot: Boolean,
  icon: String,
  name: numericProp,
  badge: numericProp,
  iconPrefix: String
});
var TabbarItem_default = defineComponent({
  name: name93,
  props: tabbarItemProps,
  emits: ["click"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var route2 = useRoute();
    var vm = getCurrentInstance().proxy;
    var {
      parent,
      index
    } = useParent(TABBAR_KEY);
    if (!parent) {
      if (true) {
        console.error("[Vant] <TabbarItem> must be a child component of <Tabbar>.");
      }
      return;
    }
    var active = computed(() => {
      var _props$name;
      var {
        route: route3,
        modelValue
      } = parent.props;
      if (route3 && "$route" in vm) {
        var {
          $route
        } = vm;
        var {
          to
        } = props;
        var config = isObject(to) ? to : {
          path: to
        };
        return !!$route.matched.find((val) => {
          var pathMatched = "path" in config && config.path === val.path;
          var nameMatched = "name" in config && config.name === val.name;
          return pathMatched || nameMatched;
        });
      }
      return ((_props$name = props.name) != null ? _props$name : index.value) === modelValue;
    });
    var onClick = (event) => {
      if (!active.value) {
        var _props$name2;
        parent.setActive((_props$name2 = props.name) != null ? _props$name2 : index.value, route2);
      }
      emit("click", event);
    };
    var renderIcon = () => {
      if (slots.icon) {
        return slots.icon({
          active: active.value
        });
      }
      if (props.icon) {
        return createVNode(Icon, {
          "name": props.icon,
          "classPrefix": props.iconPrefix
        }, null);
      }
    };
    return () => {
      var {
        dot,
        badge
      } = props;
      var {
        activeColor,
        inactiveColor
      } = parent.props;
      var color = active.value ? activeColor : inactiveColor;
      return createVNode("div", {
        "role": "tab",
        "class": bem89({
          active: active.value
        }),
        "style": {
          color
        },
        "tabindex": 0,
        "aria-selected": active.value,
        "onClick": onClick
      }, [createVNode(Badge, {
        "dot": dot,
        "content": badge,
        "class": bem89("icon")
      }, {
        default: renderIcon
      }), createVNode("div", {
        "class": bem89("text")
      }, [slots.default == null ? void 0 : slots.default({
        active: active.value
      })])]);
    };
  }
});

// node_modules/vant/es/tabbar-item/index.js
var TabbarItem = withInstall(TabbarItem_default);

// node_modules/vant/es/tree-select/TreeSelect.js
var [name94, bem90] = createNamespace("tree-select");
var treeSelectProps = {
  max: makeNumericProp(Infinity),
  items: makeArrayProp(),
  height: makeNumericProp(300),
  selectedIcon: makeStringProp("success"),
  mainActiveIndex: makeNumericProp(0),
  activeId: {
    type: [Number, String, Array],
    default: 0
  }
};
var TreeSelect_default = defineComponent({
  name: name94,
  props: treeSelectProps,
  emits: ["click-nav", "click-item", "update:activeId", "update:mainActiveIndex"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var isActiveItem = (id) => Array.isArray(props.activeId) ? props.activeId.includes(id) : props.activeId === id;
    var renderSubItem = (item) => {
      var onClick = () => {
        if (item.disabled) {
          return;
        }
        var activeId;
        if (Array.isArray(props.activeId)) {
          activeId = props.activeId.slice();
          var index = activeId.indexOf(item.id);
          if (index !== -1) {
            activeId.splice(index, 1);
          } else if (activeId.length < props.max) {
            activeId.push(item.id);
          }
        } else {
          activeId = item.id;
        }
        emit("update:activeId", activeId);
        emit("click-item", item);
      };
      return createVNode("div", {
        "key": item.id,
        "class": ["van-ellipsis", bem90("item", {
          active: isActiveItem(item.id),
          disabled: item.disabled
        })],
        "onClick": onClick
      }, [item.text, isActiveItem(item.id) && createVNode(Icon, {
        "name": props.selectedIcon,
        "class": bem90("selected")
      }, null)]);
    };
    var onSidebarChange = (index) => {
      emit("update:mainActiveIndex", index);
      emit("click-nav", index);
    };
    var renderSidebar = () => {
      var Items = props.items.map((item) => createVNode(SidebarItem, {
        "dot": item.dot,
        "title": item.text,
        "badge": item.badge,
        "class": [bem90("nav-item"), item.className],
        "disabled": item.disabled
      }, null));
      return createVNode(Sidebar, {
        "class": bem90("nav"),
        "modelValue": props.mainActiveIndex,
        "onChange": onSidebarChange
      }, {
        default: () => [Items]
      });
    };
    var renderContent = () => {
      if (slots.content) {
        return slots.content();
      }
      var selected = props.items[+props.mainActiveIndex] || {};
      if (selected.children) {
        return selected.children.map(renderSubItem);
      }
    };
    return () => createVNode("div", {
      "class": bem90(),
      "style": {
        height: addUnit(props.height)
      }
    }, [renderSidebar(), createVNode("div", {
      "class": bem90("content")
    }, [renderContent()])]);
  }
});

// node_modules/vant/es/tree-select/index.js
var TreeSelect = withInstall(TreeSelect_default);

// node_modules/vant/es/uploader/utils.js
var [name95, bem91, t20] = createNamespace("uploader");
var toArray = (item) => Array.isArray(item) ? item : [item];
function readFileContent(file, resultType) {
  return new Promise((resolve) => {
    if (resultType === "file") {
      resolve();
      return;
    }
    var reader = new FileReader();
    reader.onload = (event) => {
      resolve(event.target.result);
    };
    if (resultType === "dataUrl") {
      reader.readAsDataURL(file);
    } else if (resultType === "text") {
      reader.readAsText(file);
    }
  });
}
function isOversize(items, maxSize) {
  return toArray(items).some((item) => {
    if (item.file) {
      if (isFunction(maxSize)) {
        return maxSize(item.file);
      }
      return item.file.size > maxSize;
    }
    return false;
  });
}
function filterFiles(items, maxSize) {
  var valid = [];
  var invalid = [];
  items.forEach((item) => {
    if (isOversize(item, maxSize)) {
      invalid.push(item);
    } else {
      valid.push(item);
    }
  });
  return {
    valid,
    invalid
  };
}
var IMAGE_REGEXP = /\.(jpeg|jpg|gif|png|svg|webp|jfif|bmp|dpg)/i;
var isImageUrl = (url) => IMAGE_REGEXP.test(url);
function isImageFile(item) {
  if (item.isImage) {
    return true;
  }
  if (item.file && item.file.type) {
    return item.file.type.indexOf("image") === 0;
  }
  if (item.url) {
    return isImageUrl(item.url);
  }
  if (typeof item.content === "string") {
    return item.content.indexOf("data:image") === 0;
  }
  return false;
}

// node_modules/vant/es/uploader/UploaderPreviewItem.js
var UploaderPreviewItem_default = defineComponent({
  props: {
    name: numericProp,
    item: makeRequiredProp(Object),
    index: Number,
    imageFit: String,
    lazyLoad: Boolean,
    deletable: Boolean,
    previewSize: numericProp,
    beforeDelete: Function
  },
  emits: ["delete", "preview"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var renderMask = () => {
      var {
        status,
        message
      } = props.item;
      if (status === "uploading" || status === "failed") {
        var MaskIcon = status === "failed" ? createVNode(Icon, {
          "name": "close",
          "class": bem91("mask-icon")
        }, null) : createVNode(Loading, {
          "class": bem91("loading")
        }, null);
        var showMessage = isDef(message) && message !== "";
        return createVNode("div", {
          "class": bem91("mask")
        }, [MaskIcon, showMessage && createVNode("div", {
          "class": bem91("mask-message")
        }, [message])]);
      }
    };
    var onDelete = (event) => {
      var {
        name: name96,
        item,
        index,
        beforeDelete
      } = props;
      event.stopPropagation();
      callInterceptor(beforeDelete, {
        args: [item, {
          name: name96,
          index
        }],
        done: () => emit("delete")
      });
    };
    var onPreview = () => emit("preview");
    var renderDeleteIcon = () => {
      if (props.deletable && props.item.status !== "uploading") {
        return createVNode("div", {
          "role": "button",
          "class": bem91("preview-delete"),
          "tabindex": 0,
          "aria-label": t20("delete"),
          "onClick": onDelete
        }, [createVNode(Icon, {
          "name": "cross",
          "class": bem91("preview-delete-icon")
        }, null)]);
      }
    };
    var renderCover = () => {
      if (slots["preview-cover"]) {
        var {
          index,
          item
        } = props;
        return createVNode("div", {
          "class": bem91("preview-cover")
        }, [slots["preview-cover"](extend({
          index
        }, item))]);
      }
    };
    var renderPreview = () => {
      var {
        item
      } = props;
      if (isImageFile(item)) {
        return createVNode(Image2, {
          "fit": props.imageFit,
          "src": item.content || item.url,
          "class": bem91("preview-image"),
          "width": props.previewSize,
          "height": props.previewSize,
          "lazyLoad": props.lazyLoad,
          "onClick": onPreview
        }, {
          default: renderCover
        });
      }
      return createVNode("div", {
        "class": bem91("file"),
        "style": getSizeStyle(props.previewSize)
      }, [createVNode(Icon, {
        "class": bem91("file-icon"),
        "name": "description"
      }, null), createVNode("div", {
        "class": [bem91("file-name"), "van-ellipsis"]
      }, [item.file ? item.file.name : item.url]), renderCover()]);
    };
    return () => createVNode("div", {
      "class": bem91("preview")
    }, [renderPreview(), renderMask(), renderDeleteIcon()]);
  }
});

// node_modules/vant/es/uploader/Uploader.js
var uploaderProps = {
  name: makeNumericProp(""),
  accept: makeStringProp("image/*"),
  capture: String,
  multiple: Boolean,
  disabled: Boolean,
  readonly: Boolean,
  lazyLoad: Boolean,
  maxCount: makeNumericProp(Infinity),
  imageFit: makeStringProp("cover"),
  resultType: makeStringProp("dataUrl"),
  uploadIcon: makeStringProp("photograph"),
  uploadText: String,
  deletable: truthProp,
  afterRead: Function,
  showUpload: truthProp,
  modelValue: makeArrayProp(),
  beforeRead: Function,
  beforeDelete: Function,
  previewSize: numericProp,
  previewImage: truthProp,
  previewOptions: Object,
  previewFullImage: truthProp,
  maxSize: {
    type: [Number, String, Function],
    default: Infinity
  }
};
var Uploader_default = defineComponent({
  name: name95,
  props: uploaderProps,
  emits: ["delete", "oversize", "click-upload", "close-preview", "click-preview", "update:modelValue"],
  setup(props, _ref) {
    var {
      emit,
      slots
    } = _ref;
    var inputRef = ref();
    var urls = [];
    var getDetail = function(index) {
      if (index === void 0) {
        index = props.modelValue.length;
      }
      return {
        name: props.name,
        index
      };
    };
    var resetInput = () => {
      if (inputRef.value) {
        inputRef.value.value = "";
      }
    };
    var onAfterRead = (items) => {
      resetInput();
      if (isOversize(items, props.maxSize)) {
        if (Array.isArray(items)) {
          var result = filterFiles(items, props.maxSize);
          items = result.valid;
          emit("oversize", result.invalid, getDetail());
          if (!items.length) {
            return;
          }
        } else {
          emit("oversize", items, getDetail());
          return;
        }
      }
      items = reactive(items);
      emit("update:modelValue", [...props.modelValue, ...toArray(items)]);
      if (props.afterRead) {
        props.afterRead(items, getDetail());
      }
    };
    var readFile = (files) => {
      var {
        maxCount,
        modelValue,
        resultType
      } = props;
      if (Array.isArray(files)) {
        var remainCount = +maxCount - modelValue.length;
        if (files.length > remainCount) {
          files = files.slice(0, remainCount);
        }
        Promise.all(files.map((file) => readFileContent(file, resultType))).then((contents) => {
          var fileList = files.map((file, index) => {
            var result = {
              file,
              status: "",
              message: ""
            };
            if (contents[index]) {
              result.content = contents[index];
            }
            return result;
          });
          onAfterRead(fileList);
        });
      } else {
        readFileContent(files, resultType).then((content) => {
          var result = {
            file: files,
            status: "",
            message: ""
          };
          if (content) {
            result.content = content;
          }
          onAfterRead(result);
        });
      }
    };
    var onChange = (event) => {
      var {
        files
      } = event.target;
      if (props.disabled || !files || !files.length) {
        return;
      }
      var file = files.length === 1 ? files[0] : [].slice.call(files);
      if (props.beforeRead) {
        var response = props.beforeRead(file, getDetail());
        if (!response) {
          resetInput();
          return;
        }
        if (isPromise(response)) {
          response.then((data) => {
            if (data) {
              readFile(data);
            } else {
              readFile(file);
            }
          }).catch(resetInput);
          return;
        }
      }
      readFile(file);
    };
    var imagePreview;
    var onClosePreview = () => emit("close-preview");
    var previewImage = (item) => {
      if (props.previewFullImage) {
        var imageFiles = props.modelValue.filter(isImageFile);
        var images = imageFiles.map((item2) => {
          if (item2.file && !item2.url) {
            item2.url = URL.createObjectURL(item2.file);
            urls.push(item2.url);
          }
          return item2.url;
        }).filter(Boolean);
        imagePreview = ImagePreview(extend({
          images,
          startPosition: imageFiles.indexOf(item),
          onClose: onClosePreview
        }, props.previewOptions));
      }
    };
    var closeImagePreview = () => {
      if (imagePreview) {
        imagePreview.close();
      }
    };
    var deleteFile = (item, index) => {
      var fileList = props.modelValue.slice(0);
      fileList.splice(index, 1);
      emit("update:modelValue", fileList);
      emit("delete", item, getDetail(index));
    };
    var renderPreviewItem = (item, index) => {
      var needPickData = ["imageFit", "deletable", "previewSize", "beforeDelete"];
      var previewData = extend(pick(props, needPickData), pick(item, needPickData, true));
      return createVNode(UploaderPreviewItem_default, mergeProps({
        "item": item,
        "index": index,
        "onClick": () => emit("click-preview", item, getDetail(index)),
        "onDelete": () => deleteFile(item, index),
        "onPreview": () => previewImage(item)
      }, pick(props, ["name", "lazyLoad"]), previewData), {
        "preview-cover": slots["preview-cover"]
      });
    };
    var renderPreviewList = () => {
      if (props.previewImage) {
        return props.modelValue.map(renderPreviewItem);
      }
    };
    var onClickUpload = (event) => emit("click-upload", event);
    var renderUpload = () => {
      if (props.modelValue.length >= props.maxCount || !props.showUpload) {
        return;
      }
      var Input = props.readonly ? null : createVNode("input", {
        "ref": inputRef,
        "type": "file",
        "class": bem91("input"),
        "accept": props.accept,
        "capture": props.capture,
        "multiple": props.multiple,
        "disabled": props.disabled,
        "onChange": onChange
      }, null);
      if (slots.default) {
        return createVNode("div", {
          "class": bem91("input-wrapper"),
          "onClick": onClickUpload
        }, [slots.default(), Input]);
      }
      return createVNode("div", {
        "class": bem91("upload", {
          readonly: props.readonly
        }),
        "style": getSizeStyle(props.previewSize),
        "onClick": onClickUpload
      }, [createVNode(Icon, {
        "name": props.uploadIcon,
        "class": bem91("upload-icon")
      }, null), props.uploadText && createVNode("span", {
        "class": bem91("upload-text")
      }, [props.uploadText]), Input]);
    };
    var chooseFile = () => {
      if (inputRef.value && !props.disabled) {
        inputRef.value.click();
      }
    };
    onBeforeUnmount(() => {
      urls.forEach((url) => URL.revokeObjectURL(url));
    });
    useExpose({
      chooseFile,
      closeImagePreview
    });
    useCustomFieldValue(() => props.modelValue);
    return () => createVNode("div", {
      "class": bem91()
    }, [createVNode("div", {
      "class": bem91("wrapper", {
        disabled: props.disabled
      })
    }, [renderPreviewList(), renderUpload()])]);
  }
});

// node_modules/vant/es/uploader/index.js
var Uploader = withInstall(Uploader_default);

// node_modules/vant/es/index.js
var version = "3.3.7";
function install(app) {
  var components = [ActionBar, ActionBarButton, ActionBarIcon, ActionSheet, AddressEdit, AddressList, Area, Badge, Button, Calendar, Card, Cascader, Cell, CellGroup, Checkbox, CheckboxGroup, Circle, Col, Collapse, CollapseItem, ConfigProvider, ContactCard, ContactEdit, ContactList, CountDown, Coupon, CouponCell, CouponList, DatetimePicker, Dialog, Divider, DropdownItem, DropdownMenu, Empty, Field, Form, Grid, GridItem, Icon, Image2, ImagePreview, IndexAnchor, IndexBar, List, Loading, Locale, NavBar, NoticeBar, Notify, NumberKeyboard, Overlay, Pagination, PasswordInput, Picker, Popover, Popup, Progress, PullRefresh, Radio, RadioGroup, Rate, Row, Search, ShareSheet, Sidebar, SidebarItem, Skeleton, Slider, Step, Stepper, Steps, Sticky, SubmitBar, Swipe, SwipeCell, SwipeItem, Switch, Tab, Tabbar, TabbarItem, Tabs, Tag, Toast, TreeSelect, Uploader];
  components.forEach((item) => {
    if (item.install) {
      app.use(item);
    } else if (item.name) {
      app.component(item.name, item);
    }
  });
}
var es_default = {
  install,
  version
};

// dep:vant
var vant_default = es_default;
export {
  ActionBar,
  ActionBarButton,
  ActionBarIcon,
  ActionSheet,
  AddressEdit,
  AddressList,
  Area,
  Badge,
  Button,
  Calendar,
  Card,
  Cascader,
  Cell,
  CellGroup,
  Checkbox,
  CheckboxGroup,
  Circle,
  Col,
  Collapse,
  CollapseItem,
  ConfigProvider,
  ContactCard,
  ContactEdit,
  ContactList,
  CountDown,
  Coupon,
  CouponCell,
  CouponList,
  DatetimePicker,
  Dialog,
  Divider,
  DropdownItem,
  DropdownMenu,
  Empty,
  Field,
  Form,
  Grid,
  GridItem,
  Icon,
  Image2 as Image,
  ImagePreview,
  IndexAnchor,
  IndexBar,
  Lazyload,
  List,
  Loading,
  Locale,
  NavBar,
  NoticeBar,
  Notify,
  NumberKeyboard,
  Overlay,
  Pagination,
  PasswordInput,
  Picker,
  Popover,
  Popup,
  Progress,
  PullRefresh,
  Radio,
  RadioGroup,
  Rate,
  Row,
  Search,
  ShareSheet,
  Sidebar,
  SidebarItem,
  Skeleton,
  Slider,
  Step,
  Stepper,
  Steps,
  Sticky,
  SubmitBar,
  Swipe,
  SwipeCell,
  SwipeItem,
  Switch,
  Tab,
  Tabbar,
  TabbarItem,
  Tabs,
  Tag,
  Toast,
  TreeSelect,
  Uploader,
  vant_default as default,
  install,
  version
};
//# sourceMappingURL=vant.js.map
