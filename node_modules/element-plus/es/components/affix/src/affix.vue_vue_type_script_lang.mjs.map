{"version":3,"file":"affix.vue_vue_type_script_lang.mjs","sources":["../../../../../../packages/components/affix/src/affix.vue"],"sourcesContent":["<template>\n  <div ref=\"root\" class=\"el-affix\" :style=\"rootStyle\">\n    <div :class=\"{ 'el-affix--fixed': state.fixed }\" :style=\"affixStyle\">\n      <slot></slot>\n    </div>\n  </div>\n</template>\n<script lang=\"ts\">\nimport {\n  computed,\n  defineComponent,\n  onMounted,\n  reactive,\n  shallowRef,\n  watch,\n} from 'vue'\nimport { useEventListener, useResizeObserver } from '@vueuse/core'\nimport { getScrollContainer } from '@element-plus/utils/dom'\nimport { affixEmits, affixProps } from './affix'\n\nimport type { CSSProperties } from 'vue'\n\nexport default defineComponent({\n  name: 'ElAffix',\n\n  props: affixProps,\n  emits: affixEmits,\n\n  setup(props, { emit }) {\n    const target = shallowRef<HTMLElement>()\n    const root = shallowRef<HTMLDivElement>()\n    const scrollContainer = shallowRef<HTMLElement | Window>()\n\n    const state = reactive({\n      fixed: false,\n      height: 0, // height of root\n      width: 0, // width of root\n      scrollTop: 0, // scrollTop of documentElement\n      clientHeight: 0, // clientHeight of documentElement\n      transform: 0,\n    })\n\n    const rootStyle = computed<CSSProperties>(() => {\n      return {\n        height: state.fixed ? `${state.height}px` : '',\n        width: state.fixed ? `${state.width}px` : '',\n      }\n    })\n\n    const affixStyle = computed<CSSProperties | undefined>(() => {\n      if (!state.fixed) return\n\n      const offset = props.offset ? `${props.offset}px` : 0\n      const transform = state.transform\n        ? `translateY(${state.transform}px)`\n        : ''\n\n      return {\n        height: `${state.height}px`,\n        width: `${state.width}px`,\n        top: props.position === 'top' ? offset : '',\n        bottom: props.position === 'bottom' ? offset : '',\n        transform,\n        zIndex: props.zIndex,\n      }\n    })\n\n    const update = () => {\n      if (!root.value || !target.value || !scrollContainer.value) return\n\n      const rootRect = root.value.getBoundingClientRect()\n      const targetRect = target.value.getBoundingClientRect()\n      state.height = rootRect.height\n      state.width = rootRect.width\n      state.scrollTop =\n        scrollContainer.value instanceof Window\n          ? document.documentElement.scrollTop\n          : scrollContainer.value.scrollTop || 0\n      state.clientHeight = document.documentElement.clientHeight\n\n      if (props.position === 'top') {\n        if (props.target) {\n          const difference = targetRect.bottom - props.offset - state.height\n          state.fixed = props.offset > rootRect.top && targetRect.bottom > 0\n          state.transform = difference < 0 ? difference : 0\n        } else {\n          state.fixed = props.offset > rootRect.top\n        }\n      } else {\n        if (props.target) {\n          const difference =\n            state.clientHeight - targetRect.top - props.offset - state.height\n          state.fixed =\n            state.clientHeight - props.offset < rootRect.bottom &&\n            state.clientHeight > targetRect.top\n          state.transform = difference < 0 ? -difference : 0\n        } else {\n          state.fixed = state.clientHeight - props.offset < rootRect.bottom\n        }\n      }\n    }\n\n    const onScroll = () => {\n      update()\n\n      emit('scroll', {\n        scrollTop: state.scrollTop,\n        fixed: state.fixed,\n      })\n    }\n\n    watch(\n      () => state.fixed,\n      () => {\n        emit('change', state.fixed)\n      }\n    )\n\n    onMounted(() => {\n      if (props.target) {\n        target.value =\n          document.querySelector<HTMLElement>(props.target) ?? undefined\n        if (!target.value) {\n          throw new Error(`Target is not existed: ${props.target}`)\n        }\n      } else {\n        target.value = document.documentElement\n      }\n      scrollContainer.value = getScrollContainer(root.value!, true)\n    })\n\n    useEventListener(scrollContainer, 'scroll', onScroll)\n    useResizeObserver(root, () => update())\n    useResizeObserver(target, () => update())\n\n    return {\n      root,\n      state,\n      rootStyle,\n      affixStyle,\n      update,\n    }\n  },\n})\n</script>\n"],"names":[],"mappings":";;;;;AAkBA,aAAe,eAAe;;AAE9B,EAAE,KAAK,EAAE,UAAU;;AAEnB,EAAE,KAAK,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,EAAE;IACrB,MAAM,MAAM;;IAEZ,MAAM;IACN,MAAM,KAAK,GAAG;;MAEZ,MAAM,GAAG;MACT,KAAK,EAAE,CAAC;MACR,SAAS,EAAE,CAAC;MACZ,YAAY,EAAE,CAAC;;KAEhB,CAAC,CAAC;UACG;MACJ;QACE,MAAM,EAAE,KAAK,CAAC,QAAQ,CAAC;QACvB,KAAK,EAAE,KAAK,CAAC,KAAK,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG;OAC3C,CAAC;MACF,CAAC;IACH;;QAEI,OAAO;MACT;YACM,SAAS,GAAG,MAAM,SAAS,GAAG,CAAC,WAAW;aACzC;;;;QAIL,MAAM,EAAE,KAAK,SAAS,KAAK,QAAQ,GAAG,MAAM,GAAG,EAAE;iBACxC;;OAEV,CAAC;MACF,CAAC;UACG,MAAM,GAAG,MAAM;UACf,CAAC;;MAEL;YACM,UAAU,GAAG,MAAM,CAAC;WACrB,CAAC,MAAM,GAAG,QAAQ,CAAC;WACnB,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC;WACxB,CAAC,SAAS,GAAG,eAAe,CAAC,iBAAiB;WAC9C,CAAC;UACF,MAAM,QAAQ;;;;UAId,KAAK,UAAU;SAChB,MAAM;;SAEN;OACF,MAAM;QACL,IAAI,KAAK,OAAO,EAAE;UAChB,MAAM,UAAU,GAAG;UACnB,KAAK,CAAC;UACN,KAAK,CAAC,SAAS,GAAG,UAAU,GAAG,CAAC,GAAG,CAAC;eAC/B;UACL,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,YAAY,GAAG;SACpC;;MAEH;kBACY,GAAG;YACT,EAAE;UACJ,CAAC,QAAQ;iBACF,EAAE,KAAK,UAAU;QAC1B,KAAK,EAAE;;;SAGN,CAAC;WACC,QAAQ,EAAE,KAAK;;aAEb,CAAC,MAAM;UACV,EAAE,CAAC;eACE,CAAC,MAAM,EAAE;cACV,CAAC,KAAK,GAAG,CAAC,EAAE,GAAG,QAAQ,CAAC;YAC1B,CAAC,MAAM,CAAC;UACV;;;;;;KAML,CAAC,CAAC;;;qBAGc;WACV;UACD;MACJ;;;MAGA;MACA;;;;;;"}