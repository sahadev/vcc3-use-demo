import { defineComponent, ref, inject, computed, unref, nextTick } from 'vue';
import '../../popper/index.mjs';
import '../../visual-hidden/index.mjs';
import { ElTeleport } from '../../teleport/index.mjs';
import { composeEventHandlers } from '../../../utils/dom.mjs';
import '../../../hooks/index.mjs';
import { useTooltipContentProps } from './tooltip.mjs';
import { TOOLTIP_INJECTION_KEY } from './tokens.mjs';
import script$1 from '../../popper/src/content.vue_vue_type_script_lang.mjs';
import script$2 from '../../visual-hidden/src/visual-hidden.vue_vue_type_script_lang.mjs';
import { useEscapeKeydown } from '../../../hooks/use-escape-keydown/index.mjs';
import { useDelayedRender } from '../../../hooks/use-intermediate-render/index.mjs';
import { POPPER_CONTAINER_SELECTOR } from '../../../hooks/use-popper-container/index.mjs';

var script = defineComponent({
  name: "ElTooltipContent",
  components: {
    ElTeleport,
    ElPopperContent: script$1,
    ElVisuallyHidden: script$2
  },
  inheritAttrs: false,
  props: useTooltipContentProps,
  setup(props) {
    const contentRef = ref(null);
    const intermediateOpen = ref(false);
    const entering = ref(false);
    const leaving = ref(false);
    const { controlled, id, open, trigger, onClose, onOpen, onShow, onHide } = inject(TOOLTIP_INJECTION_KEY, void 0);
    const persistentRef = computed(() => {
      if (process.env.NODE_ENV === "test") {
        return true;
      }
      return props.persistent;
    });
    const contentStyle = computed(() => {
      var _a;
      return (_a = props.style) != null ? _a : {};
    });
    const shouldRenderTeleport = computed(() => {
      if (unref(persistentRef))
        return true;
      return unref(unref(entering) ? open : intermediateOpen);
    });
    const shouldRenderPopperContent = computed(() => {
      if (unref(persistentRef))
        return true;
      return unref(unref(leaving) ? open : intermediateOpen);
    });
    const shouldShowPopperContent = computed(() => {
      if (unref(persistentRef)) {
        return unref(unref(leaving) ? open : intermediateOpen);
      }
      return true;
    });
    const ariaHidden = computed(() => !(unref(shouldRenderPopperContent) && unref(shouldShowPopperContent)));
    useEscapeKeydown(onClose);
    useDelayedRender({
      indicator: open,
      intermediateIndicator: intermediateOpen,
      shouldSetIntermediate: (step) => {
        return step === "hide" ? false : true;
      },
      beforeShow: () => {
        if (unref(leaving)) {
          leaving.value = false;
          intermediateOpen.value = false;
        }
        entering.value = true;
      },
      beforeHide: () => {
        if (unref(entering)) {
          entering.value = false;
          return;
        }
        leaving.value = true;
      },
      afterShow: () => {
        if (!unref(open))
          return;
        entering.value = false;
        onShow();
        nextTick(() => {
          var _a;
          (_a = unref(contentRef)) == null ? void 0 : _a.updatePopper();
        });
      },
      afterHide: () => {
        if (unref(open))
          return;
        onHide();
      }
    });
    const onTransitionLeave = () => {
      if (unref(open))
        return;
      leaving.value = false;
      intermediateOpen.value = false;
    };
    const stopWhenControlled = () => {
      if (unref(controlled))
        return true;
    };
    const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
      if (props.enterable) {
        onOpen();
      }
    });
    const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
      if (unref(trigger) === "hover") {
        onClose();
      }
    });
    return {
      ariaHidden,
      entering,
      leaving,
      id,
      intermediateOpen,
      contentStyle,
      contentRef,
      shouldRenderTeleport,
      shouldRenderPopperContent,
      shouldShowPopperContent,
      open,
      POPPER_CONTAINER_SELECTOR,
      onContentEnter,
      onContentLeave,
      onTransitionLeave
    };
  }
});

export { script as default };
//# sourceMappingURL=content.vue_vue_type_script_lang.mjs.map
