'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
require('../../../hooks/index.js');
var dom = require('../../../utils/dom.js');
var aria = require('../../../utils/aria.js');
var rovingFocusGroup = require('./roving-focus-group.js');
var tokens = require('./tokens.js');
var utils = require('./utils.js');
var index = require('../../../hooks/use-id/index.js');

var script = vue.defineComponent({
  components: {
    ElRovingFocusCollectionItem: rovingFocusGroup.ElCollectionItem
  },
  props: {
    focusable: {
      type: Boolean,
      default: true
    },
    active: {
      type: Boolean,
      default: false
    }
  },
  emits: ["mousedown", "focus", "keydown"],
  setup(props, { emit }) {
    const { currentTabbedId, loop, onItemFocus, onItemShiftTab } = vue.inject(tokens.ROVING_FOCUS_GROUP_INJECTION_KEY, void 0);
    const { getItems } = vue.inject(rovingFocusGroup.ROVING_FOCUS_COLLECTION_INJECTION_KEY, void 0);
    const id = index.useId();
    const rovingFocusGroupItemRef = vue.ref(null);
    const handleMousedown = dom.composeEventHandlers((e) => {
      emit("mousedown", e);
    }, (e) => {
      if (!props.focusable) {
        e.preventDefault();
      } else {
        onItemFocus(vue.unref(id));
      }
    });
    const handleFocus = dom.composeEventHandlers((e) => {
      emit("focus", e);
    }, () => {
      onItemFocus(vue.unref(id));
    });
    const handleKeydown = dom.composeEventHandlers((e) => {
      emit("keydown", e);
    }, (e) => {
      const { key, shiftKey, target, currentTarget } = e;
      if (key === aria.EVENT_CODE.tab && shiftKey) {
        onItemShiftTab();
        return;
      }
      if (target !== currentTarget)
        return;
      const focusIntent = utils.getFocusIntent(e);
      if (focusIntent) {
        e.preventDefault();
        const items = getItems().filter((item) => item.focusable);
        let elements = items.map((item) => item.ref);
        switch (focusIntent) {
          case "last": {
            elements.reverse();
            break;
          }
          case "prev":
          case "next": {
            if (focusIntent === "prev") {
              elements.reverse();
            }
            const currentIdx = elements.indexOf(currentTarget);
            elements = loop.value ? utils.reorderArray(elements, currentIdx + 1) : elements.slice(currentIdx + 1);
            break;
          }
          default: {
            break;
          }
        }
        vue.nextTick(() => {
          utils.focusFirst(elements);
        });
      }
    });
    const isCurrentTab = vue.computed(() => currentTabbedId.value === vue.unref(id));
    vue.provide(tokens.ROVING_FOCUS_GROUP_ITEM_INJECTION_KEY, {
      rovingFocusGroupItemRef,
      tabIndex: vue.computed(() => vue.unref(isCurrentTab) ? 0 : -1),
      handleMousedown,
      handleFocus,
      handleKeydown
    });
    return {
      id,
      handleKeydown,
      handleFocus,
      handleMousedown
    };
  }
});

exports["default"] = script;
//# sourceMappingURL=roving-focus-item.vue_vue_type_script_lang.js.map
