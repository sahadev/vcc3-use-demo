'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
require('../../popper/index.js');
require('../../visual-hidden/index.js');
var index = require('../../teleport/index.js');
var dom = require('../../../utils/dom.js');
require('../../../hooks/index.js');
var tooltip = require('./tooltip.js');
var tokens = require('./tokens.js');
var content_vue_vue_type_script_lang = require('../../popper/src/content.vue_vue_type_script_lang.js');
var visualHidden_vue_vue_type_script_lang = require('../../visual-hidden/src/visual-hidden.vue_vue_type_script_lang.js');
var index$1 = require('../../../hooks/use-escape-keydown/index.js');
var index$2 = require('../../../hooks/use-intermediate-render/index.js');
var index$3 = require('../../../hooks/use-popper-container/index.js');

var script = vue.defineComponent({
  name: "ElTooltipContent",
  components: {
    ElTeleport: index.ElTeleport,
    ElPopperContent: content_vue_vue_type_script_lang["default"],
    ElVisuallyHidden: visualHidden_vue_vue_type_script_lang["default"]
  },
  inheritAttrs: false,
  props: tooltip.useTooltipContentProps,
  setup(props) {
    const contentRef = vue.ref(null);
    const intermediateOpen = vue.ref(false);
    const entering = vue.ref(false);
    const leaving = vue.ref(false);
    const { controlled, id, open, trigger, onClose, onOpen, onShow, onHide } = vue.inject(tokens.TOOLTIP_INJECTION_KEY, void 0);
    const persistentRef = vue.computed(() => {
      if (process.env.NODE_ENV === "test") {
        return true;
      }
      return props.persistent;
    });
    const contentStyle = vue.computed(() => {
      var _a;
      return (_a = props.style) != null ? _a : {};
    });
    const shouldRenderTeleport = vue.computed(() => {
      if (vue.unref(persistentRef))
        return true;
      return vue.unref(vue.unref(entering) ? open : intermediateOpen);
    });
    const shouldRenderPopperContent = vue.computed(() => {
      if (vue.unref(persistentRef))
        return true;
      return vue.unref(vue.unref(leaving) ? open : intermediateOpen);
    });
    const shouldShowPopperContent = vue.computed(() => {
      if (vue.unref(persistentRef)) {
        return vue.unref(vue.unref(leaving) ? open : intermediateOpen);
      }
      return true;
    });
    const ariaHidden = vue.computed(() => !(vue.unref(shouldRenderPopperContent) && vue.unref(shouldShowPopperContent)));
    index$1.useEscapeKeydown(onClose);
    index$2.useDelayedRender({
      indicator: open,
      intermediateIndicator: intermediateOpen,
      shouldSetIntermediate: (step) => {
        return step === "hide" ? false : true;
      },
      beforeShow: () => {
        if (vue.unref(leaving)) {
          leaving.value = false;
          intermediateOpen.value = false;
        }
        entering.value = true;
      },
      beforeHide: () => {
        if (vue.unref(entering)) {
          entering.value = false;
          return;
        }
        leaving.value = true;
      },
      afterShow: () => {
        if (!vue.unref(open))
          return;
        entering.value = false;
        onShow();
        vue.nextTick(() => {
          var _a;
          (_a = vue.unref(contentRef)) == null ? void 0 : _a.updatePopper();
        });
      },
      afterHide: () => {
        if (vue.unref(open))
          return;
        onHide();
      }
    });
    const onTransitionLeave = () => {
      if (vue.unref(open))
        return;
      leaving.value = false;
      intermediateOpen.value = false;
    };
    const stopWhenControlled = () => {
      if (vue.unref(controlled))
        return true;
    };
    const onContentEnter = dom.composeEventHandlers(stopWhenControlled, () => {
      if (props.enterable) {
        onOpen();
      }
    });
    const onContentLeave = dom.composeEventHandlers(stopWhenControlled, () => {
      if (vue.unref(trigger) === "hover") {
        onClose();
      }
    });
    return {
      ariaHidden,
      entering,
      leaving,
      id,
      intermediateOpen,
      contentStyle,
      contentRef,
      shouldRenderTeleport,
      shouldRenderPopperContent,
      shouldShowPopperContent,
      open,
      POPPER_CONTAINER_SELECTOR: index$3.POPPER_CONTAINER_SELECTOR,
      onContentEnter,
      onContentLeave,
      onTransitionLeave
    };
  }
});

exports["default"] = script;
//# sourceMappingURL=content.vue_vue_type_script_lang.js.map
