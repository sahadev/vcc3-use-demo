'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var index$1 = require('../../popper/index.js');
var error = require('../../../utils/error.js');
var util = require('../../../utils/util.js');
require('../../../hooks/index.js');
require('./content.js');
require('./trigger.js');
var tooltip = require('./tooltip.js');
var tokens = require('./tokens.js');
var index = require('../../../hooks/use-model-toggle/index.js');
var arrow_vue_vue_type_script_lang = require('../../popper/src/arrow.vue_vue_type_script_lang.js');
var content_vue_vue_type_script_lang = require('./content.vue_vue_type_script_lang.js');
var trigger_vue_vue_type_script_lang = require('./trigger.vue_vue_type_script_lang.js');
var popper = require('../../popper/src/popper.js');
var index$2 = require('../../../hooks/use-popper-container/index.js');
var index$3 = require('../../../hooks/use-id/index.js');
var index$4 = require('../../../hooks/use-delayed-toggle/index.js');

const { useModelToggleProps, useModelToggle, useModelToggleEmits } = index.createModelToggleComposable("visible");
var script = vue.defineComponent({
  name: "ElTooltip",
  components: {
    ElPopper: index$1.ElPopper,
    ElPopperArrow: arrow_vue_vue_type_script_lang["default"],
    ElTooltipContent: content_vue_vue_type_script_lang["default"],
    ElTooltipTrigger: trigger_vue_vue_type_script_lang["default"]
  },
  props: {
    ...useModelToggleProps,
    ...tooltip.useTooltipContentProps,
    ...tooltip.useTooltipTriggerProps,
    ...popper.usePopperArrowProps,
    ...tooltip.useTooltipProps
  },
  emits: [...useModelToggleEmits, "show", "hide"],
  setup(props, { emit }) {
    index$2.usePopperContainer();
    const compatShowAfter = vue.computed(() => {
      if (!util.isUndefined(props.openDelay)) {
        error.debugWarn("ElTooltip", "open-delay is about to be deprecated in the next major version, please use `show-after` instead");
      }
      return props.openDelay || props.showAfter;
    });
    const compatShowArrow = vue.computed(() => {
      if (!util.isUndefined(props.visibleArrow)) {
        error.debugWarn("ElTooltip", "`visible-arrow` is about to be deprecated in the next major version, please use `show-arrow` instead");
      }
      return util.isBool(props.visibleArrow) ? props.visibleArrow : props.showArrow;
    });
    const id = index$3.useId();
    const popperRef = vue.ref(null);
    const updatePopper = () => {
      var _a;
      const popperComponent = vue.unref(popperRef);
      if (popperComponent) {
        (_a = popperComponent.popperInstanceRef) == null ? void 0 : _a.update();
      }
    };
    const open = vue.ref(false);
    const { show, hide } = useModelToggle({
      indicator: open
    });
    const { onOpen, onClose } = index$4.useDelayedToggle({
      showAfter: compatShowAfter,
      hideAfter: vue.toRef(props, "hideAfter"),
      open: show,
      close: hide
    });
    const controlled = vue.computed(() => util.isBool(props.visible));
    vue.provide(tokens.TOOLTIP_INJECTION_KEY, {
      controlled,
      id,
      open: vue.readonly(open),
      trigger: vue.toRef(props, "trigger"),
      onOpen,
      onClose,
      onToggle: () => {
        if (vue.unref(open)) {
          onClose();
        } else {
          onOpen();
        }
      },
      onShow: () => {
        emit("show");
      },
      onHide: () => {
        emit("hide");
      }
    });
    return {
      compatShowAfter,
      compatShowArrow,
      popperRef,
      open,
      updatePopper,
      onOpen,
      onClose
    };
  }
});

exports["default"] = script;
//# sourceMappingURL=tooltip.vue_vue_type_script_lang.js.map
